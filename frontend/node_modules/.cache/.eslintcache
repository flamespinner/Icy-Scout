[{"C:\\Users\\Michael Wilke\\Desktop\\Scout\\frontend\\src\\index.js":"1","C:\\Users\\Michael Wilke\\Desktop\\Scout\\frontend\\src\\App.js":"2","C:\\Users\\Michael Wilke\\Desktop\\Scout\\frontend\\src\\reportWebVitals.js":"3","C:\\Users\\Michael Wilke\\Desktop\\Scout\\frontend\\src\\components\\Nav.js":"4","C:\\Users\\Michael Wilke\\Desktop\\Scout\\frontend\\src\\components\\graphcard.js":"5","C:\\Users\\Michael Wilke\\Desktop\\Scout\\frontend\\src\\components\\3dchart.js":"6","C:\\Users\\Michael Wilke\\Desktop\\Scout\\frontend\\src\\components\\RGraph.common.core.js":"7","C:\\Users\\Michael Wilke\\Desktop\\Scout\\frontend\\src\\components\\RGraph.bar.js":"8"},{"size":632,"mtime":1645726140647,"results":"9","hashOfConfig":"10"},{"size":650,"mtime":1645884027592,"results":"11","hashOfConfig":"10"},{"size":362,"mtime":1645725506482,"results":"12","hashOfConfig":"10"},{"size":999,"mtime":1645884046786,"results":"13","hashOfConfig":"10"},{"size":793,"mtime":1645884015680,"results":"14","hashOfConfig":"10"},{"size":7254,"mtime":1645848923262,"results":"15","hashOfConfig":"10"},{"size":313068,"mtime":1645845636046,"results":"16","hashOfConfig":"10"},{"size":149221,"mtime":1645845635982,"results":"17","hashOfConfig":"10"},{"filePath":"18","messages":"19","suppressedMessages":"20","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"21"},"116641j",{"filePath":"22","messages":"23","suppressedMessages":"24","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"25","messages":"26","suppressedMessages":"27","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"21"},{"filePath":"28","messages":"29","suppressedMessages":"30","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"31","messages":"32","suppressedMessages":"33","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"34","messages":"35","suppressedMessages":"36","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"37"},{"filePath":"38","messages":"39","suppressedMessages":"40","errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"41","usedDeprecatedRules":"42"},{"filePath":"43","messages":"44","suppressedMessages":"45","errorCount":174,"fatalErrorCount":0,"warningCount":143,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"C:\\Users\\Michael Wilke\\Desktop\\Scout\\frontend\\src\\index.js",[],[],["46","47"],"C:\\Users\\Michael Wilke\\Desktop\\Scout\\frontend\\src\\App.js",["48","49","50","51","52","53"],[],"C:\\Users\\Michael Wilke\\Desktop\\Scout\\frontend\\src\\reportWebVitals.js",[],[],"C:\\Users\\Michael Wilke\\Desktop\\Scout\\frontend\\src\\components\\Nav.js",[],[],"C:\\Users\\Michael Wilke\\Desktop\\Scout\\frontend\\src\\components\\graphcard.js",["54"],[],"C:\\Users\\Michael Wilke\\Desktop\\Scout\\frontend\\src\\components\\3dchart.js",[],[],["55","56"],"C:\\Users\\Michael Wilke\\Desktop\\Scout\\frontend\\src\\components\\RGraph.common.core.js",["57"],[],"// Version: 2022-01-22\n//\n    // o--------------------------------------------------------------------------------o\n    // | This file is part of the RGraph package - you can learn more at:               |\n    // |                                                                                |\n    // |                         https://www.rgraph.net                                 |\n    // |                                                                                |\n    // | RGraph is licensed under the Open Source MIT license. That means that it's     |\n    // | totally free to use and there are no restrictions on what you can do with it!  |\n    // o--------------------------------------------------------------------------------o\n\n    window.RGraph = window.RGraph || {isrgraph:true,isRGraph: true,rgraph:true};\n\n// Module pattern\n(function (win, doc, undefined)\n{\n    // A short name variable\n    var ua  = navigator.userAgent;\n\n    //\n    // Initialise the various objects\n    //\n    RGraph.Highlight      = {};\n    RGraph.Registry       = {};\n    RGraph.Registry.store = [];\n    RGraph.Registry.store['event.handlers']       = [];\n    RGraph.Registry.store['__rgraph_event_listeners__'] = []; // Used in the new system for tooltips\n    RGraph.Background     = {};\n    RGraph.background     = {};\n    RGraph.objects        = [];\n    RGraph.Resizing       = {};\n    RGraph.events         = [];\n    RGraph.cursor         = [];\n    RGraph.Effects        = RGraph.Effects || {};\n    RGraph.cache          = [];\n    RGraph.QS             =\n    RGraph.GET            = {};\n    RGraph.GET.__parts__  = null;\n\n    RGraph.ObjectRegistry                    = {};\n    RGraph.ObjectRegistry.objects            = {};\n    RGraph.ObjectRegistry.objects.byUID      = [];\n    RGraph.ObjectRegistry.objects.byCanvasID = [];\n    RGraph.OR                                = RGraph.ObjectRegistry;\n\n\n\n\n    //\n    // Some \"constants\". The ua variable is navigator.userAgent (definedabove)\n    //\n    RGraph.PI       = Math.PI;\n    RGraph.HALFPI   = RGraph.PI / 2;\n    RGraph.TWOPI    = RGraph.PI * 2;\n\n    RGraph.ISFF     = ua.indexOf('Firefox') != -1;\n    RGraph.ISOPERA  = ua.indexOf('Opera') != -1;\n    RGraph.ISCHROME = ua.indexOf('Chrome') != -1;\n    RGraph.ISSAFARI = ua.indexOf('Safari') != -1 && !RGraph.ISCHROME;\n    RGraph.ISWEBKIT = ua.indexOf('WebKit') != -1;\n\n    RGraph.ISIE   = ua.indexOf('Trident') > 0 || navigator.userAgent.indexOf('MSIE') > 0;\n    RGraph.ISIE6  = ua.indexOf('MSIE 6') > 0;\n    RGraph.ISIE7  = ua.indexOf('MSIE 7') > 0;\n    RGraph.ISIE8  = ua.indexOf('MSIE 8') > 0;\n    RGraph.ISIE9  = ua.indexOf('MSIE 9') > 0;\n    RGraph.ISIE10 = ua.indexOf('MSIE 10') > 0;\n    RGraph.ISOLD  = RGraph.ISIE6 || RGraph.ISIE7 || RGraph.ISIE8; // MUST be here\n    \n    RGraph.ISIE11UP = ua.indexOf('MSIE') == -1 && ua.indexOf('Trident') > 0;\n    RGraph.ISIE10UP = RGraph.ISIE10 || RGraph.ISIE11UP;\n    RGraph.ISIE9UP  = RGraph.ISIE9 || RGraph.ISIE10UP;\n\n    // Some commonly used bits of info\n    RGraph.MONTHS_SHORT = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];\n    RGraph.MONTHS_LONG  = ['January','February','March','April','May','June','July','August','September','October','November','December'];\n    RGraph.DAYS_SHORT   = ['Mon','Tue','Wed','Thu','Fri','Sat','Sun'];\n    RGraph.DAYS_LONG    = ['Monday','Tuesday','Wednesday','Thursday','Friday','Saturday','Sunday'];\n    RGraph.HOURS24      = ['00:00','01:00','02:00','03:00','04:00','05:00','06:00','07:00','08:00','09:00','10:00','11:00','12:00','13:00','14:00','15:00','16:00','17:00','18:00','19:00','20:00','21:00','22:00','23:00'];\n    RGraph.HOURS12      = ['00:00','01:00','02:00','03:00','04:00','05:00','06:00','07:00','08:00','09:00','10:00','11:00'];\n\n\n\n    //\n    // Returns five values which are used as a nice scale\n    // \n    // 11/12/2018\n    // ==========\n    // This funtction doesn't appear to be being used\n    // any more - could remove it.\n    // \n    // @param  max int    The maximum value of the graph\n    // @param  obj object The graph object\n    // @return     array   An appropriate scale\n    //\n//    RGraph.getScale = function (max, obj)\n//    {\n//        var prefix = obj.type === 'hbar' ? 'xaxis' : 'yaxis';\n//\n//        //\n//        // Special case for 0\n//        //\n//        if (max == 0) {\n//            return ['0.2', '0.4', '0.6', '0.8', '1.0'];\n//        }\n//\n//        var original_max = max;\n//\n//        //\n//        // Manually do decimals\n//        //\n//        if (max <= 1) {\n//            if (max > 0.5) {\n//                return [0.2,0.4,0.6,0.8, Number(1).toFixed(1)];\n//\n//            } else if (max >= 0.1) {\n//                return obj.get(prefix + 'ScaleRound') ? [0.2,0.4,0.6,0.8,1] : [0.1,0.2,0.3,0.4,0.5];\n//\n//            } else {\n//\n//                var tmp = max;\n//                var exp = 0;\n//\n//                while (tmp < 1.01) {\n//                    exp += 1;\n//                    tmp *= 10;\n//                }\n//\n//                var ret = ['2e-' + exp, '4e-' + exp, '6e-' + exp, '8e-' + exp, '10e-' + exp];\n//\n//\n//                if (max <= ('5e-' + exp)) {\n//                    ret = ['1e-' + exp, '2e-' + exp, '3e-' + exp, '4e-' + exp, '5e-' + exp];\n//                }\n//\n//                return ret;\n//            }\n//        }\n//\n//        // Take off any decimals\n//        if (String(max).indexOf('.') > 0) {\n//            max = String(max).replace(/\\.\\d+$/, '');\n//        }\n//\n//        var interval = Math.pow(10, Number(String(Number(max)).length - 1));\n//        var topValue = interval;\n//\n//        while (topValue < max) {\n//            topValue += (interval / 2);\n//        }\n//\n//        // Handles cases where the max is (for example) 50.5\n//        if (Number(original_max) > Number(topValue)) {\n//            topValue += (interval / 2);\n//        }\n//\n//        // Custom if the max is greater than 5 and less than 10\n//        if (max < 10) {\n//            topValue = (Number(original_max) <= 5 ? 5 : 10);\n//        }\n//        \n//        //\n//        // Added 02/11/2010 to create \"nicer\" scales\n//        //\n//        if (obj && typeof obj.get(prefix + 'ScaleRound') == 'boolean' && obj.get(prefix + 'ScaleRound')) {\n//            topValue = 10 * interval;\n//        }\n//\n//        return [topValue * 0.2, topValue * 0.4, topValue * 0.6, topValue * 0.8, topValue];\n//    };\n\n\n\n\n\n\n\n\n    //\n    // This function allows both object based arguments to functions\n    // and also regular arguments as well.\n    //\n    // You can call it from inside a function like this:\n    //\n    // args = RGraph.getArgs(arguments, 'object,id,foo,bar');\n    //\n    // So you're passing it the arguments object and a comma seperated list of names\n    // for the arguments.\n    //\n    // @param array args   The arguments object that you get when inside a function\n    // @param string names A comma seperated list of desired names for the arguments\n    //                     eg: 'object,color,size'\n    //\n    RGraph.getArgs = function (args, names)\n    {\n        var ret   = {};\n        var count = 0;\n        names     = names.trim().split(/ *, */);\n\n        if (   args\n            && args[0]\n            && args.length === 1\n            && typeof args[0][names[0]] !== 'undefined') {\n            \n            for (var i=0; i<names.length; ++i) {\n                if (typeof args[0][names[i]] === 'undefined') {\n                    args[0][names[i]] = null;\n                }\n            }\n\n            return args[0];\n        } else {\n            for (var i in names) {\n                ret[names[i]] = typeof args[count] === 'undefined' ? null : args[count];\n                \n                count += 1;\n            }\n        }\n\n        return ret;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Returns an appropriate scale. The return value is actualy an object consisting of:\n    //  scale.max\n    //  scale.min\n    //  scale.scale\n    //\n    // @param  args object An object consisting of:\n    //                     object  - The chart object\n    //                     options - Options for the function\n    //\n    // @return     object  An object containing scale information\n    //\n    RGraph.getScale  = function (args)\n    {\n        var properties   = args.object.properties,\n            numlabels    = typeof args.options['scale.labels.count'] == 'number' ? args.options['scale.labels.count'] : 5,\n            units_pre    = typeof args.options['scale.units.pre'] == 'string' ? args.options['scale.units.pre'] : '',\n            units_post   = typeof args.options['scale.units.post'] == 'string' ? args.options['scale.units.post'] : '',\n            max          = Number(args.options['scale.max']),\n            min          = typeof args.options['scale.min'] == 'number' ? args.options['scale.min'] : 0,\n            strict       = args.options['scale.strict'],\n            decimals     = Number(args.options['scale.decimals']), // Sometimes the default is null\n            point        = args.options['scale.point'], // Default is a string in all chart libraries so no need to cast it\n            thousand     = args.options['scale.thousand'], // Default is a string in all chart libraries so no need to cast it\n            original_max = max,\n            round        = args.options['scale.round'],\n            scale        = {max:1,labels:[],values:[]},\n            formatter    = args.options['scale.formatter'];\n\n            // Determine any prefix to use\n            prefix = args.object.type === 'hbar' ? 'xaxis' : 'yaxis';\n            prefix = args.object.type === 'odo' ? '' : prefix;\n\n\n\n\n\n        //\n        // Special case for 0\n        // \n        // ** Must be first **\n        //\n        if (!max) {\n\n            var max   = 1;\n\n            for (var i=0; i<numlabels; ++i) {\n\n                var label = ((((max - min) / numlabels) + min) * (i + 1)).toFixed(decimals);\n\n                scale.labels.push(units_pre + label + units_post);\n                scale.values.push(parseFloat(label))\n            }\n\n        //\n        // Manually do decimals\n        //\n        } else if (max <= 1 && !strict) {\n\n            var arr = [\n                1,0.5,\n                0.10,0.05,\n                0.010,0.005,\n                0.0010,0.0005,\n                0.00010,0.00005,\n                0.000010,0.000005,\n                0.0000010,0.0000005,\n                0.00000010,0.00000005,\n                0.000000010,0.000000005,\n                0.0000000010,0.0000000005,\n                0.00000000010,0.00000000005,\n                0.000000000010,0.000000000005,\n                0.0000000000010,0.0000000000005\n            ], vals = [];\n\n\n\n            for (var i=0; i<arr.length; ++i) {\n                if (max > arr[i]) {\n                    i--;\n                    break;\n                }\n            }\n\n\n            scale.max    = arr[i];\n            scale.labels = [];\n            scale.values = [];\n        \n            for (var j=0; j<numlabels; ++j) {\n\n                var value = ((((arr[i] - min) / numlabels) * (j + 1)) + min).toFixed(decimals);\n\n                scale.values.push(value);\n                scale.labels.push(RGraph.numberFormat({\n                    object:    args.object,\n                    number:    value,\n                    unitspre:  units_pre,\n                    unitspost: units_post,\n                    thousand:  thousand,\n                    point:     point,\n                    formatter: formatter,\n                    decimals:  decimals\n                }));\n            }\n\n\n\n\n        } else if (!strict) {\n\n            //\n            // Now comes the scale handling for integer values\n            //\n\n            // This accommodates decimals by rounding the max up to the next integer\n            max = Math.ceil(max);\n\n            var interval = Math.pow(10, Math.max(1, Number(String(Number(max) - Number(min)).length - 1)) );\n\n            var topValue = interval;\n\n            while (topValue < max) {\n                topValue += (interval / 2);\n            }\n\n            // Handles cases where the max is (for example) 50.5\n            if (Number(original_max) > Number(topValue)) {\n                topValue += (interval / 2);\n            }\n\n            // Custom if the max is greater than 5 and less than 10\n            if (max <= 10) {\n                topValue = (Number(original_max) <= 5 ? 5 : 10);\n            }\n    \n    \n            // Added 02/11/2010 to create \"nicer\" scales\n            if (args.object && typeof round == 'boolean' && round) {\n                topValue = 10 * interval;\n            }\n\n            scale.max = topValue;\n\n            // Now generate the scale. Temporarily set the objects scaleDecimal and scalePoint to those\n            // that we've been given as the number_format functuion looks at those instead of using\n            // arguments.\n            var tmp_point    = properties[prefix + 'ScalePoint'];\n            var tmp_thousand = properties[prefix + 'ScaleThousand'];\n\n            args.object.set(prefix + 'scaleThousand', thousand);\n            args.object.set(prefix + 'scalePoint', point);\n\n\n            for (var i=0; i<numlabels; ++i) {\n                scale.labels.push(RGraph.numberFormat({\n                    object:    args.object,\n                    number:    ((((i+1) / numlabels) * (topValue - min)) + min).toFixed(decimals),\n                    unitspre:  units_pre,\n                    unitspost: units_post,\n                    point:     point,\n                    thousand:  thousand,\n                    formatter: formatter\n                }) );\n                scale.values.push(((((i+1) / numlabels) * (topValue - min)) + min).toFixed(decimals));\n            }\n\n            args.object.set(prefix + 'scaleThousand', tmp_thousand);\n            args.object.set(prefix + 'scalePoint', tmp_point);\n\n        } else if (typeof max == 'number' && strict) {\n\n            //\n            // ymax is set and also strict\n            //\n            for (var i=0; i<numlabels; ++i) {\n                scale.labels.push(RGraph.numberFormat({\n                    object:    args.object,\n                    number:    ((((i+1) / numlabels) * (max - min)) + min).toFixed(decimals),\n                    unitspre:  units_pre,\n                    unitspost: units_post,\n                    thousand:  thousand,\n                    point:     point,\n                    formatter: formatter\n                }));\n\n                scale.values.push(\n                    ((((i+1) / numlabels) * (max - min)) + min).toFixed(decimals)\n                );\n            }\n\n            // ???\n            scale.max = max;\n        }\n\n\n        scale.units_pre  = units_pre;\n        scale.units_post = units_post;\n        scale.point      = point;\n        scale.decimals   = decimals;\n        scale.thousand   = thousand;\n        scale.numlabels  = numlabels;\n        scale.round      = Boolean(round);\n        scale.min        = min;\n        scale.formatter  = formatter;\n\n        //\n        // Convert all of the scale values to numbers\n        //\n        for (var i=0; i<scale.values.length; ++i) {\n            scale.values[i] = parseFloat(scale.values[i]);\n        }\n\n        return scale;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Parse a gradient thats in JSON format like this:\n    //\n    // Gradient({colors: [\"red\",\"white\"],x1:0,y1:25,x2:0,y2:275})\n    //\n    // @param  args object An object consisting of:\n    //                      o object\n    //                      o Th gradient definition\n    //\n    RGraph.parseJSONGradient = function (args)\n    {\n        var obj      = args.object,\n            def      = args.def, // The gradient definition\n            context  = args.object.context;\n\n        // Evaluate the JSON\n        def = eval(\"(\" + def + \")\");\n\n\n\n\n\n        // Create a radial gradient\n        if (typeof def.r1 === 'number' && typeof def.r2 === 'number') {\n            // Create the gradient\n            var grad = context.createRadialGradient(\n                def.x1, def.y1, def.r1,\n                def.x2, def.y2, def.r2\n            );\n        // Create a linear gradient\n        } else {\n            var grad = context.createLinearGradient(\n                def.x1, def.y1,\n                def.x2, def.y2\n            );\n        }\n\n\n\n\n        // Add the parts to the gradient\n        var diff = 1 / (def.colors.length - 1);\n        \n        grad.addColorStop(0, RGraph.trim(def.colors[0]));\n        \n        for (var j=1,len=def.colors.length; j<len; ++j) {\n            grad.addColorStop(j * diff, RGraph.trim(def.colors[j]));\n        }\n\n        return grad;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Converts an the truthy values to falsey values and vice-versa\n    //\n    // @param  args object An object consisting of:\n    //                      o array\n    //\n    RGraph.arrayInvert = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'array');\n\n        for (var i=0,len=args.array.length; i<len; ++i) {\n            args.array[i] = !args.array[i];\n        }\n\n        return args.array;\n    };\n\n\n\n\n\n\n\n\n    //\n    // An arrayTrim function that removes the empty elements off\n    // both ends\n    //\n    // @param  args object An object consisting of:\n    //                      o array\n    // OR\n    //\n    //@param        array The array to trim\n    //\n    RGraph.arrayTrim = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'array');\n        var out = [], content = false;\n\n        // Trim the start\n        for (var i=0; i<args.array.length; i++) {\n        \n            if (args.array[i]) {\n                content = true;\n            }\n        \n            if (content) {\n                out.push(args.array[i]);\n            }\n        }\n        \n        // Reverse the array and trim the start again\n        out = RGraph.arrayReverse(out);\n\n        var out2 = [], content = false ;\n        for (var i=0; i<out.length; i++) {\n        \n            if (out[i]) {\n                content = true;\n            }\n        \n            if (content) {\n                out2.push(out[i]);\n            }\n        }\n        \n        // Now reverse the array and return it\n        out2 = RGraph.arrayReverse(out2);\n\n        return out2;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Makes a clone of an ARRAY\n    //\n    // @param args object An object containg the array to clone\n    // \n    // OR\n    //\n    // @param args mixed The object to clone\n    //\n    RGraph.arrayClone = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'array');\n\n        if(args.array === null || typeof args.array !== 'object') {\n            return args.array;\n        }\n\n        return JSON.parse(JSON.stringify(args.array));\n\n        //var temp = RGraph.isArray(args.array) ? [] : {};\n        //\n        //for (var i in args.array) {\n        //    if (typeof i === 'string' || typeof i === 'number' ) {\n        //        if (typeof args.array[i]  === 'number') {\n        //            temp[i] = (function (arg) {return Number(arg);})(args.array[i]);\n        //        \n        //        } else if (typeof args.array[i]  === 'string') {\n        //            temp[i] = (function (arg) {return String(arg);})(args.array[i]);\n        //        \n        //        } else if (typeof args.array[i] === 'function') {\n        //            temp[i] = args.array[i];\n        //        \n        //        } else {\n        //            temp[i] = RGraph.arrayClone(args.array[i]);\n        //        }\n        //    }\n        //}\n\n        //return temp;\n    };\n\n\n\n\n\n\n\n\n    //\n    // An alias of the above function\n    //\n    RGraph.clone = RGraph.arrayClone;\n\n\n\n\n\n\n\n\n    //\n    // Returns the maximum numeric value which is in an array. This function IS NOT\n    // recursive\n    // \n    // @param object args An object consisting of an array property which is the array to get\n    //                    the max value of.\n    //\n    // OR\n    //\n    // @param  array arr The array (can also be a number, in which case it's returned as-is)\n    // @param  int       Whether to ignore signs (ie negative/positive)\n    // @return int       The maximum value in the array\n    //\n    RGraph.arrayMax = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'array,ignore');\n        var max = null;\n        \n        if (typeof args.array === 'number') {\n            return args.array;\n        }\n        \n        if (RGraph.isNull(args.array)) {\n            return 0;\n        }\n\n        for (var i=0,len=args.array.length; i<len; ++i) {\n            if (typeof args.array[i] === 'number' && !isNaN(args.array[i])) {\n\n                var val = args.ignore ? Math.abs(args.array[i]) : args.array[i];\n                \n                if (typeof max === 'number') {\n                    max = Math.max(max, val);\n                } else {\n                    max = val;\n                }\n            }\n        }\n\n        return max;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Returns the minimum numeric value which is in an array\n    // \n    // @param  object args An object consisting of the array to find the min of\n    //\n    // OR\n    //\n    // @param  array arr The array (can also be a number, in which case it's returned as-is)\n    // @param  int       Whether to ignore signs (ie negative/positive)\n    // @return int       The minimum value in the array\n    //\n    RGraph.arrayMin = function (args)\n    {\n        var args = RGraph.getArgs(arguments, 'array,ignore');\n\n        var max = null,\n            min = null,\n            ma  = Math;\n        \n        if (typeof args.array === 'number') {\n            return args.array;\n        }\n        \n        if (RGraph.isNull(args.array)) {\n            return 0;\n        }\n\n        for (var i=0,len=args.array.length; i<len; ++i) {\n            if (typeof args.array[i] === 'number') {\n\n                var val = args.ignore ? Math.abs(args.array[i]) : args.array[i];\n                \n                if (typeof min === 'number') {\n                    min = Math.min(min, val);\n                } else {\n                    min = val;\n                }\n            }\n        }\n\n        return min;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Returns the maximum value which is in an array\n    // \n    // @param object args An object which consists of the arguments\n    //                    to the function. Keys should be: array, length\n    //\n    // OR\n    //\n    // @param  array arr The array\n    // @param  int   len The length to pad the array to\n    // @param  mixed     The value to use to pad the array (optional)\n    //\n    RGraph.arrayPad = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'array,length,value');\n\n        if (args.array.length < args.length) {            \n            for (var i=args.array.length; i<args.length; i+=1) {\n                args.array[i] = args.value;\n            }\n        }\n        \n        return args.array;\n    };\n\n\n\n\n\n\n\n\n    //\n    // An array sum function\n    // \n    // @param object args An object consisting of the argumments to the\n    //                    function\n    //\n    // OR\n    //\n    // @param  array arr The  array to calculate the total of\n    // @return int       The summed total of the arrays elements\n    //\n    RGraph.arraySum = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'array');\n\n        // Allow integers\n        if (typeof args.array === 'number') {\n            return args.array;\n        }\n        \n        // Account for null\n        if (RGraph.isNull(args.array)) {\n            return 0;\n        }\n\n        var i, sum, len = args.array.length;\n\n        for(i=0,sum=0;i<len;sum+=(args.array[i++]||0));\n\n        return sum;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Takes any number of arguments and adds them to one big linear array\n    // which is then returned\n    // \n    // @param ... mixed The data to linearise. You can strings, booleans, numbers or arrays\n    //\n    RGraph.arrayLinearize = function ()\n    {\n        var arr  = [],\n            args = arguments\n\n        for (var i=0,len=args.length; i<len; ++i) {\n\n            if (typeof args[i] === 'object' && args[i]) {\n                for (var j=0,len2=args[i].length; j<len2; ++j) {\n                    var sub = RGraph.arrayLinearize(args[i][j]);\n                    \n                    for (var k=0,len3=sub.length; k<len3; ++k) {\n                        arr.push(sub[k]);\n                    }\n                }\n            } else {\n                arr.push(args[i]);\n            }\n        }\n\n        return arr;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Takes one off the front of the given array and returns the new array.\n    //\n    // @param object args An object consisting of the array to linearise. \n    //\n    // OR\n    //\n    // @param  array arr The array from which to take one off the front of array\n    // @return array     The new array\n    //\n    RGraph.arrayShift = function()\n    {\n        var args = RGraph.getArgs(arguments, 'array');\n        var ret  = [];\n        \n        for(var i=1,len=args.array.length; i<len; ++i) {\n            ret.push(args.array[i]);\n        }\n        \n        return ret;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Reverses the order of an array\n    //\n    // @param  args object An object consisting of:\n    //                      o array\n    //\n    // OR\n    //\n    // @param array  arr The array to reverse\n    //\n    RGraph.arrayReverse = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'array');\n\n        if (!args.array) {\n            return;\n        }\n\n        var newarr=[];\n\n        for(var i=args.array.length - 1; i>=0; i-=1) {\n            newarr.push(args.array[i]);\n        }\n        \n        return newarr;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Returns the absolute value of a number. You can also pass in an\n    // array and it will run the abs() function on each element. It\n    // operates recursively so sub-arrays are also traversed.\n    // \n    // @param  args object An object consisting of:\n    //                      o value\n    // OR\n    //\n    // @param array arr The number or array to work on\n    //\n    RGraph.abs = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'value');\n\n        if (typeof args.value === 'string') {\n            args.value = parseFloat(args.value) || 0;\n        }\n\n        if (typeof args.value === 'number') {\n            return Math.abs(args.value);\n        }\n\n        if (typeof args.value === 'object') {\n            for (i in args.value) {\n                if (   typeof args.value[i] === 'string'\n                    || typeof args.value[i] === 'number'\n                    || typeof args.value[i] === 'object') {\n\n                    args.value[i] = RGraph.abs(args.value[i]);\n                }\n            }\n            \n            return args.value;\n        }\n        \n        return 0;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Clears the canvas by setting the width. You can specify a colour if you wish.\n    //\n    // @param  args object An object consisting of:\n    //                      o canvas\n    //                      o color\n    // OR\n    //\n    //\n    // @param object canvas The canvas to clear\n    // @param mixed         Usually a color string to use to clear the canvas\n    //                      with - could also be a gradient object\n    //\n    RGraph.clear =\n    RGraph.Clear = function (args)\n    {\n        var args    = RGraph.getArgs(arguments, 'canvas,color');\n        var obj     = args.canvas.__object__;\n        var context = args.canvas.getContext('2d');\n        var color   = args.color || (obj && obj.get('clearto'));\n\n        if (!args.canvas) {\n            return;\n        }\n        \n        RGraph.fireCustomEvent(obj, 'onbeforeclear');\n\n        //\n        // Set the CSS display: to none for DOM text\n        //\n        if (RGraph.text.domNodeCache && RGraph.text.domNodeCache[args.canvas.id]) {\n            for (var i in RGraph.text.domNodeCache[args.canvas.id]) {\n                \n                var el = RGraph.text.domNodeCache[args.canvas.id][i];\n    \n                if (el && el.style) {\n                    el.style.display = 'none';\n                }\n            }\n        }\n\n        //\n        // Can now clear the canvas back to fully transparent\n        //\n        if (   !color\n            || (color && color === 'rgba(0,0,0,0)' || color === 'transparent')\n            ) {\n\n            context.clearRect(\n                -100,\n                -100,\n                args.canvas.width + 200,\n                args.canvas.height + 200\n            );\n\n            // Reset the globalCompositeOperation\n            context.globalCompositeOperation = 'source-over';\n\n        } else if (color) {\n\n            obj.path(\n                'fs % fr -100 -100 % %',\n                color,\n                args.canvas.width + 200,\n                args.canvas.height + 200\n            );\n        \n        } else {\n            obj.path(\n                'fs % fr -100 -100 % %',\n                obj.get('clearto'),\n                args.canvas.width + 200,\n                args.canvas.height + 200\n            );\n        }\n        \n        //if (RGraph.clearAnnotations) {\n            //RGraph.clearAnnotations(canvas.id);\n        //}\n        \n        //\n        // This removes any background image that may be present\n        //\n        if (RGraph.Registry.get('background.image.' + args.canvas.id)) {\n            var img            = RGraph.Registry.get('background.image.' + args.canvas.id);\n            img.style.position = 'absolute';\n            img.style.left     = '-10000px';\n            img.style.top      = '-10000px';\n        }\n        \n        //\n        // This hides the tooltip that is showing IF it has the same canvas ID as\n        // that which is being cleared\n        //\n        if (RGraph.Registry.get('tooltip') && obj && !obj.get('tooltipsNohideonclear')) {\n            RGraph.hideTooltip(args.canvas);\n        }\n\n        //\n        // Set the cursor to default\n        //\n        args.canvas.style.cursor = 'default';\n\n        RGraph.fireCustomEvent(obj, 'onclear');\n    };\n\n\n\n\n\n\n\n\n    //\n    // Draws the title of the graph\n    // \n    // @param object  args   An object consisting of the arguments to the function\n    //                        o object\n    //                        o text\n    //                        o marginTop\n    //                        o centerx\n    //\n    // OR\n    //\n    // @param object  canvas The canvas object\n    // @param string  text   The title to write\n    // @param integer margin The size of the margin\n    // @param integer        The center X point (optional - if not given it will be generated from the canvas width)\n    // @param integer        Size of the text. If not given it will fallback to the textSize property\n    // @param object         An optional object which has canvas and context properties to use instead of those on\n    //                       the obj argument (so as to enable caching)\n    //\n    RGraph.drawTitle = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'object,text,marginTop,centerx');\n\n        //if (   typeof args === 'object'\n        //    && !RGraph.isNull(args)\n        //    && typeof args.object === 'object'\n        //    && typeof args.text === 'string'\n        //    && typeof args.marginTop === 'number') {\n        //    \n        //    // Nada...\n        //    \n        //} else {\n        //\n        //    var args = {\n        //        object:    arguments[0],\n        //        text:      arguments[1],\n        //        marginTop: arguments[2],\n        //        centerx:   arguments[3]\n        //    };\n        //}\n\n        var canvas       = args.object.canvas,\n            context      = args.object.context,\n            properties   = args.object.properties,\n            marginLeft   = properties.marginLeft,\n            marginRight  = properties.marginRight,\n            marginTop    = args.marginTop,\n            marginBottom = properties.marginBottom,\n            centerx      = (args.centerx ? args.centerx : ((canvas.width - marginLeft - marginRight) / 2) + marginLeft),\n            keypos       = properties.keyPosition,\n            vpos         = properties.titleVpos,\n            hpos         = properties.titleHpos,\n            bgcolor      = properties.titleBackground,\n            x            = properties.titleX,\n            y            = properties.titleY,\n            halign       = 'center',\n            valign       = 'center',\n\n            textConf = RGraph.getTextConf({\n                object: args.object,\n                prefix: 'title'\n            });\n\n            var size   = textConf.size,\n                bold   = textConf.bold,\n                italic = textConf.italic;\n                \n                // Set bold to true for the title if it hasn't been set by\n                // the user \n                if (RGraph.isNull(bold)) {\n                    textConf.bold = true;\n                    bold          = true;\n                }\n\n\n\n        // Account for 3D effect by faking the key position\n        if (args.object.type == 'bar' && properties.variant == '3d') {\n            keypos = 'margin';\n        }\n\n        context.beginPath();\n        context.fillStyle = textConf.color ? textConf.color : 'black';\n\n\n        //\n        // Vertically center the text if the key is not present\n        //\n        if (keypos && keypos != 'margin') {\n            var valign = 'center';\n\n        } else if (!keypos) {\n            var valign = 'center';\n\n       } else {\n            var valign = 'bottom';\n        }\n\n\n\n\n\n        // if titleVpos is a number, use that\n        if (typeof properties.titleVpos === 'number') {\n            vpos = properties.titleVpos * marginTop;\n\n            if (properties.xaxisPosition === 'top') {\n                vpos = properties.titleVpos * marginBottom + marginTop + (canvas.height - marginTop - marginBottom);\n            }\n\n        } else {\n            vpos = marginTop - size - 5;\n\n            if (properties.xaxisPosition === 'top') {\n                vpos = canvas.height  - marginBottom + size + 5;\n            }\n        }\n\n        // if titleHpos is a number, use that. It's multiplied with the (entire) canvas width\n        if (typeof hpos === 'number') {\n            centerx = hpos * canvas.width;\n        }\n\n        //\n        // Now the titleX and titleY settings override (if set) the above\n        //\n        // Also now (Feb 2021) allow the use of the titleOffsetx and\n        // titleOffsety properties\n        if (typeof x === 'number') centerx = x;\n        if (typeof y === 'number') vpos    = y;\n        \n        if (typeof x === 'string') centerx += parseFloat(x);\n        if (typeof y === 'string') vpos    += parseFloat(y);\n        \n        if (typeof properties.titleOffsetx === 'number') centerx += properties.titleOffsetx;\n        if (typeof properties.titleOffsety === 'number') vpos += properties.titleOffsety;\n\n\n\n\n        //\n        // Horizontal alignment can now (Jan 2013) be specified\n        //\n        if (typeof properties.titleHalign === 'string') {\n            halign = properties.titleHalign;\n        }\n        \n        //\n        // Vertical alignment can now (Jan 2013) be specified\n        //\n        if (typeof properties.titleValign === 'string') {\n            valign = properties.titleValign;\n        }\n\n\n\n\n        \n        // Set the color\n        if (typeof textConf.color !== null) {\n            \n            var oldColor = context.fillStyle,\n                newColor = textConf.color;\n            \n            context.fillStyle = newColor ? newColor : 'black';\n        }\n\n        // Draw the title\n        var ret = RGraph.text({\n        \n            object:  args.object,\n\n            font:    textConf.font,\n            size:    textConf.size,\n            color:   textConf.color,\n            bold:    textConf.bold,\n            italic:  textConf.italic,\n\n            x:       centerx,\n            y:       vpos,\n            text:    args.text,\n            valign:  valign,\n            halign:  halign,\n            bounding:bgcolor != null,\n            'bounding.fill':bgcolor,\n            tag:     'title',\n            marker:  false\n        });\n\n        // Reset the fill colour\n        context.fillStyle = oldColor;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Gets the mouse X/Y coordinates relative to the canvas\n    // \n    // @param  args object An object consisting of:\n    //                      o event\n    // OR\n    //\n    // @param object e The event object. As such this method should be used in an event listener.\n    //\n    RGraph.getMouseXY = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'event');\n\n        // This is necessary for IE9\n        if (!args.event.target) {\n            return;\n        }\n\n        var el      = args.event.target,\n            canvas  = el,\n            caStyle = canvas.style,\n            offsetX = 0,\n            offsetY = 0,\n            x,\n            y,\n            borderLeft  = parseInt(caStyle.borderLeftWidth) || 0,\n            borderTop   = parseInt(caStyle.borderTopWidth) || 0,\n            paddingLeft = parseInt(caStyle.paddingLeft) || 0,\n            paddingTop  = parseInt(caStyle.paddingTop) || 0,\n            additionalX = borderLeft + paddingLeft,\n            additionalY = borderTop + paddingTop;\n\n        if (typeof args.event.offsetX === 'number' && typeof args.event.offsetY === 'number') {\n\n            if (!RGraph.ISIE && !RGraph.ISOPERA) {\n                x = args.event.offsetX - borderLeft - paddingLeft;\n                y = args.event.offsetY - borderTop - paddingTop;\n            \n            } else if (RGraph.ISIE) {\n                x = args.event.offsetX - paddingLeft;\n                y = args.event.offsetY - paddingTop;\n            \n            } else {\n                x = args.event.offsetX;\n                y = args.event.offsetY;\n            }   \n\n        } else {\n\n            if (typeof el.offsetParent !== 'undefined') {\n                do {\n                    offsetX += el.offsetLeft;\n                    offsetY += el.offsetTop;\n                } while ((el = el.offsetParent));\n            }\n\n            x = args.event.pageX - offsetX - additionalX;\n            y = args.event.pageY - offsetY - additionalY;\n\n            x -= (2 * (parseInt(document.body.style.borderLeftWidth) || 0));\n            y -= (2 * (parseInt(document.body.style.borderTopWidth) || 0));\n\n            //x += (parseInt(caStyle.borderLeftWidth) || 0);\n            //y += (parseInt(caStyle.borderTopWidth) || 0);\n        }\n\n        // We return a javascript array with x and y defined\n        return [x, y];\n    };\n\n\n\n\n\n\n\n\n    //\n    // This function returns a two element array of the canvas x/y position in\n    // relation to the page\n    // \n    // @param  args object An object consisting of:\n    //                      o canvas\n    // OR\n    //\n    // @param object canvas\n    //\n    RGraph.getCanvasXY = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'canvas');\n\n\n\n\n        // If the getBoundingClientRect function is available - use that\n        //\n        if (args.canvas.getBoundingClientRect) {\n            \n            var rect = args.canvas.getBoundingClientRect();\n\n            // Add the the current scrollTop and scrollLeft becuase the getBoundingClientRect()\n            // method is relative to the viewport - not the document\n            var scrollLeft = window.pageXOffset || document.documentElement.scrollLeft,\n                scrollTop  = window.pageYOffset || document.documentElement.scrollTop;\n            \n            return [rect.x + scrollLeft, rect.y + scrollTop];\n        }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        var x  = 0;\n        var y  = 0;\n        var el = args.canvas; // !!!\n\n        do {\n\n            x += el.offsetLeft;\n            y += el.offsetTop;\n            \n            // ACCOUNT FOR TABLES IN wEBkIT\n            if (el.tagName.toLowerCase() == 'table' && (RGraph.ISCHROME || RGraph.ISSAFARI)) {\n                x += parseInt(el.border) || 0;\n                y += parseInt(el.border) || 0;\n            }\n\n            el = el.offsetParent;\n\n        } while (el && el.tagName.toLowerCase() != 'body');\n\n\n        var paddingLeft = args.canvas.style.paddingLeft ? parseInt(args.canvas.style.paddingLeft) : 0;\n        var paddingTop  = args.canvas.style.paddingTop ? parseInt(args.canvas.style.paddingTop) : 0;\n        var borderLeft  = args.canvas.style.borderLeftWidth ? parseInt(args.canvas.style.borderLeftWidth) : 0;\n        var borderTop   = args.canvas.style.borderTopWidth  ? parseInt(args.canvas.style.borderTopWidth) : 0;\n\n        if (navigator.userAgent.indexOf('Firefox') > 0) {\n            x += parseInt(document.body.style.borderLeftWidth) || 0;\n            y += parseInt(document.body.style.borderTopWidth) || 0;\n        }\n\n        return [x + paddingLeft + borderLeft, y + paddingTop + borderTop];\n    };\n\n\n\n\n\n\n\n\n    //\n    // This function determines whther a canvas is fixed (CSS positioning) or not. If not it returns\n    // false. If it is then the element that is fixed is returned (it may be a parent of the canvas).\n    // \n    // @param  args object An object consisting of:\n    //                      o canvas\n    // OR\n    //\n    // @return Either false or the fixed positioned element\n    //\n    RGraph.isFixed = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'canvas');\n        var i    = 0;\n\n        while (args.canvas && args.canvas.tagName.toLowerCase() != 'body' && i < 99) {\n\n            if (args.canvas.style.position == 'fixed') {\n                return args.canvas;\n            }\n            \n            args.canvas = args.canvas.offsetParent;\n        }\n\n        return false;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Registers a graph object (used when the canvas is redrawn)\n    // \n    // @param  args object An object consisting of:\n    //                      o object\n    // OR\n    //\n    // @param object obj The object to be registered\n    //\n    RGraph.register = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'object');\n\n        // Allow the registration of functions\n        if (typeof args.object === 'function') {\n            \n            var func = args.object;\n            \n            // Register a shell object\r\n            var temp = function ()\n            {\n                this.id            = null;\n                this.isFunction    = true;\n                this.canvas        = {id: null};\n                this.getObjectByXY = function (){return false;};\n                this.get           = function (){};\n                this.set           = function (){};\n                this.draw          = function (){func();};\n            };\n            \n            args.object = new temp();\n        }\n\n\n\n\n        // Checking this property ensures the object is only registered once\n        if (!args.object.get('noregister') && args.object.get('register') !== false) {\n            RGraph.ObjectRegistry.add(args.object);\n            args.object.set('register', false);\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // Causes all registered objects to be redrawn\n    // \n    // @param  args object An object consisting of:\n    //                      o color\n    // OR\n    //\n    // @param string An optional color to use to clear the canvas\n    //\n    RGraph.redraw = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'color');\n        var objectRegistry = RGraph.ObjectRegistry.objects.byCanvasID;\n\n\n\n\n\n        // if the argument is a canvas object (ie not a color string) then\n        // call .redrawCanvas instead\n        if (    typeof args.color === 'object'\n            && args.color\n            && typeof args.color.toString === 'function'\n            && typeof args.color.toString().indexOf === 'function'\n            && args.color.toString().indexOf('HTMLCanvasElement') > -1) {\n            \n            var opt = {canvas: args.color};\n            \n            // Has a color been given as well?\n            if (arguments[1]) {\n                opt.color = arguments[1];\n            }\n            \n            return RGraph.redrawCanvas(opt);\n        }\n\n\n\n\n\n        // Get all of the canvas tags on the page\n        var tags = document.getElementsByTagName('canvas');\n\n        for (var i=0,len=tags.length; i<len; ++i) {\n            if (tags[i] && tags[i].__object__ && tags[i].__object__.isrgraph) {\n                \n                // Only clear the canvas if it's not Trace'ing - this applies to the Line/Scatter Trace effects\n                if (!tags[i].noclear) {\n                    RGraph.clear(tags[i], args.color ? args.color : null);\n                }\n            }\n        }\n\n        // Go through the object registry and redraw *all* of the canvas'es that have been registered\n        for (var i=0,len=objectRegistry.length; i<len; ++i) {\n            if (objectRegistry[i]) {\n                var id = objectRegistry[i][0];\n                objectRegistry[i][1].draw();\n            }\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // Causes all registered objects ON THE GIVEN CANVAS to be redrawn\n    // \n    // @param  args object An object consisting of:\n    //                      o canvas\n    //                      o clear\n    //                      o color\n    // OR\n    //\n    // @param canvas object The canvas object to redraw\n    // @param        bool   Optional boolean which defaults to true and determines whether to clear the canvas\n    //\n    RGraph.redrawCanvas = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'canvas,clear,color');\n        var objects = RGraph.ObjectRegistry.getObjectsByCanvasID(args.canvas.id);\n\n        //\n        // First clear the canvas\n        //\n        if (RGraph.isNull(args.clear) || (typeof args.clear === 'boolean' && args.clear !== false) ) {\n            var color = args.color || args.canvas.__object__.get('clearto') || 'transparent';\n            RGraph.clear(args.canvas, args.color);\n        }\n \n        //\n        // Now redraw all the charts associated with that canvas\n        //\n        for (var i=0,len=objects.length; i<len; ++i) {\n            if (objects[i]) {\n                if (objects[i] && objects[i].isrgraph) { // Is it an RGraph object ??\n                    objects[i].draw();\n                }\n            }\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // This function draws the background for the bar chart, line chart and scatter chart.\n    // \n    // @param  args object An object consisting of:\n    //                      o object\n    // OR\n    //\n    // @param  object obj The graph object\n    //\n    RGraph.Background.draw = function ()\n    {\n        var args         = RGraph.getArgs(arguments, 'object');\n        var properties   = args.object.properties,\n            height       = 0,\n            marginLeft   = args.object.marginLeft,\n            marginRight  = args.object.marginRight,\n            marginTop    = args.object.marginTop,\n            marginBottom = args.object.marginBottom,\n            variant      = properties.variant\n\n\n            args.object.context.fillStyle = properties.textColor;\n\n            // If it's a bar and 3D variant, translate\n            if (variant == '3d') {\n                args.object.context.save();\n                args.object.context.translate(properties.variantThreedOffsetx, -1 * properties.variantThreedOffsety);\n            }\n    \n            // X axis title (not for the Bar or waterfall charts now - that's done\n            // in the newer drawXAxis() function)\n            if (\n                   args.object.type !== 'bar'\n                && args.object.type !== 'waterfall'\n                && args.object.type !== 'hbar'\n                && args.object.type !== 'line'\n                && args.object.type !== 'gantt'\n                && args.object.type !== 'scatter'\n                && typeof properties.xaxisTitle === 'string'\n                && properties.xaxisTitle.length\n               ) {\n            \n                var size   = properties.textSize + 2;\n                //var font   = properties.textFont;\n                //var bold   = properties.xaxisTitleBold;\n                //var italic = properties.xaxisTitleItalic;\n\n                //if (typeof properties.xaxisTitleSize === 'number') {\n                //    size = properties.xaxisTitleSize;\n                //}\n    \n                //if (typeof properties.xaxisTitleFont === 'string') {\n                //    font = properties.xaxisTitleFont;\n                //}\n                \n                var hpos = ((args.object.canvas.width - marginLeft - marginRight) / 2) + marginLeft;\n                var vpos = args.object.canvas.height - marginBottom + 25;\n                \n                if (typeof properties.xaxisTitlePos === 'number') {\n                    vpos = args.object.canvas.height - (marginBottom * properties.xaxisTitlePos);\n                }\n    \n    \n    \n    \n                // Specifically specified X/Y positions\n                if (typeof properties.xaxisTitleX === 'number') {\n                    hpos = properties.xaxisTitleX;\n                }\n    \n                if (typeof properties.xaxisTitleY === 'number') {\n                    vpos = properties.xaxisTitleY;\n                }\n                \n                // Get the text configuration\n                var textConf = RGraph.getTextConf({\n                    object: args.object,\n                    prefix: 'xaxisTitle'\n                });\n    \n\n                RGraph.text({\n                \n                  object: args.object,\n\n                    font:   textConf.font,\n                    size:   textConf.size,\n                    color:  textConf.color,\n                    bold:   textConf.bold,\n                    italic: textConf.italic,\n\n                    x:      hpos,\n                    y:      vpos,\n                    text:   properties.xaxisTitle,\n                    halign: 'center',\n                    valign: 'top',\n                    tag:    'xaxis.title'\n                });\n            }\n\n            // Y axis title\n            if (\n                   args.object.type !== 'bar'\n                && args.object.type !== 'waterfall'\n                && args.object.type !== 'hbar'\n                && args.object.type !== 'line'\n                && args.object.type !== 'gantt'\n                && args.object.type !== 'scatter'\n                && typeof properties.yaxisTitle === 'string'\n                && properties.yaxisTitle.length) {\n\n                var size   = properties.textSize + 2;\n                var font   = properties.textFont;\n                var italic = properties.textItalic;\n                var angle  = 270;\n                var bold   = properties.yaxisTitleBold;\n                var color  = properties.yaxisTitleColor;\n\n                if (typeof properties.yaxisTitlePos == 'number') {\n                    var yaxis_title_pos = properties.yaxisTitlePos * marginLeft;\n                } else if (args.object.type === 'hbar' && RGraph.isNull(properties.yaxisTitlePos) ) {\n                    var yaxis_title_pos = properties.marginLeft - args.object.yaxisLabelsSize;\n                } else {\n\n                    if (args.object && args.object.scale2) {\n\n                        var yaxisTitleDimensions = RGraph.measureText({\n                            text: args.object.scale2.labels[args.object.scale2.labels.length - 1],\n                            bold: typeof properties.yaxisScaleBold === 'boolean' ? properties.yaxisScaleBold : properties.textBold,\n                            font: properties.yaxisScaleFont || properties.textFont,\n                            size: typeof properties.yaxisScaleSize === 'number' ? properties.yaxisScaleSize : properties.textSize\n                        });\n\n                    } else {\n                        // This is here to allow for the drawing API background\n                        // object\n                        yaxisTitleDimensions = [0,0];\n                    }\n\n                    var yaxis_title_pos = properties.marginLeft - yaxisTitleDimensions[0] - 7;\n                }\n                if (typeof properties.yaxisTitleSize === 'number') {\n                    size = properties.yaxisTitleSize;\n                }\n    \n                if (typeof properties.yaxisTitleItalic === 'boolean') {\n                    italic = properties.yaxisTitleItalic;\n                }\n    \n                if (typeof properties.yaxisTitleFont === 'string') {\n                    font = properties.yaxisTitleFont;\n                }\n                \n                \n\n                if (   properties.yaxisTitleAlign == 'right'\n                    || properties.yaxisTitlePosition == 'right'\n                    || (args.object.type === 'hbar' && properties.yaxisPosition === 'right' && typeof properties.yaxisTitleAlign === 'undefined' && typeof properties.yaxisTitlePosition === 'undefined')\n                   ) {\n\n                    angle = 90;\n                    yaxis_title_pos = typeof properties.yaxisTitlePos === 'number'\n                                          ? (args.object.canvas.width - marginRight) + (properties.yaxisTitlePos * marginRight)\n                                          : args.object.canvas.width - marginRight + (properties.yaxisLabelsSize || properties.textSize) + 10;\n\n                }\n\n                var y = ((args.object.canvas.height - marginTop - marginBottom) / 2) + marginTop;\n\n                // Specifically specified X/Y positions\n                if (typeof properties.yaxisTitleX === 'number') {\n                    yaxis_title_pos = properties.yaxisTitleX;\n                }\n    \n                if (typeof properties.yaxisTitleY === 'number') {\n                    y = properties.yaxisTitleY;\n                }\n\n                args.object.context.fillStyle = color;\n\n                // Get the text configuration\n                var textConf = RGraph.getTextConf({\n                    object: args.object,\n                    prefix: 'yaxisTitle'\n                });\n\n\n                RGraph.text({\n                \n                  object: args.object,\n                \n                    font:   textConf.font,\n                    size:   textConf.size,\n                    color:  textConf.color,\n                    bold:   textConf.bold,\n                    italic: textConf.italic,\n\n                    x:          yaxis_title_pos,\n                    y:          y,\n                    valign:     'bottom',\n                    halign:     'center',\n                    angle:      angle,\n                    text:       properties.yaxisTitle,\n                    tag:        'yaxis.title',\n                    accessible: false\n                });\n            }\n    \n            //\n            // If the background color is spec ified - draw that. It's a rectangle that fills the\n            // entire area within the margins\n            //\n            var bgcolor = properties.backgroundColor;\n\n            if (bgcolor) {\n                args.object.context.fillStyle = bgcolor;\n                args.object.context.fillRect(marginLeft + 0.5, marginTop + 0.5, args.object.canvas.width - marginLeft - marginRight, args.object.canvas.height - marginTop - marginBottom);\n            }\n\n\n\n\n\n\n\n            //\n            // Draw horizontal background bars\n            //\n            var numbars   = (properties.yaxisLabelsCount || 5);\n\n            // If the backbgroundBarcount property is set use that\n            if (typeof properties.backgroundBarsCount === 'number') {\n                numbars = properties.backgroundBarsCount;\n            }\n\n            // Calculate the height of the bars\n            var barHeight = (args.object.canvas.height - marginBottom - marginTop) / numbars;\n\n            args.object.context.beginPath();\n                args.object.context.fillStyle   = properties.backgroundBarsColor1;\n                args.object.context.strokeStyle = args.object.context.fillStyle;\n                height = (args.object.canvas.height - marginBottom);\n\n                for (var i=0; i<numbars; i+=2) {\n                    args.object.context.rect(marginLeft,\n                        (i * barHeight) + marginTop,\n                        args.object.canvas.width - marginLeft - marginRight,\n                        barHeight\n                    );\n                }\n            args.object.context.fill();\n\n\n\n            args.object.context.beginPath();\n                args.object.context.fillStyle   = properties.backgroundBarsColor2;\n                args.object.context.strokeStyle = args.object.context.fillStyle;\n        \n                for (var i=1; i<numbars; i+=2) {\n                    args.object.context.rect(\n                        marginLeft,\n                        (i * barHeight) + marginTop,\n                        args.object.canvas.width - marginLeft - marginRight,\n                        barHeight\n                    );\n                }\n            \n            args.object.context.fill();\n            \n            // Close any errantly open path\n            args.object.context.beginPath();\n\n\n\n\n\n\n\n\n\n\n\n\n\n            //\n            // The background grid is cached\n            //\n            var func = function (obj, cacheCanvas, cacheContext)\n            {\n                // Draw the background grid\n                if (properties.backgroundGrid) {\n                \n                    properties.backgroundGridHlinesCount += 0.0001;\n\n                    // If autofit is specified, use the .numhlines and .numvlines along with the width to work\n                    // out the hsize and vsize\n                    if (properties.backgroundGridAutofit) {\n\n                        //\n                        // Align the grid to the tickmarks\n                        //\n                        if (properties.backgroundGridAutofitAlign) {\n\n                            // Align the horizontal lines\n                            if (obj.type === 'hbar') {\n                                obj.set('backgroundGridHlinesCount', obj.data.length);\n                            }\n\n                            // Align the vertical lines for the line\n                            if (obj.type === 'line') {\n\n                                if (typeof properties.backgroundGridVlinesCount === 'number') {\n                                    // Nada\n                                } else if (properties.xaxisLabels && properties.xaxisLabels.length) {\n                                    obj.set('backgroundGridVlinesCount', properties.xaxisLabels.length - 1);\n                                } else {\n                                \n                                    obj.set(\n                                        'backgroundGridVlinesCount',\n                                        obj.data[0].length > 0 ? obj.data[0].length - 1 : 0\n                                    );\n                                }\n                            } else if (obj.type === 'waterfall') {\n                                obj.set(\n                                    'backgroundGridVlinesCount',\n                                    obj.data.length + (properties.total ? 1 : 0)\n                                );\n\n                            // Align the vertical lines for the bar\n                            } else if (obj.type === 'bar') {\n                                \n                                // 13/12/2018\n                                //\n                                // Updated to be the same as the number of data points\n                                //\n                                obj.set('backgroundGridVlinesCount', obj.data.length);\n                            \n                            // Align the vertical lines for the Scatter\n                            } else if (obj.type === 'scatter') {\n                                if (typeof properties.backgroundGridVlinesCount !== 'number') {\n                                    \n                                    // Set the number of grid lines to the same\n                                    // as the number of labels\n                                    if (RGraph.isArray(properties.xaxisLabels) && properties.xaxisLabels.length) {\n                                        obj.set('backgroundGridVlinesCount', properties.xaxisLabels.length);\n                                    \n                                    // No labels - set the number of grid lines\n                                    // to 10\n                                    } else {\n                                        obj.set('backgroundGridVlinesCount', 10);\n                                    }\n                                }\n\n    \n                            // Gantt\n                            } else if (obj.type === 'gantt') {\n\n                                if (typeof obj.get('backgroundGridVlinesCount') === 'number') {\n                                    // Nothing to do here\n                                } else {\n                                    obj.set('backgroundGridVlinesCount', properties.xaxisScaleMax);\n                                }\n    \n                                obj.set('backgroundGridHlinesCount', obj.data.length);\n                            \n                            // HBar\n                            } else if (obj.type === 'hbar' && RGraph.isNull(properties.backgroundGridHlinesCount) ) {\n                                obj.set('backgroundGridHlinesCount', obj.data.length);\n                            }\n                        }\n    \n                        var vsize = ((cacheCanvas.width - marginLeft - marginRight)) / properties.backgroundGridVlinesCount;\n                        var hsize = (cacheCanvas.height - marginTop - marginBottom) / properties.backgroundGridHlinesCount;\n\n                        obj.set('backgroundGridVsize', vsize);\n                        obj.set('backgroundGridHsize', hsize);\n                    }\n\n                    obj.context.beginPath();\n                    cacheContext.lineWidth   = properties.backgroundGridLinewidth ? properties.backgroundGridLinewidth : 1;\n                    cacheContext.strokeStyle = properties.backgroundGridColor;\n\n                    // Dashed background grid\n                    if (properties.backgroundGridDashed && typeof cacheContext.setLineDash == 'function') {\n                        cacheContext.setLineDash([3,5]);\n                    }\n                    \n                    // Dotted background grid\n                    if (properties.backgroundGridDotted && typeof cacheContext.setLineDash == 'function') {\n                        cacheContext.setLineDash([1,3]);\n                    }\n                    \n                    obj.context.beginPath();\n        \n        \n                    // Draw the horizontal lines\n                    if (properties.backgroundGridHlines) {\n                        height = (cacheCanvas.height - marginBottom)\n                        var hsize = properties.backgroundGridHsize;\n                        for (y=marginTop; y<=height; y+=hsize) {\n                            cacheContext.moveTo(marginLeft, Math.round(y));\n                            cacheContext.lineTo(args.object.canvas.width - marginRight, Math.round(y));\n                        }\n                    }\n        \n                    // Draw the vertical lines\n\n                    if (properties.backgroundGridVlines) {\n\n                        var width = (cacheCanvas.width - marginRight);\n                        var vsize = properties.backgroundGridVsize;\n\n                        for (var x=marginLeft; Math.round(x)<=width; x+=vsize) {\n                            cacheContext.moveTo(Math.round(x), marginTop);\n                            cacheContext.lineTo(Math.round(x), obj.canvas.height - marginBottom);\n                        }\n                    }\n        \n                    if (properties.backgroundGridBorder) {\n                        // Make sure a rectangle, the same colour as the grid goes around the graph\n                        cacheContext.strokeStyle = properties.backgroundGridColor;    \n                        cacheContext.strokeRect(Math.round(marginLeft), Math.round(marginTop), obj.canvas.width - marginLeft - marginRight, obj.canvas.height - marginTop - marginBottom);\n                    }\n                }\n    \n                cacheContext.stroke();\n    \n    \n    \n                // Ensure the grid is drawn before continuing\n                cacheContext.beginPath();\n                cacheContext.closePath();\n            }\n\n            // Now a cached draw in newer browsers\n            RGraph.cachedDraw(\n                args.object,\n                args.object.uid + '_background',\n                func\n            );\n\n\n\n\n\n\n\n            // If it's a bar and 3D variant, translate\n            if (variant == '3d') {\n                args.object.context.restore();\n            }\n\n            // Reset the line dash\n            if (typeof args.object.context.setLineDash == 'function') {\n                args.object.context.setLineDash([1,0]);\n            }\n    \n            args.object.context.stroke();\n\n\n\n        // Draw the title if one is set\n        if ( typeof args.object.properties.title == 'string') {\n\n            RGraph.drawTitle(\n                args.object,\n                properties.title,\n                args.object.marginTop,\n                null,\n                properties.titleSize ? properties.titleSize : properties.textSize + 2,\n                args.object\n            );\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // Formats a number with thousand separators so it's easier to read\n    // \n    // @param  args object An object consisting of:\n    //                      o object\n    //                      o number\n    //                      o unitspre\n    //                      o unitspost\n    //                      o point\n    //                      o thousand\n    //                      o formatter\n    // OR\n    //\n    // THESE ARE OLDER ARGS:\n    // \n    // @param  object obj The chart object\n    // @param  integer num The number to format\n    // @param  string      The (optional) string to prepend to the string\n    // @param  string      The (optional) string to append to the string\n    // @return string      The formatted number\n    //\n    RGraph.numberFormat = function (args)\n    {\n        var i;\n        var prepend = args.unitspre ? String(args.unitspre) : '';\n        var append  = args.unitspost ? String(args.unitspost) : '';\n        var output  = '';\n        var decimal = '';\n        var decimal_seperator  = typeof args.point    === 'string' ? args.point    : '.';\n        var thousand_seperator = typeof args.thousand === 'string' ? args.thousand : ',';\n        RegExp.$1   = '';\n        var i,j;\n\n        if (typeof args.formatter === 'function') {\n            return (args.formatter)(args);\n        }\n\n        // Ignore the preformatted version of \"1e-2\"\n        if (String(args.number).indexOf('e') > 0) {\n            return String(prepend + String(args.number) + append);\n        }\n\n        // We need then number as a string\n        args.number = String(args.number);\n\n        // Take off the decimal part - we re-append it later\n        if (args.number.indexOf('.') > 0) {\n            var tmp    = args.number;\n            args.number = args.number.replace(/\\.(.*)/, ''); // The front part of the number\n            decimal    = tmp.replace(/(.*)\\.(.*)/, '$2'); // The decimal part of the number\n        }\n\n        // Thousand separator\n        //var separator = arguments[1] ? String(arguments[1]) : ',';\n        var seperator = thousand_seperator;\n\n        // Work backwards adding the thousand separators\n        //\n        // ** i is a local variable at this poin **\n        var foundPoint;\n        for (i=(args.number.length - 1),j=0; i>=0; j++,i--) {\n            var character = args.number.charAt(i);\n            \n            if ( j % 3 == 0 && j != 0) {\n                output += seperator;\n            }\n            \n            //\n            // Build the output\n            //\n            output += character;\n        }\n\n        //\n        // Now need to reverse the string\n        //\n        var rev = output;\n        output = '';\n        for (i=(rev.length - 1); i>=0; i--) {\n            output += rev.charAt(i);\n        }\n\n        // Tidy up\n        //output = output.replace(/^-,/, '-');\n        if (output.indexOf('-' + args.thousand) == 0) {\n            output = '-' + output.substr(('-' + args.thousand).length);\n        }\n\n        // Reappend the decimal\n        if (decimal.length) {\n            output =  output + decimal_seperator + decimal;\n            decimal = '';\n            RegExp.$1 = '';\n        }\n\n        // Minor bugette\n        if (output.charAt(0) == '-') {\n            output = output.replace(/-/, '');\n            prepend = '-' + prepend;\n        }\n        \n        // Get rid of leading commas\n        output = output.replace(/^,+/,'');\n\n        return prepend + output + append;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Draws horizontal coloured bars on something like the bar, line or scatter\n    // \n    // @param  args object An object consisting of:\n    //                      o object\n    //\n    RGraph.drawBars = function ()\n    {\n        var args       = RGraph.getArgs(arguments, 'object'),\n            properties = args.object.properties,\n            hbars      = properties.backgroundHbars;\n\n        if (hbars === null) {\n            return;\n        }\n\n        //\n        // Draws a horizontal bar\n        //\n        args.object.context.beginPath();\n\n        for (var i=0,len=hbars.length; i<len; ++i) {\n        \n            var start  = hbars[i][0];\n            var length = hbars[i][1];\n            var color  = hbars[i][2];\n            \n\n            // Perform some bounds checking\n            if(RGraph.isNull(start))start = args.object.scale2.max\n            if (start > args.object.scale2.max) start = args.object.scale2.max;\n            if (RGraph.isNull(length)) length = args.object.scale2.max - start;\n            if (start + length > args.object.scale2.max) length = args.object.scale2.max - start;\n            if (start + length < (-1 * args.object.scale2.max) ) length = (-1 * args.object.scale2.max) - start;\n\n            if (properties.xaxisPosition == 'center' && start == args.object.scale2.max && length < (args.object.scale2.max * -2)) {\n                length = args.object.scale2.max * -2;\n            }\n\n\n            //\n            // Draw the bar\n            //\n            var x = properties.marginLeft;\n            var y = args.object.getYCoord(start);\n            var w = args.object.canvas.width - properties.marginLeft - properties.marginRight;\n            var h = args.object.getYCoord(start + length) - y;\n\n            // Accommodate Opera :-/\n            if (RGraph.ISOPERA != -1 && properties.xaxisPosition == 'center' && h < 0) {\n                h *= -1;\n                y = y - h;\n            }\n\n            //\n            // Account for X axis at the top\n            //\n            if (properties.xaxisPosition == 'top') {\n                y  = args.object.canvas.height - y;\n                h *= -1;\n            }\n\n            args.object.context.fillStyle = color;\n            args.object.context.fillRect(x, y, w, h);\n        }\n\n\n\n\n//\n//            // If the X axis is at the bottom, and a negative max is given, warn the user\n//            if (args.object.get('xaxisPosition') == 'bottom' && (hbars[i][0] < 0 || (hbars[i][1] + hbars[i][1] < 0)) ) {\n//                alert('[' + args.object.type.toUpperCase() + ' (ID: ' + args.object.id + ') BACKGROUND HBARS] You have a negative value in one of your background hbars values, whilst the X axis is in the center');\n//            }\n//\n//            var ystart = (args.object.grapharea - (((hbars[i][0] - args.object.scale2.min) / (args.object.scale2.max - args.object.scale2.min)) * args.object.grapharea));\n//            //var height = (Math.min(hbars[i][1], args.object.max - hbars[i][0]) / (args.object.scale2.max - args.object.scale2.min)) * args.object.grapharea;\n//            var height = args.object.getYCoord(hbars[i][0]) - args.object.getYCoord(hbars[i][1]);\n//\n//           // Account for the X axis being in the center\n//            if (args.object.get('xaxisPosition') == 'center') {\n//                ystart /= 2;\n//                //height /= 2;\n//            }\n//            \n//            ystart += args.object.get('marginTop')\n//\n//            var x = args.object.get('marginLeft');\n//            var y = ystart - height;\n//            var w = args.object.canvas.width - args.object.get('marginLeft') - args.object.get('marginRight');\n//            var h = height;\n//\n//            // Accommodate Opera :-/\n//            if (navigator.userAgent.indexOf('Opera') != -1 && args.object.get('xaxisPosition') == 'center' && h < 0) {\n//                h *= -1;\n//                y = y - h;\n//            }\n//            \n//            //\n//            // Account for X axis at the top\n//            //\n//            //if (args.object.get('xaxisPosition') == 'top') {\n//            //    y  = args.object.canvas.height - y;\n//            //    h *= -1;\n//            //}\n//\n//            //args.object.context.fillStyle = hbars[i][2];\n//            //args.object.context.fillRect(x, y, w, h);\n//        //}\n    };\n\n\n\n\n\n\n\n\n    //\n    // Draws in-graph labels.\n    // \n    // @param  args object An object consisting of:\n    //                      o object\n    // OR\n    //\n    // @param object obj The graph object\n    //\n    RGraph.drawInGraphLabels = function ()\n    {\n        var args             = RGraph.getArgs(arguments, 'object');\n        var properties       = args.object.properties,\n            labels           = properties.labelsIngraph,\n            labels_processed = [];\n\n        // Defaults\n        var fgcolor   = 'black',\n            bgcolor   = 'white',\n            direction = 1;\n\n        if (!labels) {\n            return;\n        }\n\n        // Get the text configuration\n        var textConf = RGraph.getTextConf({\n            object: args.object,\n            prefix: 'labelsIngraph'\n        });\n\n        //\n        // Preprocess the labels array. Numbers are expanded\n        //\n        for (var i=0,len=labels.length; i<len; i+=1) {\n            if (typeof labels[i] === 'number') {\n                for (var j=0; j<labels[i]; ++j) {\n                    labels_processed.push(null);\n                }\n            } else if (typeof labels[i] === 'string' || typeof labels[i] === 'object') {\n                labels_processed.push(labels[i]);\n\n            } else {\n                labels_processed.push('');\n            }\n        }\n\n\n\n\n\n\n\n\n        // Turn off any shadow\n        RGraph.noShadow(args.object);\n\n\n\n\n\n\n\n\n        if (labels_processed && labels_processed.length > 0) {\n\n            for (var i=0,len=labels_processed.length; i<len; i+=1) {\n                if (labels_processed[i]) {\n                    var coords = args.object.coords[i];\n                    \n                    if (coords && coords.length > 0) {\n                        var x      = ((args.object.type == 'bar' ? coords[0] + (coords[2] / 2) : coords[0])) + (properties.labelsIngraphOffsetx || 0);\n                        var y      = (args.object.type == 'bar' ? coords[1] + (coords[3] / 2) : coords[1]) + (properties.labelsIngraphOffsety || 0);\n                        var length = typeof labels_processed[i][4] === 'number' ? labels_processed[i][4] : 25;\n    \n                        args.object.context.beginPath();\n                        args.object.context.fillStyle   = 'black';\n                        args.object.context.strokeStyle = 'black';\n                        \n\n                        if (args.object.type === 'bar') {\n                        \n                            //\n                            // X axis at the top\n                            //\n                            if (args.object.get('xaxisPosition') == 'top') {\n                                length *= -1;\n                            }\n    \n                            if (properties.variant == 'dot') {\n                                args.object.context.moveTo(Math.round(x), args.object.coords[i][1] - 5);\n                                args.object.context.lineTo(Math.round(x), args.object.coords[i][1] - 5 - length);\n                                \n                                var text_x = Math.round(x);\n                                var text_y = args.object.coords[i][1] - 5 - length;\n                            \n                            } else if (properties.variant == 'arrow') {\n                                args.object.context.moveTo(Math.round(x), args.object.coords[i][1] - 5);\n                                args.object.context.lineTo(Math.round(x), args.object.coords[i][1] - 5 - length);\n                                \n                                var text_x = Math.round(x);\n                                var text_y = args.object.coords[i][1] - 5 - length;\n                            \n                            } else {\n    \n                                args.object.context.arc(Math.round(x), y, 2.5, 0, 6.28, 0);\n                                args.object.context.moveTo(Math.round(x), y);\n                                args.object.context.lineTo(Math.round(x), y - length);\n\n                                var text_x = Math.round(x);\n                                var text_y = y - length;\n                            }\n\n                            args.object.context.stroke();\n                            args.object.context.fill();\n                            \n    \n                        } else {\n\n                            if (\n                                typeof labels_processed[i] == 'object' &&\n                                typeof labels_processed[i][3] == 'number' &&\n                                labels_processed[i][3] == -1\n                               ) {\n\n                                // Draw an up arrow\n                                drawUpArrow(x, y)\n                                var valign = 'top';\n                                \n                                var text_x = x;\n                                var text_y = y + 5 + length;\n                            \n                            } else {\n\n                                var text_x = x;\n                                var text_y = y - 5 - length;\n\n                                if (text_y < 5 && (typeof labels_processed[i] === 'string' || typeof labels_processed[i][3] === 'undefined')) {\n                                    text_y = y + 5 + length;\n                                    var valign = 'top';\n                                }\n\n                                if (valign === 'top') {\n                                    /// Draw an down arrow\n                                    drawUpArrow(x, y);\n                                } else {\n                                    /// Draw an up arrow\n                                    drawDownArrow(x, y);\n                                }\n                            }\n                        \n                            args.object.context.fill();\n                        }\n\n                        args.object.context.beginPath();\n\n                            // Foreground color\n                            if ((typeof labels_processed[i] === 'object' && typeof labels_processed[i][1] === 'string')) {\n                                args.object.context.fillStyle = labels_processed[i][1];\n                            } else {\n                                args.object.context.fillStyle = properties.labelsIngraphColor;\n                            }\n\n                            RGraph.text({\n                            \n                              object:            args.object,\n\n                                font:            textConf.font,\n                                size:            textConf.size,\n                                color:           args.object.context.fillStyle || textConf.color,\n                                bold:            textConf.bold,\n                                italic:          textConf.italic,\n\n                                x:               text_x,\n                                y:               text_y + (args.object.properties.textAccessible ? 2 : 0),\n\n                                text:            (typeof labels_processed[i] === 'object' && typeof labels_processed[i][0] === 'string') ? labels_processed[i][0] : labels_processed[i],\n                                valign:          valign || 'bottom',\n                                halign:          'center',\n                                bounding:        true,\n                                'bounding.fill': (typeof labels_processed[i] === 'object' && typeof labels_processed[i][2] === 'string') ? labels_processed[i][2] : 'white',\n                                tag:             'labels ingraph'\n                            });\n                        args.object.context.fill();\n                    }\n\n\n\n\n                    // Draws a down arrow\n                    function drawUpArrow (x, y)\n                    {\n                        args.object.context.moveTo(Math.round(x), y + 5);\n                        args.object.context.lineTo(Math.round(x), y + 5 + length);\n                        \n                        args.object.context.stroke();\n                        args.object.context.beginPath();                                \n                        \n                        // This draws the arrow\n                        args.object.context.moveTo(Math.round(x), y + 5);\n                        args.object.context.lineTo(Math.round(x) - 3, y + 10);\n                        args.object.context.lineTo(Math.round(x) + 3, y + 10);\n                        args.object.context.closePath();\n                    }\n\n\n\n\n                    // Draw an up arrow\n                    function drawDownArrow (x, y)\n                    {\n                        args.object.context.moveTo(Math.round(x), y - 5);\n                        args.object.context.lineTo(Math.round(x), y - 5 - length);\n                        \n                        args.object.context.stroke();\n                        args.object.context.beginPath();\n                        \n                        // This draws the arrow\n                        args.object.context.moveTo(Math.round(x), y - 5);\n                        args.object.context.lineTo(Math.round(x) - 3, y - 10);\n                        args.object.context.lineTo(Math.round(x) + 3, y - 10);\n                        args.object.context.closePath();\n                    }\n                    \n                    valign = undefined;\n                }\n            }\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // This function hides the crosshairs coordinates. This function\n    // has no arguments\n    //\n    RGraph.hideCrosshairCoords = function ()\n    {\n        var div = RGraph.Registry.get('coordinates.coords.div');\n\n        if (   div\n            && div.style.opacity == 1\n            && div.__object__.get('crosshairsCoordsFadeout')\n           ) {\n            \n            var style = RGraph.Registry.get('coordinates.coords.div').style;\n\n            setTimeout(function() {style.opacity = 0.9;}, 25);\n            setTimeout(function() {style.opacity = 0.8;}, 50);\n            setTimeout(function() {style.opacity = 0.7;}, 75);\n            setTimeout(function() {style.opacity = 0.6;}, 100);\n            setTimeout(function() {style.opacity = 0.5;}, 125);\n            setTimeout(function() {style.opacity = 0.4;}, 150);\n            setTimeout(function() {style.opacity = 0.3;}, 175);\n            setTimeout(function() {style.opacity = 0.2;}, 200);\n            setTimeout(function() {style.opacity = 0.1;}, 225);\n            setTimeout(function() {style.opacity = 0;}, 250);\n            setTimeout(function() {style.display = 'none';}, 275);\n        }\n    };\n\n\n\n\n\n\n\n\n\n    //\n    // Draws the3D axes/background\n    // \n    // @param  args object An object consisting of:\n    //                      o object\n    // OR\n    //\n    // @param object obj The chart object\n    //\n    RGraph.draw3DAxes = function ()\n    {\n        var args       = RGraph.getArgs(arguments, 'object');\n        var properties = args.object.properties;\n\n        var marginLeft    = args.object.marginLeft,\n            marginRight   = args.object.marginRight,\n            marginTop     = args.object.marginTop,\n            marginBottom  = args.object.marginBottom,\n            xaxispos      = properties.xaxisPosition,\n            graphArea     = args.object.canvas.height - marginTop - marginBottom,\n            halfGraphArea = graphArea / 2,\n            offsetx       = properties.variantThreedOffsetx,\n            offsety       = properties.variantThreedOffsety,\n            xaxis         = properties.variantThreedXaxis,\n            yaxis         = properties.variantThreedYaxis\n        \n\n        //\n        // Draw the 3D Y axis\n        //\n        if (yaxis) {\n            RGraph.draw3DYAxis(args.object);\n        }\n        \n        \n        \n        // X axis\n        if (xaxis) {\n            if (xaxispos === 'center') {\n                args.object.path(\n                    'b m % % l % % l % % l % % c s #aaa f #ddd',\n                    marginLeft,marginTop + halfGraphArea,\n                    marginLeft + offsetx,marginTop + halfGraphArea - offsety,\n                    args.object.canvas.width - marginRight + offsetx,marginTop + halfGraphArea - offsety,\n                    args.object.canvas.width - marginRight,marginTop + halfGraphArea\n                );\n\n            } else {\n            \n                if (args.object.type === 'hbar') {\n                    var xaxisYCoord = args.object.canvas.height - args.object.properties.marginBottom;\n                } else {\n                    var xaxisYCoord = args.object.getYCoord(0);\n                }\n\n                args.object.path(\n                    'm % % l % % l % % l % % c s #aaa f #ddd',\n                    marginLeft,xaxisYCoord,\n                    marginLeft + offsetx,xaxisYCoord - offsety,\n                    args.object.canvas.width - marginRight + offsetx,xaxisYCoord - offsety,\n                    args.object.canvas.width - marginRight,xaxisYCoord\n                );\n            }\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // Draws the3D Y axis/background\n    // \n    // @param  args object An object consisting of:\n    //                      o object\n    // OR\n    //\n    // @param object obj The chart object\n    //\n    RGraph.draw3DYAxis = function (args)\n    {\n        var args       = RGraph.getArgs(arguments, 'object');\n        var properties = args.object.properties;\n\n        var marginLeft    = args.object.marginLeft,\n            marginRight   = args.object.marginRight,\n            marginTop     = args.object.marginTop,\n            marginBottom  = args.object.marginBottom,\n            xaxispos      = properties.xaxisPosition,\n            graphArea     = args.object.canvas.height - marginTop - marginBottom,\n            halfGraphArea = graphArea / 2,\n            offsetx       = properties.variantThreedOffsetx,\n            offsety       = properties.variantThreedOffsety;\n\n        \n        \n        // Y axis\n        // Commented out the if condition because of drawing oddities\n        //if (!properties.noaxes && !properties.noyaxis) {\n\n            if ( (args.object.type === 'hbar' || args.object.type === 'bar') && properties.yaxisPosition === 'center') {\n                var x = ((args.object.canvas.width - marginLeft - marginRight) / 2) + marginLeft;\n            } else if ((args.object.type === 'hbar' || args.object.type === 'bar') && properties.yaxisPosition === 'right') {\n                var x = args.object.canvas.width - marginRight;\n            } else {\n                var x = marginLeft;\n            }\n\n            args.object.path(\n                'b m % % l % % l % % l % % s #aaa f #ddd',\n                x,marginTop,\n                x + offsetx,marginTop - offsety,\n                x + offsetx,args.object.canvas.height - marginBottom - offsety,\n                x,args.object.canvas.height - marginBottom\n            );\n        //}\n    };\n\n\n\n\n\n\n\n\n    //\n    // Draws a filled rectangle with curvy corners\n    // \n    // @param  args object An object consisting of:\n    //                      o context\n    //                      o x\n    //                      o y\n    //                      o w\n    //                      o h\n    //                      o roundtl\n    //                      o roundtr\n    //                      o roundbl\n    //                      o roundbr\n    // OR\n    //\n    // @param context object The context\n    // @param x       number The X coordinate (top left of the square)\n    // @param y       number The Y coordinate (top left of the square)\n    // @param w       number The width of the rectangle\n    // @param h       number The height of the rectangle\n    // @param         number The radius of the curved corners\n    // @param         boolean Whether the top left corner is curvy\n    // @param         boolean Whether the top right corner is curvy\n    // @param         boolean Whether the bottom right corner is curvy\n    // @param         boolean Whether the bottom left corner is curvy\n    //\n    RGraph.roundedRect = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'context,x,y,width,height,radius,roundtl,roundtr,roundbl,roundbr');\n\n        // The corner radius\n        var r = args.radius ? args.radius : 3;\n\n        // Change the radius based on the smallest width or height\n        r = Math.min(\n            Math.min(args.width, args.height) / 2,\n            args.radius\n        );\n\n        // The corners\n        var corner_tl = (args.roundtl === false) ? false : true,\n            corner_tr = (args.roundtr === false) ? false : true,\n            corner_bl = (args.roundbl === false) ? false : true,\n            corner_br = (args.roundbr === false) ? false : true;\n\n        args.context.beginPath();\n            \n            args.context.moveTo(args.x, args.y + r);\n\n            // Top left corner\n            if (corner_tl) {\n                args.context.arc(args.x + r, args.y + r, r, RGraph.PI, RGraph.PI + RGraph.HALFPI, false);\n            } else {\n                args.context.lineTo(args.x, args.y);\n                args.context.lineTo(args.x + r, args.y);\n            }\n\n            // Top right corner\n            if (corner_tr) {\n                args.context.arc(args.x + args.width - r, args.y + r, r, RGraph.PI + RGraph.HALFPI, 0, false);\n            } else {\n                args.context.lineTo(args.x + args.width, args.y);\n                args.context.lineTo(args.x + args.width, args.y + r);\n            }\n\n\n\n            // Bottom right corner\n            if (corner_br) {\n                args.context.arc(args.x + args.width - r, args.y + args.height - r, r, 0, RGraph.HALFPI, false);\n            } else {\n                args.context.lineTo(args.x + args.width, args.y + args.height);\n                args.context.lineTo(args.x + args.width - r, args.y + args.height);\n            }\n\n            // Bottom left corner\n            if (corner_bl) {\n                args.context.arc(args.x + r, args.y - r + args.height, r, RGraph.HALFPI, RGraph.PI, false);\n            } else {\n                args.context.lineTo(args.x, args.y + args.height);\n                args.context.lineTo(args.x, args.y + args.height - r);\n            }\n            \n            args.context.closePath();\n    };\n\n\n\n\n\n\n\n\n    //\n    // Hides the zoomed canvas.\n    //\n    // UPDATE 14th Oct 2019\n    // Zoom has been removed for some time now so this is now commented out\n    //\n    //RGraph.hideZoomedCanvas =\n    //RGraph.HideZoomedCanvas = function ()\n    //{\n    //    var interval = 10;\n    //    var frames   = 15;\n    //\n    //    if (typeof RGraph.zoom_image === 'object') {\n    //        var obj        = RGraph.zoom_image.obj;\n    //        var properties = obj.properties;\n    //    } else {\n    //        return;\n    //    }\n    //\n    //    if (properties.zoomFadeOut) {\n    //        for (var i=frames,j=1; i>=0; --i, ++j) {\n    //            if (typeof RGraph.zoom_image === 'object') {\n    //                setTimeout(\"RGraph.zoom_image.style.opacity = \" + String(i / 10), j * interval);\n    //            }\n    //        }\n    //\n    //        if (typeof RGraph.zoom_background === 'object') {\n    //            setTimeout(\"RGraph.zoom_background.style.opacity = \" + String(i / frames), j * interval);\n    //        }\n    //    }\n    //\n    //    if (typeof RGraph.zoom_image === 'object') {\n    //        setTimeout(\"RGraph.zoom_image.style.display = 'none'\", properties.zoomFadeOut ? (frames * interval) + 10 : 0);\n    //    }\n    //\n    //    if (typeof RGraph.zoom_background === 'object') {\n    //        setTimeout(\"RGraph.zoom_background.style.display = 'none'\", properties.zoomFadeOut ? (frames * interval) + 10 : 0);\n    //    }\n    //};\n\n\n\n\n\n\n\n\n    //\n    // Adds an event handler\n    // \n    // @param  args object An object consisting of:\n    //                      o object\n    //                      o name\n    //                      o func\n    // OR\n    //\n    // @param object obj   The graph object\n    // @param string event The name of the event, eg ontooltip\n    // @param object func  The callback function\n    //\n    RGraph.addCustomEventListener = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'object,name,func');\n\n        // Initialise the events array if necessary\n        if (typeof RGraph.events[args.object.uid] === 'undefined') {\n            RGraph.events[args.object.uid] = [];\n        }\n\n        // Prepend \"on\" if necessary\n        if (args.name.substr(0, 2) !== 'on') {\n            args.name = 'on' + args.name;\n        }\n\n        RGraph.events[args.object.uid].push([\n            args.object,\n            args.name,\n            args.func\n        ]);\n\n        return RGraph.events[args.object.uid].length - 1;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Used to fire one of the RGraph custom events\n    // \n    // @param  args object An object consisting of:\n    //                      o object\n    //                      o name\n    // OR\n    //\n    // @param object obj   The graph object that fires the event\n    // @param string event The name of the event to fire\n    //\n    RGraph.fireCustomEvent = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'object,name');\n\n        // Prepend the name with \"on\" if necessary\n        if (args.name.substr(0,2) !== 'on') {\n            args.name = 'on' + args.name;\n        }\n\n        if (args.object && args.object.isrgraph) {\n\n            // This allows the eventsMouseout property to work\n            // (for some reason...)\n            //\n            // 25/10/19 - Taken out\n            //\n            //if (args.name.match(/(on)?mouseout/) && typeof args.object.properties.eventsMouseout === 'function') {\n            //    (args.object.properties.eventsMouseout)(args.object);\n            //}\n            // DOM1 style of adding custom events\n            if (args.object[args.name]) {\n                (args.object[args.name])(args.object);\n            }\n\n            var uid = args.object.uid;\n\n            if (   typeof uid === 'string'\n                && typeof RGraph.events === 'object'\n                && typeof RGraph.events[uid] === 'object'\n                && RGraph.events[uid].length > 0) {\n\n                for(var j=0; j<RGraph.events[uid].length; ++j) {\n                    if (RGraph.events[uid][j] && RGraph.events[uid][j][1] === args.name) {\n                        RGraph.events[uid][j][2](args.object);\n                    }\n                }\n            }\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // Clears all the custom event listeners that have been registered\n    // \n    // @param  args object An object consisting of:\n    //                      o uid\n    // OR\n    //\n    // @param    string Limits the clearing to this object UID\n    //\n    RGraph.removeAllCustomEventListeners = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'uid');\n\n        if (args.uid && RGraph.events[args.uid]) {\n            RGraph.events[args.uid] = [];\n        } else {\n            RGraph.events = [];\n            \n            // Use the ObjectRegistry to iterate through all registered objects\n            // and remove the DOM1 listeners\n            RGraph.ObjectRegistry.iterate(function (obj)\n            {\n                if (obj.onclick)     obj.onclick     = null;\n                if (obj.onmousemove) obj.onmousemove = null;\n                if (obj.onmouseover) obj.onmouseover = null;\n                if (obj.onmouseout)  obj.onmouseout  = null;\n            });\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // Clears a particular custom event listener\n    // \n    // @param object obj The graph object\n    // @param number i   This is the index that is return by .addCustomEventListener()\n    //\n    RGraph.removeCustomEventListener = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'object,index');\n\n        if (   typeof RGraph.events === 'object'\n            && typeof RGraph.events[args.object.uid] === 'object'\n            && typeof RGraph.events[args.object.uid][args.index] === 'object') {\n\n            RGraph.events[args.object.uid][args.index] = null;\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // This draws the background\n    // @param  args object An object consisting of:\n    //                      o object\n    // OR\n    // \n    // @param object obj The graph object\n    //\n    RGraph.drawBackgroundImage = function (args)\n    {\n        var args       = RGraph.getArgs(arguments, 'object');\n        var properties = args.object.properties;\n\n        if (typeof properties.backgroundImage === 'string') {\n            if (typeof args.object.canvas.__rgraph_background_image__ === 'undefined') {\n                var img = new Image();\n                img.__object__  = args.object;\n                img.__canvas__  = args.object.canvas;\n                img.__context__ = args.object.context;\n                img.src         = args.object.get('backgroundImage');\n                \n                args.object.canvas.__rgraph_background_image__ = img;\n            } else {\n                img = args.object.canvas.__rgraph_background_image__;\n            }\n\n            // When the image has loaded - redraw the canvas\n            img.onload = function ()\n            {\n                args.object.__rgraph_background_image_loaded__ = true;\n                RGraph.clear(args.object.canvas);\n                RGraph.redrawCanvas(args.object.canvas);\n            }\n                \n            var marginLeft   = args.object.marginLeft;\n            var marginRight  = args.object.marginRight;\n            var marginTop    = args.object.marginTop;\n            var marginBottom = args.object.marginBottom;\n            var stretch      = properties.backgroundImageStretch;\n            var align        = properties.backgroundImageAlign;\n    \n            // Handle backgroundImage.align\n            if (typeof align === 'string') {\n                if (align.indexOf('right') != -1) {\n                    var x = args.object.canvas.width - (properties.backgroundImageW || img.width) - marginRight;\n                } else {\n                    var x = marginLeft;\n                }\n    \n                if (align.indexOf('bottom') != -1) {\n                    var y = args.object.canvas.height - (properties.backgroundImageH || img.height) - marginBottom;\n                } else {\n                    var y = marginTop;\n                }\n            } else {\n                var x = marginLeft || 25;\n                var y = marginTop || 25;\n            }\n\n            // X/Y coords take precedence over the align\n            var x = typeof properties.backgroundImageX === 'number' ? properties.backgroundImageX : x;\n            var y = typeof properties.backgroundImageY === 'number' ? properties.backgroundImageY : y;\n            var w = stretch ? args.object.canvas.width - marginLeft - marginRight : img.width;\n            var h = stretch ? args.object.canvas.height - marginTop - marginBottom : img.height;\n            \n            //\n            // You can now specify the width and height of the image\n            //\n            if (typeof properties.backgroundImageW === 'number') w  = properties.backgroundImageW;\n            if (typeof properties.backgroundImageH === 'number') h = properties.backgroundImageH;\n\n            var oldAlpha = args.object.context.globalAlpha;\n                args.object.context.globalAlpha = properties.backgroundImageAlpha;\n                args.object.context.drawImage(img,x,y,w, h);\n            args.object.context.globalAlpha = oldAlpha;\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // This function determines wshether an object has tooltips or not\n    // \n    // @param  args object An object consisting of:\n    //                      o object\n    // OR\n    //\n    // @param object obj The chart object\n    //\n    RGraph.hasTooltips = function ()\n    {\n        var args       = RGraph.getArgs(arguments, 'object');\n        var properties = args.object.properties;\n\n        if (typeof properties.tooltips == 'object' && properties.tooltips) {\n            for (var i=0,len=properties.tooltips.length; i<len; ++i) {\n                if (!RGraph.isNull(args.object.get('tooltips')[i])) {\n                    return true;\n                }\n            }\n        } else if (typeof properties.tooltips === 'function') {\n            return true;\n        }\n        \n        return false;\n    };\n\n\n\n\n\n\n\n\n    //\n    // This function creates a (G)UID which can be used to identify objects.\n    // \n    // @return string The (G)UID\n    //\n    RGraph.createUID = function ()\n    {\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c)\n        {\n            var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);\n            return v.toString(16);\n        });\n    };\n\n\n\n\n\n\n\n\n    //\n    // This is the object registry, used to facilitate multiple objects per canvas.\n    // \n    // @param  args object An object consisting of:\n    //                      o object\n    // OR\n    //\n    // @param object obj The object to register\n    //\n    RGraph.ObjectRegistry.add = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'object');\n        var uid  = args.object.uid;\n        var id   = args.object.canvas.id;\n\n        //\n        // Index the objects by UID\n        //\n        //RGraph.ObjectRegistry.objects.byUID.push([uid, obj]);\n        RGraph.ObjectRegistry.objects.byUID[RGraph.ObjectRegistry.objects.byUID.length] = [uid, args.object];\n        \n        //\n        // Index the objects by the canvas that they're drawn on\n        //\n        RGraph.ObjectRegistry.objects.byCanvasID.push([\n            id,\n            args.object\n        ]);\n    };\n\n\n\n\n\n\n\n\n    //\n    // Remove an object from the object registry\n    // \n    // @param  args object An object consisting of:\n    //                      o object\n    // OR\n    //\n    // @param object obj The object to remove.\n    //\n    RGraph.ObjectRegistry.remove = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'object');\n        var id  = args.object.id;\n        var uid = args.object.uid;\n\n        for (var i=0; i<RGraph.ObjectRegistry.objects.byUID.length; ++i) {\n            if (RGraph.ObjectRegistry.objects.byUID[i] && RGraph.ObjectRegistry.objects.byUID[i][1].uid == uid) {\n                RGraph.ObjectRegistry.objects.byUID[i] = null;\n            }\n        }\n\n\n        for (var i=0; i<RGraph.ObjectRegistry.objects.byCanvasID.length; ++i) {\n            if (   RGraph.ObjectRegistry.objects.byCanvasID[i]\n                && RGraph.ObjectRegistry.objects.byCanvasID[i][1]\n                && RGraph.ObjectRegistry.objects.byCanvasID[i][1].uid == uid) {\n                \n                RGraph.ObjectRegistry.objects.byCanvasID[i] = null;\n            }\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // Removes all objects from the ObjectRegistry. If either the ID of a canvas is supplied,\n    // or the canvas itself, then only objects pertaining to that canvas are cleared.\n    // \n    // @param  args object An object consisting of:\n    //                      o object or ID or canvas\n    // OR\n    //\n    // @param mixed   Either a canvas object (as returned by document.getElementById()\n    //                or the ID of a canvas (ie a string)\n    //\n    RGraph.ObjectRegistry.clear = function ()\n    {\n        if (   typeof arguments[0] === 'object'\n            && !RGraph.isNull(arguments)\n            && (typeof arguments[0].canvas === 'object' || typeof arguments[0].id === 'string')\n           ) {\n\n            var args = arguments[0];\n\n        } else {\n        \n            // A string has been given\n            if (typeof arguments[0] === 'string') {\n                var args = {\n                    id: arguments[0]\n                };\n            \n            // A canvas has been given\n            } else if (typeof arguments[0] === 'object' && arguments[0].getContext) {\n                var args = {\n                    canvas: arguments[0]\n                };\n\n            // No args given - so cear the entire registry\n            } else {\n\n                RGraph.ObjectRegistry.objects            = {};\n                RGraph.ObjectRegistry.objects.byUID      = [];\n                RGraph.ObjectRegistry.objects.byCanvasID = [];\n                \n                return;\n            }\n        }\n\n        // If an ID is supplied restrict the learing to that\n        if (args.id || args.canvas) { // A string\n\n            // Get the ID of the canvas if a canvas tag has been given\n            if (args.canvas) {\n                args.id = args.canvas.id;\n            }\n\n            var objects = RGraph.ObjectRegistry.getObjectsByCanvasID(args.id);\n\n            for (var i=0,len=objects.length; i<len; ++i) {\n                RGraph.ObjectRegistry.remove(objects[i]);\n            }\n\n        // Clear the entire ObjectRegistry by resetting the object stores\n        } else {\n\n            RGraph.ObjectRegistry.objects            = {};\n            RGraph.ObjectRegistry.objects.byUID      = [];\n            RGraph.ObjectRegistry.objects.byCanvasID = [];\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // Lists all objects in the ObjectRegistry\n    // \n    // @param  args object An object consisting of:\n    //                      o alert\n    // OR\n    //\n    // @param boolean alert Whether to return the list or alert() it\n    //\n    RGraph.ObjectRegistry.list = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'alert');\n        var list = [];\n\n        for (var i=0,len=RGraph.ObjectRegistry.objects.byUID.length; i<len; ++i) {\n            if (RGraph.ObjectRegistry.objects.byUID[i]) {\n                list.push(RGraph.ObjectRegistry.objects.byUID[i][1].type);\n            }\n        }\n\n        if (args.alert) {\n            $p(list);\n        } else {\n            return list;\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // Clears the ObjectRegistry of objects that are of a certain given type\n    // \n    // @param  args object An object consisting of:\n    //                      o type\n    // OR\n    //\n    // @param type string The type to clear\n    //\n    RGraph.ObjectRegistry.clearByType = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'type');\n        var objects = RGraph.ObjectRegistry.objects.byUID;\n\n        for (var i=0,len=objects.length; i<len; ++i) {\n            if (objects[i]) {\n                \n                var uid = objects[i][0],\n                    obj = objects[i][1];\n                \n                if (obj && obj.type === args.type) {\n                    RGraph.ObjectRegistry.remove(obj);\n                }\n            }\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // This function provides an easy way to go through all of the objects that are held in the\n    // Registry\n    // \n    // @param  args object An object consisting of:\n    //                      o type\n    // OR\n    //\n    // @param func function This function is run for every object. Its passed the object as an argument\n    // @param string type Optionally, you can pass a type of object to look for\n    //\n    RGraph.ObjectRegistry.iterate = function ()\n    {\n        var args    = RGraph.getArgs(arguments, 'func,type');\n        var objects = RGraph.ObjectRegistry.objects.byUID;\n\n        for (var i=0,len=objects.length; i<len; ++i) {\n        \n            if (typeof args.type === 'string') {\n                \n                var types = args.type.split(/,/);\n\n                for (var j=0,len2=types.length; j<len2; ++j) {\n                    if (types[j] == objects[i][1].type) {\n                        args.func(objects[i][1]);\n                    }\n                }\n            } else {\n                args.func(objects[i][1]);\n            }\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // Retrieves all objects for a given canvas id\n    // \n    // @param  args object An object consisting of:\n    //                      o id\n    // OR\n    //\n    // @patarm id string The canvas ID to get objects for.\n    //\n    RGraph.ObjectRegistry.getObjectsByCanvasID = function ()\n    {\n        var args  = RGraph.getArgs(arguments, 'id');\n        var store = RGraph.ObjectRegistry.objects.byCanvasID;\n        var ret   = [];\n\n        // Loop through all of the objects and return the appropriate ones\n        for (var i=0,len=store.length; i<len; ++i) {\n            if (store[i] && store[i][0] == args.id) {\n                ret.push(store[i][1]);\n            }\n        }\n\n        return ret;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Retrieves the relevant object based on the X/Y position.\n    // \n    // @param  args object An object consisting of:\n    //                      o event\n    // OR\n    //\n    // @param  object e The event object\n    // @return object   The applicable (if any) object\n    //\n    RGraph.ObjectRegistry.firstbyxy =\n    RGraph.ObjectRegistry.getObjectByXY =\n    RGraph.ObjectRegistry.getFirstObjectByXY = function ()\n    {\n        var args    = RGraph.getArgs(arguments, 'event');\n        var canvas  = args.event.target;\n        var ret     = null;\n        var objects = RGraph.ObjectRegistry.getObjectsByCanvasID(canvas.id);\n\n        for (var i=(objects.length - 1); i>=0; --i) {\n\n            var obj = objects[i].getObjectByXY(args.event);\n\n            if (obj) {\n                return obj;\n            }\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // Retrieves the relevant objects based on the X/Y position.\n    // NOTE This function returns an array of objects\n    // \n    // @param  args object An object consisting of:\n    //                      o event\n    // OR\n    //\n    // @param  object e The event object\n    // @return          An array of pertinent objects. Note the there may be only one object\n    //\n    RGraph.ObjectRegistry.getObjectsByXY = function ()\n    {\n        var args    = RGraph.getArgs(arguments, 'event');\n        var canvas  = args.event.target,\n            ret     = [],\n            objects = RGraph.ObjectRegistry.getObjectsByCanvasID(canvas.id);\n\n        // Retrieve objects \"front to back\"\n        for (var i=(objects.length - 1); i>=0; --i) {\n\n            var obj = objects[i].getObjectByXY(args.event);\n\n            if (obj) {\n                ret.push(obj);\n            }\n        }\n        \n        return ret;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Retrieves the object with the corresponding UID\n    // \n    // @param  args object An object consisting of:\n    //                      o uid\n    // OR\n    //\n    // @param string uid The UID to get the relevant object for\n    //\n    RGraph.ObjectRegistry.get =\n    RGraph.ObjectRegistry.getObjectByUID = function ()\n    {\n        var args    = RGraph.getArgs(arguments, 'uid');\n        var objects = RGraph.ObjectRegistry.objects.byUID;\n\n        for (var i=0,len=objects.length; i<len; ++i) {\n            if (objects[i] && objects[i][1].uid == args.uid) {\n                return objects[i][1];\n            }\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // Brings a chart to the front of the ObjectRegistry by\n    // removing it and then readding it at the end and then\n    // redrawing the canvas\n    // \n    // @param  args object An object consisting of:\n    //                      o object\n    //                      o redraw\n    // OR\n    //\n    // @param object  obj    The object to bring to the front\n    // @param boolean redraw Whether to redraw the canvas after the \n    //                       object has been moved\n    //\n    RGraph.ObjectRegistry.bringToFront = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'object,redraw');\n        var redraw = args.redraw ? true : args.redraw;\n\n        RGraph.ObjectRegistry.remove(args.object);\n        RGraph.ObjectRegistry.add(args.object);\n        \n        if (redraw) {\n            RGraph.redrawCanvas(args.object.canvas);\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // Retrieves the objects that are the given type\n    // \n    // @param  args object An object consisting of:\n    //                      o type\n    // OR\n    //\n    // @param  mixed canvas  The canvas to check. It can either be the canvas object itself or just the ID\n    // @param  string type   The type to look for\n    // @return array         An array of one or more objects\n    //\n    RGraph.ObjectRegistry.type =\n    RGraph.ObjectRegistry.getObjectsByType = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'type');\n\n        var objects = RGraph.ObjectRegistry.objects.byUID;\n        var ret     = [];\n\n        for (i in objects) {\n            if (objects[i] && objects[i][1] && objects[i][1].type && objects[i][1].type && objects[i][1].type == args.type) {\n                ret.push(objects[i][1]);\n            }\n        }\n\n        return ret;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Retrieves the FIRST object that matches the given type\n    //\n    // @param  args object An object consisting of:\n    //                      o type\n    // OR\n    //\n    // @param  string type   The type of object to look for\n    // @return object        The FIRST object that matches the given type\n    //\n    RGraph.ObjectRegistry.first =\n    RGraph.ObjectRegistry.getFirstObjectByType = function ()\n    {\n        var args    = RGraph.getArgs(arguments, 'type');\n        var objects = RGraph.ObjectRegistry.objects.byUID;\n\n        for (var i in objects) {\n            if (objects[i] && objects[i][1] && objects[i][1].type == args.type) {\n                return objects[i][1];\n            }\n        }\n        \n        return null;\n    };\n\n\n\n\n\n\n\n\n    //\n    // This takes centerx, centery, x and y coordinates and returns the\n    // appropriate angle relative to the canvas angle system. Remember\n    // that the canvas angle system starts at the EAST axis\n    // \n    // @param  args object An object consisting of:\n    //                      o cx\n    //                      o cy\n    //                      o x\n    //                      o y\n    // OR\n    //\n    // @param  number cx  The centerx coordinate\n    // @param  number cy  The centery coordinate\n    // @param  number x   The X coordinate (eg the mouseX if coming from a click)\n    // @param  number y   The Y coordinate (eg the mouseY if coming from a click)\n    // @return number     The relevant angle (measured in in RADIANS)\n    //\n    RGraph.getAngleByXY = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'cx,cy,x,y');\n        var angle = Math.atan((args.y - args.cy) / (args.x - args.cx));\n            angle = Math.abs(angle)\n\n        if (args.x >= args.cx && args.y >= args.cy) {\n            angle += RGraph.TWOPI;\n\n        } else if (args.x >= args.cx && args.y < args.cy) {\n            angle = (RGraph.HALFPI - angle) + (RGraph.PI + RGraph.HALFPI);\n\n        } else if (args.x < args.cx && args.y < args.cy) {\n            angle += RGraph.PI;\n\n        } else {\n            angle = RGraph.PI - angle;\n        }\n\n        //\n        // Upper and lower limit checking\n        //\n        if (angle > RGraph.TWOPI) {\n            angle -= RGraph.TWOPI;\n        }\n\n        return angle;\n    };\n\n\n\n\n\n\n\n\n    //\n    // This function returns the distance between two points. In effect the\n    // radius of an imaginary circle that is centered on x1 and y1. The name\n    // of this function is derived from the word \"Hypoteneuse\", which in\n    // trigonmetry is the longest side of a triangle\n    // \n    // @param  args object An object consisting of:\n    //                      o x1\n    //                      o y1\n    //                      o x2\n    //                      o y2\n    // OR\n    //\n    // @param number x1 The original X coordinate\n    // @param number y1 The original Y coordinate\n    // @param number x2 The target X coordinate\n    // @param number y2 The target Y  coordinate\n    //\n    RGraph.getHypLength = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'x1,y1,x2,y2');\n\n        return Math.sqrt(((args.x2 - args.x1) * (args.x2 - args.x1)) + ((args.y2 - args.y1) * (args.y2 - args.y1)));\n    };\n\n\n\n\n\n\n\n\n    //\n    // This function gets the end point (X/Y coordinates) of a given radius.\n    // You pass it the center X/Y, the angle and the radius and this function\n    // will return the endpoint X/Y coordinates.\n    // \n    // @param  args object An object consisting of:\n    //                      o cx\n    //                      o cy\n    //                      o angle\n    //                      o radius\n    // OR\n    //\n    // @param number cx     The center X coord\n    // @param number cy     The center Y coord\n    // @param number angle  The angle that the \"line\" is at from the cx/cy coords\n    // @param number radius The length of the radius\n    //\n    //\n    RGraph.getRadiusEndPoint = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'cx,cy,angle,radius');\n\n        var x    = args.cx + (Math.cos(args.angle) * args.radius);\n        var y    = args.cy + (Math.sin(args.angle) * args.radius);\n\n        return [x, y];\n    };\n\n\n\n\n\n\n\n\n    //\n    // This installs all of the event listeners\n    // \n    // @param  args object An object consisting of:\n    //                      o object\n    // OR\n    //\n    // @param object object The chart object\n    //\n    RGraph.installEventListeners = function ()\n    {\n        var args       = RGraph.getArgs(arguments, 'object');\n        var properties = args.object.properties;\n\n        //\n        // If this function exists, then the dynamic file has been included.\n        //\n        if (RGraph.installCanvasClickListener) {\n\n            RGraph.installWindowMousedownListener(args.object);\n            RGraph.installWindowMouseupListener(args.object);\n            RGraph.installCanvasMousemoveListener(args.object);\n            RGraph.installCanvasMouseupListener(args.object);\n            RGraph.installCanvasMousedownListener(args.object);\n            RGraph.installCanvasClickListener(args.object);\n        \n        } else if (   RGraph.hasTooltips(args.object)\n                   || properties.adjustable\n                   || properties.annotatable\n                   || properties.contextmenu\n                   || properties.keyInteractive\n                   || typeof args.object.onclick     === 'function'\n                   || typeof args.object.onmousemove === 'function'\n                   || typeof args.object.onmouseout  === 'function'\n                   || typeof args.object.onmouseover === 'function'\n                  ) {\n\n            alert('[RGRAPH] You appear to have used dynamic features but not included the file: RGraph.common.dynamic.js');\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // Loosly mimicks the PHP function print_r();\n    //\n    // @param  args object An object consisting of:\n    //                      o object - You only really need to give this argument\n    //                      o alert\n    //                      o indent\n    //                      o count\n    //\n    RGraph.pr = function (obj)\n    {\n        var args = RGraph.getArgs(arguments, 'object,alert,indent,counter');\n\n        var indent = (args.indent ? args.indent : '    ');\n        var str    = '';\n\n        var counter = typeof args.counter == 'number' ? args.counter : 0;\n        \n        if (counter >= 3) {\n            return '';\n        }\n\n        switch (typeof obj) {\n            \n            case 'string':    str += args.object + ' (' + (typeof args.object) + ', ' + args.object.length + ')'; break;\n            case 'number':    str += args.object + ' (' + (typeof args.object) + ')'; break;\n            case 'boolean':   str += args.object + ' (' + (typeof args.object) + ')'; break;\n            case 'function':  str += 'function () {}'; break;\n            case 'undefined': str += 'undefined'; break;\n            case 'null':      str += 'null'; break;\n            \n            case 'object':\n                // In case of null\n                if (RGraph.isNull(args.object)) {\n                    str += 'null';\n                } else {\n                    str += 'Object {' + '\\n'\n                    for (var j in obj) {\n                        str += indent + '    ' + j + ' => ' + RGraph.pr(args.object[j], true, indent + '    ', counter + 1) + '\\n';\n                    }\n                    str += indent + '}';\n                }\n                break;\n            \n            \n            default:\n                str += 'Unknown type: ' + typeof args.object + '';\n                break;\n        }\n\n\n        /**\n        * Finished, now either return if we're in a recursed call, or alert()\n        * if we're not.\n        */\n        if (!args.alert) {\n            alert(str);\n        }\n        \n        return str;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Produces a dashed line\n    // \n    // @param  args object An object consisting of:\n    //                      o context\n    //                      o x1\n    //                      o y1\n    //                      o x2\n    //                      o y2\n    //                      o size\n    // OR\n    //\n    // @param object context The 2D context\n    // @param number x1 The start X coordinate\n    // @param number y1 The start Y coordinate\n    // @param number x2 The end X coordinate\n    // @param number y2 The end Y coordinate\n    // @param number    The size of the dashes\n    //\n    RGraph.dashedLine = function()\n    {\n        var args  = RGraph.getArgs(arguments, 'context,x1,y1,x2,y2,size'),\n            dx    = args.x2 - args.x1,\n            dy    = args.y2 - args.y1,\n            num   = Math.floor(Math.sqrt((dx * dx) + (dy * dy)) / (args.size || 3)),\n            xLen  = dx / num,\n            yLen  = dy / num,\n            count = 0;\n\n        do {\n            if (count % 2 == 0 && count > 0) {\n                args.context.lineTo(args.x1, args.y1);\n            } else {\n                args.context.moveTo(args.x1, args.y1);\n            }\n\n            args.x1 += xLen;\n            args.y1 += yLen;\n            \n            count++;\n            \n        } while(count <= num);\n    };\n\n\n\n\n\n\n\n\n    //\n    // Makes an AJAX call. It calls the given callback (a function) when ready\n    // \n    // @param  args object An object consisting of:\n    //                      o url\n    //                      o callback\n    // OR\n    //\n    // @param string   url      The URL to retrieve\n    // @param function callback A function that is called when the response is ready,\n    //                          there's an example below called \"myCallback\".\n    //\n    RGraph.AJAX = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'url,callback');\n\n        // Mozilla, Safari, ...\n        if (window.XMLHttpRequest) {\n            var httpRequest = new XMLHttpRequest();\n            \n\n        // MSIE\n        } else if (window.ActiveXObject) {\n            var httpRequest = new ActiveXObject(\"Microsoft.XMLHTTP\");\n        }\n\n        httpRequest.onreadystatechange = function ()\n        {\n            if (this.readyState == 4 && this.status == 200) {\n                this.__user_callback__ = args.callback;\n                this.__user_callback__(this.responseText);\n            }\n        }\n\n        httpRequest.open('GET', args.url, true);\n        \n        // Set a Cache-Control header\n        if (httpRequest && httpRequest.setRequestHeader) {\n            httpRequest.setRequestHeader('Cache-Control', 'no-cache');\n        }\n        \n        httpRequest.send();\n    };\n\n\n\n\n\n\n\n\n    //\n    // Makes an AJAX POST request. It calls the given callback (a function) when ready\n    // \n    // @param  args object An object consisting of:\n    //                      o url\n    //                      o data\n    //                      o callback\n    // OR\n    //\n    // @param string   url      The URL to retrieve\n    // @param object   data     The POST data\n    // @param function callback A function that is called when the response is ready, there's an example below\n    //                          called \"myCallback\".\n    //\n    // DO NOT REMOVE THIS ALIAS!\n    RGraph.AJAX.post =\n    RGraph.AJAX.POST = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'url,data,callback');\n\n        // Used when building the POST string\n        var crumbs = [];\n\n        // Mozilla, Safari, ...\n        if (window.XMLHttpRequest) {\n            var httpRequest = new XMLHttpRequest();\n\n        // MSIE\n        } else if (window.ActiveXObject) {\n            var httpRequest = new ActiveXObject(\"Microsoft.XMLHTTP\");\n        }\n\n        httpRequest.onreadystatechange = function ()\n        {\n            if (this.readyState == 4 && this.status == 200) {\n                this.__user_callback__ = args.callback;\n                this.__user_callback__(this.responseText);\n            }\n        }\n\n        httpRequest.open('POST', args.url, true);\n        httpRequest.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");\n        \n        for (i in args.data) {\n            if (typeof i == 'string') {\n                crumbs.push(i + '=' + encodeURIComponent(args.data[i]));\n            }\n        }\n\n        httpRequest.send(crumbs.join('&'));\n    };\n\n\n\n\n\n\n\n\n    //\n    // Uses the above function but calls the call back passing a number as its argument\n    // \n    // @param  args object An object consisting of:\n    //                      o url\n    //                      o callback\n    // OR\n    //\n    // @param url string The URL to fetch\n    // @param callback function Your callback function (which is passed the number as an argument)\n    //\n    RGraph.AJAX.getNumber = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'url,callback');\n\n        RGraph.AJAX(args.url, function ()\n        {\n            var num = parseFloat(this.responseText);\n\n            args.callback(num);\n        });\n    };\n\n\n\n\n\n\n\n\n    //\n    // Uses the above function but calls the call back passing a string as its argument\n    // \n    // @param  args object An object consisting of:\n    //                      o url\n    //                      o callback\n    // OR\n    //\n    // @param url string The URL to fetch\n    // @param callback function Your callback function (which is passed the string as an argument)\n    //\n    RGraph.AJAX.getString = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'url,callback');\n\n        RGraph.AJAX(args.url, function ()\n        {\n            var str = String(this.responseText);\n\n            args.callback(str);\n        });\n    };\n\n\n\n\n\n\n\n\n    //\n    // Uses the above function but calls the call back passing JSON (ie a JavaScript object ) as its argument\n    // \n    // @param  args object An object consisting of:\n    //                      o url\n    //                      o callback\n    // OR\n    //\n    // @param url string The URL to fetch\n    // @param callback function Your callback function (which is passed the JSON object as an argument)\n    //\n    RGraph.AJAX.getJSON = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'url,callback');\n\n        RGraph.AJAX(args.url, function ()\n        {\n            var json = eval('(' + this.responseText + ')');\n\n            args.callback(json);\n        });\n    };\n\n\n\n\n\n\n\n\n    //\n    // Uses the above RGraph.AJAX function but calls the call back passing an array as its argument.\n    // Useful if you're retrieving CSV data\n    // \n    // @param  args object An object consisting of:\n    //                      o url\n    //                      o callback\n    //                      o sparator (optional)\n    // OR\n    //\n    // @param url      string   The URL to fetch\n    // @param callback function Your callback function (which is passed the CSV/array as an argument)\n    // @param          string   An OPTIONAL separator character\n    //\n    RGraph.AJAX.getCSV = function ()\n    {\n        var args      = RGraph.getArgs(arguments, 'url,callback,separator');\n        var separator = args.separator ? args.separator : ',';\n\n        RGraph.AJAX(args.url, function ()\n        {\n            var regexp = new RegExp(separator);\n            var arr = this.responseText.split(regexp);\n            \n            // Convert the strings to numbers\n            for (var i=0,len=arr.length;i<len;++i) {\n                arr[i] = parseFloat(arr[i]);\n            }\n\n            args.callback(arr);\n        });\n    };\n\n\n\n\n\n\n\n\n    //\n    // Rotates the canvas\n    // \n    // @param  args object An object consisting of:\n    //                      o canvas\n    //                      o x\n    //                      o y\n    //                      o angle (measured in radians)\n    // OR\n    //\n    // @param object canvas The canvas to rotate\n    // @param  int   x      The X coordinate about which to rotate the canvas\n    // @param  int   y      The Y coordinate about which to rotate the canvas\n    // @param  int   angle  The angle(in RADIANS) to rotate the canvas by\n    //\n    RGraph.rotateCanvas = function ()\n    {\n        var args    = RGraph.getArgs(arguments, 'canvas,x,y,angle');\n        var context = args.canvas.getContext('2d');\n\n        context.translate(args.x,args.y);\n        context.rotate(args.angle);\n        context.translate(0 - args.x, 0 - args.y);    \n    };\n\n\n\n\n\n\n\n\n    //\n    // Measures text by creating a DIV in the document and adding the relevant text to it.\n    // Then checking the .offsetWidth and .offsetHeight.\n    // \n    // @param  args object An object consisting of:\n    //                      o text\n    //                      o bold\n    //                      o font\n    //                      o size\n    // OR\n    //\n    // @param  string text   The text to measure\n    // @param  bool   bold   Whether the text is bold or not\n    // @param  string font   The font to use\n    // @param  size   number The size of the text (in pts)\n    // @return array         A two element array of the width and height of the text\n    //\n    RGraph.measureText = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'text,bold,font,size');\n\n        // Add the sizes to the cache as adding DOM elements is costly and causes slow downs\n        if (typeof RGraph.measuretext_cache === 'undefined') {\n            RGraph.measuretext_cache = [];\n        }\n\n        var str = args.text + ':' + args.bold + ':' + args.font + ':' + args.size;\n\n        if (typeof RGraph.measuretext_cache == 'object' && RGraph.measuretext_cache[str]) {\n            return RGraph.measuretext_cache[str];\n        }\n        \n        if (!RGraph.measuretext_cache['text-div']) {\n            var div = document.createElement('DIV');\n                div.style.position = 'absolute';\n                div.style.top = '-100px';\n                div.style.left = '-100px';\n                div.style.lineHeight = (args.size || 12) * 1.5 + 'px';\n            document.body.appendChild(div);\n\n            // Now store the newly created DIV\n            RGraph.measuretext_cache['text-div'] = div;\n\n        } else if (RGraph.measuretext_cache['text-div']) {\n            var div = RGraph.measuretext_cache['text-div'];\n        \n            // Clear the contents of the DIV tag\n            while(div.firstChild){\n                div.removeChild(div.firstChild);\n            }\n        }\n\n        div.insertAdjacentHTML('afterbegin', String(args.text).replace(/\\r?\\n/g, '<br />'));\n        div.style.fontFamily = args.font;\n        div.style.fontWeight = args.bold ? 'bold' : 'normal';\n        div.style.fontSize   = (args.size || 12) + 'pt';\n\n        //document.body.removeChild(div);\n        RGraph.measuretext_cache[str] = [div.offsetWidth, div.offsetHeight];\n        \n        return [div.offsetWidth, div.offsetHeight];\n    };\n\n\n\n\n\n\n\n\n    //\n    // New text function. Accepts two arguments:\n    //  o opt - An object/hash/map of properties. This can consist of:\n    //          object           The RGraph chart object (THIS OR BELOW OPTION IS REQUIRED)\n    //          context          The canvases context. This can be given in\n    //                           place of the above      (THIS OR ABOVE OPTION IS REQUIRED)\n    //          x                The X coordinate        (REQUIRED)\n    //          y                The Y coordinate        (REQUIRED)\n    //          text             The text to show        (REQUIRED)\n    //          font             The font to use\n    //          size             The size of the text (in pt)\n    //          italic           Whether the text should be italic or not\n    //          bold             Whether the text should be bold or not\n    //          marker           Whether to show a marker that indicates the X/Y coordinates\n    //          valign           The vertical alignment\n    //          halign           The horizontal alignment\n    //          bounding         Whether to draw a bounding box for the text\n    //          boundingStroke   The strokeStyle of the bounding box\n    //          boundingFill     The fillStyle of the bounding box\n    //          accessible       If false this will cause the text to be\n    //                           rendered as native canvas text. DOM text otherwise\n    //\n    RGraph.text = function (args)\n    {\n        // Allow for the use of a single argument or two\n        // 1. First handle two arguments\n        if (arguments[0] && arguments[1] && (typeof arguments[1].text === 'string' || typeof arguments[1].text === 'number' ) ) {\n            var obj  = arguments[0],\n                args = arguments[1];\n\n        // 2. The alternative is a single option\n       } else {\n\n            var obj = args.object;\n\n            //\n            // The text arg must be a string or a number\n            //\n            if (typeof args.text === 'number') {\n                args.text = String(args.text);\n            }\n        }\n        \n        // Get the defaults for the text function from RGraph.text.defaults object\n        for (var i in RGraph.text.defaults) {\n            if (typeof i === 'string' && typeof args[i] === 'undefined') {\n                args[i] = RGraph.text.defaults[i];\n            }\n        }\n\n        // Use DOM nodes to get better quality text. This option is BETA quality\n        // code and most likely and will not work if you use 3D or if you use\n        // your own transformations.\n        function domtext ()\n        {\n            //\n            // Check the font property to see if it contains the italic keyword,\n            // and if it does then take it out and set the italic property\n            //\n            if (String(args.size).toLowerCase().indexOf('italic') !== -1) {\n                args.size = args.size.replace(/ *italic +/, '');\n                args.italic = true;\n            }\n\n\n\n            // Used for caching the DOM node\n            var cacheKey = Math.abs(parseInt(args.x)) + '_' + Math.abs(parseInt(args.y)) + '_' + String(args.text).replace(/[^a-zA-Z0-9]+/g, '_') + '_' + obj.canvas.id;\n\n\n\n            // Wrap the canvas in a DIV\n            if (!obj.canvas.rgraph_domtext_wrapper) {\n\n                var wrapper = document.createElement('div');\n                    wrapper.id        = obj.canvas.id + '_rgraph_domtext_wrapper';\n                    wrapper.className = 'rgraph_domtext_wrapper';\n\n                    // The wrapper can be configured to hide or show the\n                    // overflow with the textAccessibleOverflow option\n                    wrapper.style.overflow = obj.properties.textAccessibleOverflow != false && obj.properties.textAccessibleOverflow != 'hidden' ? 'visible' : 'hidden';\n                    \n                    wrapper.style.width    = obj.canvas.offsetWidth + 'px';\n                    wrapper.style.height   = obj.canvas.offsetHeight + 'px';\n\n                    wrapper.style.cssFloat   = obj.canvas.style.cssFloat;\n                    wrapper.style.display    = obj.canvas.style.display || 'inline-block';\n                    wrapper.style.position   = obj.canvas.style.position || 'relative';\n                    wrapper.style.left       = obj.canvas.style.left;\n                    wrapper.style.right      = obj.canvas.style.right;\n                    wrapper.style.top        = obj.canvas.style.top;\n                    wrapper.style.bottom     = obj.canvas.style.bottom;\n                    wrapper.style.width      = obj.canvas.width + 'px';\n                    wrapper.style.height     = obj.canvas.height + 'px';\n                    wrapper.style.lineHeight = 'initial';\n\n                    obj.canvas.style.position      = 'absolute';\n                    obj.canvas.style.left          = 0;\n                    obj.canvas.style.top           = 0;\n                    obj.canvas.style.display       = 'inline';\n                    obj.canvas.style.cssFloat      = 'none';\n\n\n                    if ((obj.type === 'bar' || obj.type === 'bipolar' || obj.type === 'hbar') && obj.properties.variant === '3d') {\n                        wrapper.style.transform = 'skewY(5.7deg)';\n                    }\n\n                obj.canvas.parentNode.insertBefore(wrapper, obj.canvas);\n                \n                // Remove the canvas from the DOM and put it in the wrapper\n                obj.canvas.parentNode.removeChild(obj.canvas);\n                wrapper.appendChild(obj.canvas);\n                \n                obj.canvas.rgraph_domtext_wrapper = wrapper;\n                \n                // TODO Add a subwrapper here\n\n            } else {\n                wrapper = obj.canvas.rgraph_domtext_wrapper;\n            }\n\n\n\n            var defaults = {\n                size:   12,\n                font:   'Arial',\n                italic: 'normal',\n                bold:   'normal',\n                valign: 'bottom',\n                halign: 'left',\n                marker: true,\n                color:  context.fillStyle,\n                bounding: {\n                    enabled:   false,\n                    fill:      'rgba(255,255,255,0.7)',\n                    stroke:    '#666',\n                    linewidth: 1\n                }\n            }\n\n            \n            // Transform \\n to the string [[RETURN]] which is then replaced\n            // further down\n            args.text = String(args.text).replace(/\\r?\\n/g, '[[RETURN]]');\n\n\n            // Create the node cache array that nodes\n            // already created are stored in\n            if (typeof RGraph.text.domNodeCache === 'undefined') {\n                RGraph.text.domNodeCache = new Array();\n            }\n            \n            if (typeof RGraph.text.domNodeCache[obj.id] === 'undefined') {\n                RGraph.text.domNodeCache[obj.id] = new Array();\n            }\n\n            // Create the dimension cache array that node\n            // dimensions are stored in\n            if (typeof RGraph.text.domNodeDimensionCache === 'undefined') {\n                RGraph.text.domNodeDimensionCache = new Array();\n            }\n            \n            if (typeof RGraph.text.domNodeDimensionCache[obj.id] === 'undefined') {\n                RGraph.text.domNodeDimensionCache[obj.id] = new Array();\n            }\n\n\n\n            // Create the DOM node\n            if (!RGraph.text.domNodeCache[obj.id] || !RGraph.text.domNodeCache[obj.id][cacheKey]) {\n\n                var span = document.createElement('span');\n                    span.style.position      = 'absolute';\n                    span.style.display       = 'inline';\n                    \n                    span.className        =   ' rgraph_accessible_text'\n                                            + ' rgraph_accessible_text_' + obj.id\n                                            + ' rgraph_accessible_text_' + (args.tag || '').replace(/\\./, '_')\n                                            + ' rgraph_accessible_text_' + obj.type\n                                            + ' ' + (args.cssClass || '');\n\n                    // This is here to accommodate 3D charts\n                    //\n                    span.style.left       = (args.x * (parseInt(obj.canvas.offsetWidth) / parseInt(obj.canvas.width))) + 'px';\n                    span.style.top        = (args.y * (parseInt(obj.canvas.offsetHeight) / parseInt(obj.canvas.height)))  + 'px';\n                    \n                    // This could be used for none-3d charts\n                    //\n                    //span.style.left       = args.x + 'px';\n                    //span.style.top        = args.y  + 'px';\n                    \n                    span.style.color      = args.color || defaults.color;\n                    span.style.fontFamily = args.font || defaults.font;\n                    span.style.fontWeight = args.bold ? 'bold' : defaults.bold;\n                    span.style.fontStyle  = args.italic ? 'italic' : defaults.italic;\n                    span.style.fontSize   = (args.size || defaults.size) + 'pt'; // Also see line-height setting a few lines down\n                    span.style.whiteSpace = 'nowrap';\n                    span.style.lineHeight = RGraph.ISIE ? 'normal' : 'initial'; // Also see font-size setting a few lines up\n                    span.tag              = args.tag;\n                    span.setAttribute('data-tag', args.tag);\n\n\n                    // CSS angled text. This should be conasidered BETA quality code at the moment,\n                    // but it seems to be OK. You may need to use the labelsOffsety when using this\n                    // option.\n                    if (typeof args.angle === 'number' && args.angle !== 0) {\n                    \n                        var coords = RGraph.measureText(\n                            args.text,\n                            args.bold,\n                            args.font,\n                            args.size\n                        );\n                    \n                        //span.style.left = parseFloat(span.style.left) - coords[0] + 'px';\n                        var hOrigin, vOrigin;\n                        \n                        if (args.halign === 'center') {hOrigin = '50%';}\n                        else if (args.halign === 'right') {hOrigin = '100%';}\n                        else {hOrigin = '0%';}\n                        \n                        if (args.valign === 'center') {vOrigin = '50%';}\n                        else if (args.valign === 'top') {vOrigin = '0%';}\n                        else {vOrigin = '100%';}\n                        \n                        span.style.transformOrigin = '{1} {2}'.format(\n                            hOrigin,\n                            vOrigin\n                        );\n                        \n                        span.style.transform       = 'rotate(' + args.angle + 'deg)';\n                    }\n\n\n\n\n                    // Shadow\n                    span.style.textShadow = '{1}px {2}px {3}px {4}'.format(\n                        context.shadowOffsetX,\n                        context.shadowOffsetY,\n                        context.shadowBlur,\n                        context.shadowColor\n                    );\n\n\n                    if (args.bounding) {\n                        span.style.border          = '1px solid ' + (args['bounding.stroke'] || defaults.bounding.stroke);\n                        span.style.backgroundColor = args['bounding.fill'] || defaults.bounding.fill;\n                        span.style.borderWidth     = typeof args['bounding.linewidth'] === 'number' ? args['bounding.linewidth'] : defaults.bounding.linewidth;\n                    }\n                    // Pointer events\n                    if (\n                           (typeof obj.properties.textAccessiblePointerevents === 'undefined' || obj.properties.textAccessiblePointerevents)\n                        && obj.properties.textAccessiblePointerevents !== 'none'\n                       ) {\n                        \n                        span.style.pointerEvents =  'auto';\n                    } else {\n                        span.style.pointerEvents =  'none';\n                    }\n\n                    span.style.padding = args.bounding ? '2px' : null; // Changed to 2px on 16th January 2019\n                    span.__text__      = args.text\n                    \n                span.insertAdjacentHTML(\n                    'afterbegin',\n                    args.text.replace('&', '&amp;')\n                             .replace('<', '&lt;')\n                             .replace('>', '&gt;')\n                             .replace(/\\[\\[RETURN\\]\\]/g, '<br />')\n                );\n                //span.innerHTML     = args.text.replace('&', '&amp;')\n                //                             .replace('<', '&lt;')\n                //                             .replace('>', '&gt;');\n                \n                // Now replace the string [[RETURN]] with a <br />\n                //span.innerHTML = span.innerHTML.replace(/\\[\\[RETURN\\]\\]/g, '<br />');\n\n                wrapper.appendChild(span);\n\n                // Alignment defaults\n                args.halign = args.halign || 'left';\n                args.valign = args.valign || 'bottom';\n                \n                // Horizontal alignment\n                if (args.halign === 'right') {\n                    span.style.left      = parseFloat(span.style.left) - span.offsetWidth + 'px';\n                    span.style.textAlign = 'right';\n                } else if (args.halign === 'center') {\n                    span.style.left      = parseFloat(span.style.left) - (span.offsetWidth  / 2) + 'px';\n                    span.style.textAlign = 'center';\n                }\n                \n                // Vertical alignment\n                if (args.valign === 'top') {\n                    // Nothing to do here\n                } else if (args.valign === 'center') {\n                    span.style.top = parseFloat(span.style.top) - (span.offsetHeight / 2) + 'px';\n                } else {\n                    span.style.top = parseFloat(span.style.top) - span.offsetHeight + 'px';\n                }\n                        \n                \n                var offsetWidth  = parseFloat(span.offsetWidth),\n                    offsetHeight = parseFloat(span.offsetHeight),\n                    top          = parseFloat(span.style.top),\n                    left         = parseFloat(span.style.left);\n\n                RGraph.text.domNodeCache[obj.id][cacheKey] = span;\n                RGraph.text.domNodeDimensionCache[obj.id][cacheKey] = {\n                      left: left,\n                       top: top,\n                     width: offsetWidth,\n                    height: offsetHeight\n                };\n                span.id = cacheKey;\n\n\n            \n            } else {\n                span = RGraph.text.domNodeCache[obj.id][cacheKey];\n                span.style.display = 'inline';\n                \n                var offsetWidth  = RGraph.text.domNodeDimensionCache[obj.id][cacheKey].width,\n                    offsetHeight = RGraph.text.domNodeDimensionCache[obj.id][cacheKey].height,\n                    top          = RGraph.text.domNodeDimensionCache[obj.id][cacheKey].top,\n                    left         = RGraph.text.domNodeDimensionCache[obj.id][cacheKey].left;\n            }\n\n\n            \n\n            \n            \n            // If requested, draw a marker to indicate the coords\n            if (args.marker) {\n                obj.path(\n                    'b m % % l % % m % % l % % s',\n                    args.x - 5, args.y,\n                    args.x + 5, args.y,\n                    args.x, args.y - 5,\n                    args.x, args.y + 5\n                );\n            }\n            \n            //\n            // If its a drawing API text object then allow\n            // for events and tooltips\n            //\n            if (obj.type === 'drawing.text') {\n\n                // Mousemove\n                //if (obj.properties.eventsMousemove) {\n                //    span.addEventListener('mousemove', function (e) {(obj.properties.eventsMousemove)(e, obj);}, false);\n                //}\n                \n                // Click\n                //if (obj.properties.eventsClick) {\n                //    span.addEventListener('click', function (e) {(obj.properties.eventsClick)(e, obj);}, false);\n                //}\n                \n                // Tooltips\n                if (obj.properties.tooltips) {\n                    span.addEventListener(\n                        obj.properties.tooltipsEvent.indexOf('mousemove') !== -1 ? 'mousemove' : 'click',\n                        function (e)\n                        {\n                            if (   !RGraph.Registry.get('tooltip')\n                                || RGraph.Registry.get('tooltip').__index__ !== 0\n                                || RGraph.Registry.get('tooltip').__object__.uid != obj.uid\n                               ) {\n                               \n                                RGraph.hideTooltip();\n                                RGraph.redraw();\n                                RGraph.tooltip(obj, obj.properties.tooltips[0], args.x, args.y, 0, e);\n                            }\n                        },\n                        false\n                    );\n                }\n            }\n\n            // Build the return value\n            var ret        = {};\n                ret.x      = left;\n                ret.y      = top;\n                ret.width  = offsetWidth;\n                ret.height = offsetHeight;\n                ret.object = obj;\n                ret.text   = args.text;\n                ret.tag    = args.tag;\n\n            \n            // The reset() function clears the domNodeCache\n            ////\n            // @param object OPTIONAL You can pass in the canvas to limit the\n            //                        clearing to that canvas.\n            RGraph.text.domNodeCache.reset = function ()\n            {\n                // Limit the clearing to a single canvas tag\n                if (arguments[0]) {\n                    \n                    if (typeof arguments[0] === 'string') {\n                        var canvas = document.getElementById(arguments[0])\n                    } else {\n                        var canvas = arguments[0];\n                    }\n\n                    var nodes = RGraph.text.domNodeCache[canvas.id];\n\n                    for (j in nodes) {\n                        \n                        var node = RGraph.text.domNodeCache[canvas.id][j];\n                        \n                        if (node && node.parentNode) {\n                            node.parentNode.removeChild(node);\n                        }\n                    }\n                    \n                    RGraph.text.domNodeCache[canvas.id]          = [];\n                    RGraph.text.domNodeDimensionCache[canvas.id] = [];\n\n                // Clear all DOM text from all tags\n                } else {\n                    for (i in RGraph.text.domNodeCache) {\n                        for (j in RGraph.text.domNodeCache[i]) {\n                            if (RGraph.text.domNodeCache[i][j] && RGraph.text.domNodeCache[i][j].parentNode) {\n                                RGraph.text.domNodeCache[i][j].parentNode.removeChild(RGraph.text.domNodeCache[i][j]);\n                            }\n                        }\n                    }\n\n                    RGraph.text.domNodeCache          = [];\n                    RGraph.text.domNodeDimensionCache = [];\n                }\n            };\n\n\n\n\n            //\n            // Helps you get hold of the SPAN tag nodes that hold the text on the chart\n            //\n            RGraph.text.find = function (args)\n            {\n                var span, nodes = [];\n                \n                if (args.object && args.object.isrgraph) {\n                    var id = args.object.id;\n                } else if (args.id) {\n                    var id     = typeof args.id === 'string' ? args.id : args.object.id;\n                    args.object = document.getElementById(id).__object__;\n                } else {\n                    alert('[RGRAPH] You Must give either an object or an ID to the RGraph.text.find() function');\n                    return false;\n                }\n\n                for (i in RGraph.text.domNodeCache[id]) {\n                \n                    span = RGraph.text.domNodeCache[id][i];\n\n                    // A full tag is given\n                    if (typeof args.tag === 'string' && args.tag === span.tag) {\n                        nodes.push(span);\n                        continue;\n                    }\n\n\n\n                    // A regex is given as the tag\n                    if (typeof args.tag === 'object' && args.tag.constructor.toString().indexOf('RegExp')) {\n\n                        var regexp = new RegExp(args.tag);\n\n                        if (regexp.test(span.tag)) {\n                            nodes.push(span);\n                            continue;\n                        }\n                    }\n\n\n\n                    // A full text is given\n                    if (typeof args.text === 'string' && args.text === span.__text__) {\n                        nodes.push(span);\n                        continue;\n                    }\n\n\n\n                    // Regex for the text is given\n                    // A regex is given as the tag\n                    if (typeof args.text === 'object' && args.text.constructor.toString().indexOf('RegExp')) {\n\n                        var regexp = new RegExp(args.text);\n\n                        if (regexp.test(span.__text__)) {\n                            nodes.push(span);\n                            \n                        continue;\n                        }\n                    }\n                }\n                \n                // If a callback has been specified then call it whilst\n                // passing it the text\n                if (typeof args.callback === 'function') {\n                    (args.callback)({nodes: nodes, object:args.object});\n                }\n\n                return nodes;\n            };\n\n\n\n\n            //\n            // Add the SPAN tag to the return value\n            //\n            ret.node = span;\n\n\n            //\n            // Save and then return the details of the text (but oly\n            // if it's an RGraph object that was given)\n            //\n            if (obj && obj.isrgraph && obj.coordsText) {\n                obj.coordsText.push(ret);\n            }\n\n\n            return ret;\n        }\n\n\n\n\n        //\n        // An RGraph object can be given, or a string or the 2D rendering context\n        // The coords are placed on the obj.coordsText variable ONLY if it's an RGraph object. The function\n        // still returns the cooords though in all cases.\n        //\n        if (obj && obj.isrgraph) {\n            var obj     = obj;\n            var canvas  = obj.canvas;\n            var context = obj.context;\n        \n        } else if (typeof obj == 'string') {\n            var canvas  = document.getElementById(obj);\n            var context = canvas.getContext('2d');\n            var obj     = canvas.__object__;\n        \n        } else if (typeof obj.getContext === 'function') {\n            var canvas  = obj;\n            var context = canvas.getContext('2d');\n            var obj     = canvas.__object__;\n        \n        } else if (obj.toString().indexOf('CanvasRenderingContext2D') != -1 || RGraph.ISIE8 && obj.moveTo) {\n            var context  = obj;\n            var canvas   = obj.canvas;\n            var obj      = canvas.__object__;\n\n        // IE7/8\n        } else if (RGraph.ISOLD && obj.fillText) {\n            var context  = obj;\n            var canvas   = obj.canvas;\n            var obj      = canvas.__object__;\n        }\n\n\n        //\n        // Changed the name of boundingFill/boundingStroke - this allows you to still use those names\n        //\n\n        if (typeof args.boundingFill      === 'string') args['bounding.fill']   = args.boundingFill;\n        if (typeof args.boundingStroke    === 'string') args['bounding.stroke'] = args.boundingStroke;\n        if (typeof args.boundingLinewidth === 'number') args['bounding.linewidth'] = args.boundingLinewidth;\n\n\n\n        //\n        // If textConfPrefix is set then get the style configuration\n        //\n        if (typeof args.textConfPrefix === 'string' && args.textConfPrefix.length) {\n            var textConf = RGraph.getTextConf({\n                object: obj,\n                prefix: args.textConfPrefix\n            });\n            \n            args.font   = textConf.font;\n            args.size   = textConf.size;\n            args.color  = textConf.color;\n            args.bold   = textConf.bold;\n            args.italic = textConf.italic;\n        }\n\n\n        if (typeof args.accessible === 'undefined') {\n            if (obj && obj.properties.textAccessible) {\n                return domtext();\n            }\n        } else if (typeof args.accessible === 'boolean' && args.accessible) {\n            return domtext();\n        }\n\n\n\n\n        var x              = args.x,\n            y              = args.y,\n            originalX      = x,\n            originalY      = y,\n            text           = args.text,\n            text_multiline = typeof text === 'string' ? text.split(/\\r?\\n/g) : '',\n            numlines       = text_multiline.length,\n            font           = args.font ? args.font : 'Arial',\n            size           = args.size ? args.size : 10,\n            size_pixels    = size * 1.5,\n            bold           = args.bold,\n            italic         = args.italic,\n            halign         = args.halign ? args.halign : 'left',\n            valign         = args.valign ? args.valign : 'bottom',\n            tag            = typeof args.tag == 'string' && args.tag.length > 0 ? args.tag : '',\n            marker         = args.marker,\n            angle          = args.angle || 0;\n\n\n        //\n        // The text arg must be a string or a number\n        //\n        if (typeof text == 'number') {\n            text = String(text);\n        }\n\n\n\n        var bounding                = args.bounding,\n            bounding_stroke         = args['bounding.stroke'] ? args['bounding.stroke'] : 'black',\n            bounding_fill           = args['bounding.fill'] ? args['bounding.fill'] : 'rgba(255,255,255,0.7)',\n            bounding_shadow         = args['bounding.shadow'],\n            bounding_shadow_color   = args['bounding.shadow.color'] || '#ccc',\n            bounding_shadow_blur    = args['bounding.shadow.blur'] || 3,\n            bounding_shadow_offsetx = args['bounding.shadow.offsetx'] || 3,\n            bounding_shadow_offsety = args['bounding.shadow.offsety'] || 3,\n            bounding_linewidth      = typeof args['bounding.linewidth'] === 'number' ? args['bounding.linewidth'] : 1;\n\n\n\n        //\n        // Initialize the return value to an empty object\n        //\n        var ret = {};\n        \n        //\n        // Color\n        //\n        if (typeof args.color === 'string') {\n            var orig_fillstyle = context.fillStyle;\n            context.fillStyle = args.color;\n        }\n\n\n\n\n        if (typeof text !== 'string') {\n            return;\n        }\n        \n        \n        \n        //\n        // This facilitates vertical text\n        //\n        if (angle != 0) {\n            context.save();\n            context.translate(x, y);\n            context.rotate((Math.PI / 180) * angle)\n            x = 0;\n            y = 0;\n        }\n\n\n        \n        //\n        // Set the font\n        //\n        context.font = (args.italic ? 'italic ' : '') + (args.bold ? 'bold ' : '') + size + 'pt ' + font;\n\n\n\n        //\n        // Measure the width/height. This must be done AFTER the font has been set\n        //\n        var width=0;\n        for (var i=0; i<numlines; ++i) {\n            width = Math.max(width, context.measureText(text_multiline[i]).width);\n        }\n        var height = size_pixels * numlines;\n\n\n\n\n        //\n        // Accommodate old MSIE 7/8\n        //\n        //if (document.all && RGraph.ISOLD) {\n            //y += 2;\n        //}\n\n\n\n        //\n        // If marker is specified draw a marker at the X/Y coordinates\n        //\n        if (args.marker) {\n            \n            var marker_size = 10;\n            var strokestyle = context.strokeStyle;\n            \n            context.beginPath();\n                context.strokeStyle = 'red';\n                context.moveTo(x, y - marker_size);\n                context.lineTo(x, y + marker_size);\n                context.moveTo(x - marker_size, y);\n                context.lineTo(x + marker_size, y);\n            context.stroke();\n            context.strokeStyle = strokestyle;\n        }\n\n\n\n        //\n        // Set the horizontal alignment\n        //\n        if (halign == 'center') {\n            context.textAlign = 'center';\n            var boundingX = x - 2 - (width / 2);\n        } else if (halign == 'right') {\n            context.textAlign = 'right';\n            var boundingX = x - 2 - width;\n        } else {\n            context.textAlign = 'left';\n            var boundingX = x - 2;\n        }\n\n\n        //\n        // Set the vertical alignment\n        //\n        if (valign == 'center') {\n\n            context.textBaseline = 'middle';\n            // Move the text slightly\n            y -= 1;\n            \n            y -= ((numlines - 1) / 2) * size_pixels;\n            var boundingY = y - (size_pixels / 2) - 2;\n        \n        } else if (valign == 'top') {\n            context.textBaseline = 'top';\n\n            var boundingY = y - 2;\n        \n        } else if (valign == 'alphabetic') {\n            context.textBaseline = 'alphabetic';\n\n            var boundingY = y - size_pixels + 5;\n\n        } else {\n\n            context.textBaseline = 'bottom';\n\n            // Move the Y coord if multiline text\n            if (numlines > 1) {\n                y -= ((numlines - 1) * size_pixels);\n            }\n\n            var boundingY = y - size_pixels - 2;\n        }\n        \n        var boundingW = width + 4;\n        var boundingH = height + 4;\n\n\n\n        //\n        // Draw a bounding box if required\n        //\n        if (bounding) {\n\n            var pre_bounding_linewidth     = context.lineWidth,\n                pre_bounding_strokestyle   = context.strokeStyle,\n                pre_bounding_fillstyle     = context.fillStyle,\n                pre_bounding_shadowcolor   = context.shadowColor,\n                pre_bounding_shadowblur    = context.shadowBlur,\n                pre_bounding_shadowoffsetx = context.shadowOffsetX,\n                pre_bounding_shadowoffsety = context.shadowOffsetY;\n\n            context.lineWidth   = bounding_linewidth ? bounding_linewidth : 0.001;\n            context.strokeStyle = bounding_stroke;\n            context.fillStyle   = bounding_fill;\n\n            if (bounding_shadow) {\n                context.shadowColor   = bounding_shadow_color;\n                context.shadowBlur    = bounding_shadow_blur;\n                context.shadowOffsetX = bounding_shadow_offsetx;\n                context.shadowOffsetY = bounding_shadow_offsety;\n            }\n\n            //obj.context.strokeRect(boundingX, boundingY, width + 6, (size_pixels * numlines) + 4);\n            //obj.context.fillRect(boundingX, boundingY, width + 6, (size_pixels * numlines) + 4);\n            context.fillRect(\n                boundingX,\n                boundingY,\n                boundingW,\n                boundingH\n            );\n            \n            context.strokeRect(\n                boundingX,\n                boundingY,\n                boundingW,\n                boundingH\n            );\n\n            // Reset the linewidth,colors and shadow to it's original setting\n            context.lineWidth     = pre_bounding_linewidth;\n            context.strokeStyle   = pre_bounding_strokestyle;\n            context.fillStyle     = pre_bounding_fillstyle;\n            context.shadowColor   = pre_bounding_shadowcolor\n            context.shadowBlur    = pre_bounding_shadowblur\n            context.shadowOffsetX = pre_bounding_shadowoffsetx\n            context.shadowOffsetY = pre_bounding_shadowoffsety\n        }\n\n        \n        \n        //\n        // Draw the text\n        //\n        if (numlines > 1) {\n            for (var i=0; i<numlines; ++i) {\n                context.fillText(text_multiline[i], x, y + (size_pixels * i));\n            }\n        } else {\n            context.fillText(text, x + 0.5, y + 0.5);\n        }\n        \n        \n        \n        //\n        // If the text is at 90 degrees restore() the canvas - getting rid of the rotation\n        // and the translate that we did\n        //\n        if (angle != 0) {\n            if (angle == 90) {\n                if (halign == 'left') {\n                    if (valign == 'bottom') {boundingX = originalX - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}\n                    if (valign == 'center') {boundingX = originalX - (height / 2) - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}\n                    if (valign == 'top')    {boundingX = originalX - height - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}\n                \n                } else if (halign == 'center') {\n                    if (valign == 'bottom') {boundingX = originalX - 2; boundingY = originalY - (width / 2) - 2; boundingW = height + 4; boundingH = width + 4;}\n                    if (valign == 'center') {boundingX = originalX - (height / 2) -  2; boundingY = originalY - (width / 2) - 2; boundingW = height + 4; boundingH = width + 4;}\n                    if (valign == 'top')    {boundingX = originalX - height -  2; boundingY = originalY - (width / 2) - 2; boundingW = height + 4; boundingH = width + 4;}\n                \n                } else if (halign == 'right') {\n                    if (valign == 'bottom') {boundingX = originalX - 2; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}\n                    if (valign == 'center') {boundingX = originalX - (height / 2) - 2; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}\n                    if (valign == 'top')    {boundingX = originalX - height - 2; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}\n                }\n\n            } else if (angle == 180) {\n\n                if (halign == 'left') {\n                    if (valign == 'bottom') {boundingX = originalX - width - 2; boundingY = originalY - 2; boundingW = width + 4; boundingH = height + 4;}\n                    if (valign == 'center') {boundingX = originalX - width - 2; boundingY = originalY - (height / 2) - 2; boundingW = width + 4; boundingH = height + 4;}\n                    if (valign == 'top')    {boundingX = originalX - width - 2; boundingY = originalY - height - 2; boundingW = width + 4; boundingH = height + 4;}\n                \n                } else if (halign == 'center') {\n                    if (valign == 'bottom') {boundingX = originalX - (width / 2) - 2; boundingY = originalY - 2; boundingW = width + 4; boundingH = height + 4;}\n                    if (valign == 'center') {boundingX = originalX - (width / 2) - 2; boundingY = originalY - (height / 2) - 2; boundingW = width + 4; boundingH = height + 4;}\n                    if (valign == 'top')    {boundingX = originalX - (width / 2) - 2; boundingY = originalY - height - 2; boundingW = width + 4; boundingH = height + 4;}\n                \n                } else if (halign == 'right') {\n                    if (valign == 'bottom') {boundingX = originalX - 2; boundingY = originalY - 2; boundingW = width + 4; boundingH = height + 4;}\n                    if (valign == 'center') {boundingX = originalX - 2; boundingY = originalY - (height / 2) - 2; boundingW = width + 4; boundingH = height + 4;}\n                    if (valign == 'top')    {boundingX = originalX - 2; boundingY = originalY - height - 2; boundingW = width + 4; boundingH = height + 4;}\n                }\n            \n            } else if (angle == 270) {\n\n                if (halign == 'left') {\n                    if (valign == 'bottom') {boundingX = originalX - height - 2; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}\n                    if (valign == 'center') {boundingX = originalX - (height / 2) - 4; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}\n                    if (valign == 'top')    {boundingX = originalX - 2; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}\n                \n                } else if (halign == 'center') {\n                    if (valign == 'bottom') {boundingX = originalX - height - 2; boundingY = originalY - (width/2) - 2; boundingW = height + 4; boundingH = width + 4;}\n                    if (valign == 'center') {boundingX = originalX - (height/2) - 4; boundingY = originalY - (width/2) - 2; boundingW = height + 4; boundingH = width + 4;}\n                    if (valign == 'top')    {boundingX = originalX - 2; boundingY = originalY - (width/2) - 2; boundingW = height + 4; boundingH = width + 4;}\n                \n                } else if (halign == 'right') {\n                    if (valign == 'bottom') {boundingX = originalX - height - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}\n                    if (valign == 'center') {boundingX = originalX - (height/2) - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}\n                    if (valign == 'top')    {boundingX = originalX - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}\n                }\n            }\n\n            context.restore();\n        }\n\n\n\n\n        //\n        // Reset the text alignment so that text rendered after this text function is not affected\n        //\n        context.textBaseline = 'alphabetic';\n        context.textAlign    = 'left';\n\n\n\n\n\n        //\n        // Fill the ret variable with details of the text\n        //\n        ret.x      = boundingX;\n        ret.y      = boundingY;\n        ret.width  = boundingW;\n        ret.height = boundingH\n        ret.object = obj;\n        ret.text   = text;\n        ret.tag    = tag;\n\n\n\n        //\n        // Save and then return the details of the text (but oly\n        // if it's an RGraph object that was given)\n        //\n        if (obj && obj.isrgraph && obj.coordsText) {\n            obj.coordsText.push(ret);\n        }\n        \n        //\n        // Restore the original fillstyle\n        //\n        if (typeof orig_fillstyle === 'string') {\n            context.fillStyle = orig_fillstyle;\n        }\n\n        return ret;\n    };\n    \n    // Create the DEFAULTS object\n    RGraph.text.defaults = {};\n\n\n\n\n\n\n\n\n    //\n    //\n    // Adds custom text to the chart based on whats\n    // in the objects text: property.\n    //\n    //@param object obj The chart object\n    //\n    RGraph.addCustomText = function (obj)\n    {\n        if (RGraph.isArray(obj.properties.text) && obj.properties.text.length) {\n            for (var i=0; i<obj.properties.text.length; ++i) {\n                var conf = obj.properties.text[i];\n                \n                // Add the object to the config\n                conf.object = obj;\n                \n                // Set the color to black if it's not set\n                if (typeof conf.color !== 'string' || !conf.color.length) {\n                    conf.color = 'black';\n                }\n                \n                RGraph.text(conf);\n            }\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // Takes a sequential index abd returns the group/index variation of it. Eg if you have a\n    // sequential index from a grouped bar chart this function can be used to convert that into\n    // an appropriate group/index combination\n    // \n    // @param  args object An object consisting of:\n    //                      o index\n    //                      o data\n    // OR\n    //\n    // @param index number The sequential index\n    // @param data  array  The original data (which is grouped)\n    // @return             The group/index information\n    //\n    RGraph.sequentialIndexToGrouped = function ()\n    {\n        var args          = RGraph.getArgs(arguments, 'index,data');\n        var group         = 0;\n        var grouped_index = 0;\n\n        while (--args.index >= 0) {\n\n            if (RGraph.isNull(args.data[group])) {\n                group++;\n                grouped_index = 0;\n                continue;\n            }\n\n            // Allow for numbers as well as arrays in the dataset\n            if (typeof args.data[group] == 'number') {\n                group++\n                grouped_index = 0;\n                continue;\n            }\n            \n\n            grouped_index++;\n            \n            if (grouped_index >= args.data[group].length) {\n                group++;\n                grouped_index = 0;\n            }\n        }\n        \n        return [group, grouped_index];\n    };\n\n\n\n\n\n\n\n\n    //\n    // This is the reverse of the above function - converting\n    // group/index to a sequential index\n    //\n    // @return number The sequential index\n    //\n    RGraph.groupedIndexToSequential = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'object,dataset,index');\n\n        for (var i=0,seq=0; i<=args.dataset; ++i) {\n            for (var j=0; j<args.object.data[args.dataset].length; ++j) {\n                \n                if (i === args.dataset && j === args.index) {\n                    return seq;\n                }\n                seq++;\n            }\n        }\n        \n        return seq;\n    };\n\n\n\n\n\n\n\n\n    //\n    // This function highlights a rectangle\n    // \n    // @param  args object An object consisting of:\n    //                      o object\n    //                      o shape\n    // OR\n    //\n    // @param object obj    The chart object\n    // @param number shape  The coordinates of the rect to highlight\n    //\n    RGraph.Highlight.rect = function ()\n    {\n        var args       = RGraph.getArgs(arguments, 'object,shape'),\n            properties = args.object.properties;\n\n        if (properties.tooltipsHighlight) {\n            \n        \n            // Safari seems to need this\n            args.object.context.lineWidth = 1;\n\n\n            //\n            // Draw a rectangle on the canvas to highlight the appropriate area\n            //\n            args.object.context.beginPath();\n\n                args.object.context.strokeStyle = properties.highlightStroke;\n                args.object.context.fillStyle   = properties.highlightFill;\n\n                args.object.context.rect(\n                    args.shape.x - 0.5,\n                    args.shape.y - 0.5,\n                    args.shape.width + 1,\n                    args.shape.height + 1\n                );\n                //obj.context.fillRect(shape.x,shape.y,shape.width,shape.height);\n            args.object.context.stroke();\n            args.object.context.fill();\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // This function highlights a point\n    // \n    // @param  args object An object consisting of:\n    //                      o object\n    //                      o shape\n    // OR\n    //\n    // @param object obj    The chart object\n    // @param number shape  The coordinates of the rect to highlight\n    //\n    RGraph.Highlight.point = function ()\n    {\n        var args        = RGraph.getArgs(arguments, 'object,shape');\n        var properties  = args.object.properties;\n\n        if (properties.tooltipsHighlight) {\n    \n            //\n            // Draw a rectangle on the canvas to highlight the appropriate area\n            //\n            args.object.context.beginPath();\n                args.object.context.strokeStyle = properties.highlightStroke;\n                args.object.context.fillStyle   = properties.highlightFill;\n\n                var radius = properties.highlightPointRadius || 2;\n\n                args.object.context.arc(\n                    args.shape.x,\n                    args.shape.y,\n                    radius,\n                    0,\n                    RGraph.TWOPI,\n                    0\n                );\n            args.object.context.stroke();\n            args.object.context.fill();\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // A better, more flexible, date parsing function that\n    // was taken from the SVG libraries.\n    //\n    // @param  args object An object consisting of:\n    //                      o str\n    // OR\n    //\n    // @param  string str The string to parse\n    // @return number     A number, as returned by Date.parse()\n    //\n    RGraph.parseDate = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'str');\n\n        // First off - remove the T from the format: YYYY-MM-DDTHH:MM:SS\n        if (args.str.match(/^\\d\\d\\d\\d-\\d\\d-\\d\\d(t|T)\\d\\d:\\d\\d(:\\d\\d)?$/)) {\n            args.str = args.str.toUpperCase().replace(/T/, ' ');\n        }\n\n\n        var d = new Date();\n\n        // Initialise the default values\n        var defaults = {\n            seconds: '00',\n            minutes: '00',\n              hours: '00',\n               date: d.getDate(),\n              month: d.getMonth() + 1,\n               year: d.getFullYear()\n        };\n\n        // Create the months array for turning textual months back to numbers\n        var months       = ['january','february','march','april','may','june','july','august','september','october','november','december'],\n            months_regex = months.join('|');\n\n        for (var i=0; i<months.length; ++i) {\n            months[months[i]] = i;\n            months[months[i].substring(0,3)] = i;\n            months_regex = months_regex + '|' + months[i].substring(0,3);\n        }\n\n        // These are the separators allowable for d/m/y and y/m/d dates\n        // (Its part of a regexp so the position of the square brackets\n        //  is crucial)\n        var sep = '[-./_=+~#:;,]+';\n\n\n        // Tokenise the string\n        var tokens = args.str.split(/ +/);\n\n        // Loop through each token checking what it is\n        for (var i=0,len=tokens.length; i<len; ++i) {\n            if (tokens[i]) {\n                \n                // Year\n                if (tokens[i].match(/^\\d\\d\\d\\d$/)) {\n                    defaults.year = tokens[i];\n                }\n\n                // Month\n                var res = isMonth(tokens[i]);\n                if (typeof res === 'number') {\n                    defaults.month = res + 1; // Months are zero indexed\n                }\n\n                // Date\n                if (tokens[i].match(/^\\d?\\d(?:st|nd|rd|th)?$/)) {\n                    defaults.date = parseInt(tokens[i]);\n                }\n\n                // Time\n                if (tokens[i].match(/^(\\d\\d):(\\d\\d):?(?:(\\d\\d))?$/)) {\n                    defaults.hours   = parseInt(RegExp.$1);\n                    defaults.minutes = parseInt(RegExp.$2);\n                    \n                    if (RegExp.$3) {\n                        defaults.seconds = parseInt(RegExp.$3);\n                    }\n                }\n\n                // Dateformat: XXXX-XX-XX\n                if (tokens[i].match(new RegExp('^(\\\\d\\\\d\\\\d\\\\d)' + sep + '(\\\\d\\\\d)' + sep + '(\\\\d\\\\d)$', 'i'))) {\n                    defaults.date  = parseInt(RegExp.$3);\n                    defaults.month = parseInt(RegExp.$2);\n                    defaults.year  = parseInt(RegExp.$1);\n\n                }\n\n                // Dateformat: XX-XX-XXXX\n                if (tokens[i].match(new RegExp('^(\\\\d\\\\d)' + sep + '(\\\\d\\\\d)' + sep + '(\\\\d\\\\d\\\\d\\\\d)$','i') )) {\n                    defaults.date  = parseInt(RegExp.$1);\n                    defaults.month = parseInt(RegExp.$2);\n                    defaults.year  = parseInt(RegExp.$3);\n                }\n            }\n        }\n\n        // Now put the defaults into a format thats recognised by Date.parse()\n        args.str = '{1}/{2}/{3} {4}:{5}:{6}'.format(\n            defaults.year,\n            String(defaults.month).length     === 1 ? '0' + (defaults.month) : defaults.month,\n            String(defaults.date).length      === 1 ? '0' + (defaults.date)      : defaults.date,\n            String(defaults.hours).length     === 1 ? '0' + (defaults.hours)     : defaults.hours,\n            String(defaults.minutes).length   === 1 ? '0' + (defaults.minutes)   : defaults.minutes,\n            String(defaults.seconds).length   === 1 ? '0' + (defaults.seconds)   : defaults.seconds\n        );\n\n        return Date.parse(args.str);\n\n        //\n        // Support functions\n        //\n        function isMonth(str)\n        {\n            var res = str.toLowerCase().match(months_regex);\n\n            return res ? months[res[0]] : false;\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // This is the same as Date.parse - though a little more flexible.\n    // \n    // @param  args object An object consisting of:\n    //                      o str\n    // OR\n    //\n    // @param string str The date string to parse\n    // @return Returns the same thing as Date.parse\n    //\n    RGraph.parseDateOld = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'str');\n\n        args.str = RGraph.trim(args.str);\n\n        // Allow for: now (just the word \"now\")\n        if (args.str === 'now') {\n            args.str = (new Date()).toString();\n        }\n\n\n        // Allow for: 22-11-2013\n        // Allow for: 22/11/2013\n        // Allow for: 22-11-2013 12:09:09\n        // Allow for: 22/11/2013 12:09:09\n        if (args.str.match(/^(\\d\\d)(?:-|\\/)(\\d\\d)(?:-|\\/)(\\d\\d\\d\\d)(.*)$/)) {\n            args.str = '{1}/{2}/{3}{4}'.format(\n                RegExp.$3,\n                RegExp.$2,\n                RegExp.$1,\n                RegExp.$4\n            );\n        }\n\n        // Allow for: 2013-11-22 12:12:12 or  2013/11/22 12:12:12\n        if (args.str.match(/^(\\d\\d\\d\\d)(-|\\/)(\\d\\d)(-|\\/)(\\d\\d)( |T)(\\d\\d):(\\d\\d):(\\d\\d)$/)) {\n            args.str = RegExp.$1 + '-' + RegExp.$3 + '-' + RegExp.$5 + 'T' + RegExp.$7 + ':' + RegExp.$8 + ':' + RegExp.$9;\n        }\n\n        // Allow for: 2013-11-22\n        if (args.str.match(/^\\d\\d\\d\\d-\\d\\d-\\d\\d$/)) {\n            args.str = args.str.replace(/-/g, '/');\n        }\n\n\n        // Allow for: 12:09:44 (time only using todays date)\n        if (args.str.match(/^\\d\\d:\\d\\d:\\d\\d$/)) {\n        \n            var dateObj  = new Date();\n            var date     = dateObj.getDate();\n            var month    = dateObj.getMonth() + 1;\n            var year     = dateObj.getFullYear();\n            \n            // Pad the date/month with a zero if it's not two characters\n            if (String(month).length === 1) month = '0' + month;\n            if (String(date).length === 1) date = '0' + date;\n\n            args.str = (year + '/' + month + '/' + date) + ' ' + args.str;\n        }\n\n        return Date.parse(args.str);\n    };\n\n\n\n\n\n\n\n\n    //\n    // Reset all of the color values to their original values\n    // \n    // @param  args object An object consisting of:\n    //                      o object\n    // OR\n    //\n    // @param object The chart object\n    //\n    RGraph.resetColorsToOriginalValues = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'object');\n\n        if (args.object.original_colors) {\n            // Reset the colors to their original values\n            for (var j in args.object.original_colors) {\n                if (typeof j === 'string') {// TAKEN OUT 1st AUGUST && j.substr(0,6) === 'chart.'\n                    args.object.properties[j] = RGraph.arrayClone(args.object.original_colors[j]);\n                }\n            }\n        }\n\n\n\n        //\n        // If the function is present on the object to reset specific colors - use that\n        //\n        if (typeof args.object.resetColorsToOriginalValues === 'function') {\n            args.object.resetColorsToOriginalValues();\n        }\n\n        // Reset the colorsParsed flag so that they're parsed for gradients again\n        args.object.colorsParsed = false;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Creates a Linear gradient\n    // \n    // @param object object An object that can contain these properties\n    //                       o object  The RGraph object\n    //                       o x1      The starting X coordinate\n    //                       o y1      The starting Y coordinate\n    //                       o x2      The ending X coordinate\n    //                       o y2      The ending Y coordinate\n    //                       o colors  An array of colors for the gradient\n    RGraph.linearGradient = function ()\n    {\n        var args = arguments[0];\n\n        var gradient = args.object.context.createLinearGradient(\n            args.x1,\n            args.y1,\n            args.x2,\n            args.y2\n        );\n        var numColors = args.colors.length;\n\n        for (var i=0; i<args.colors.length; ++i) {\n            \n            var color = args.colors[i];\n            var stop = i / (numColors - 1);\n\n            gradient.addColorStop(stop, color);\n        }\n\n        return gradient;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Creates a Radial gradient\n    // \n    // @param object object An object that can contain these properties\n    //                       o object  The RGraph object\n    //                       o x1      The start X coordinate\n    //                       o y1      The start Y coordinate\n    //                       o r1      The start radius\n    //                       o x2      The end X coordinate\n    //                       o y2      The end Y coordinate\n    //                       o r2      The end radius\n    //                       o colors  An array of colors for the gradient\n    RGraph.radialGradient = function()\n    {\n        var args = arguments[0];\n\n        var gradient  = args.object.context.createRadialGradient(\n            args.x1,\n            args.y1,\n            args.r1,\n            args.x2,\n            args.y2,\n            args.r2\n        );\n\n        var numColors = args.colors.length;\n        \n        for(var i=0; i<args.colors.length; ++i) {\n            gradient.addColorStop(\n                i / (numColors-1),\n                args.colors[i]\n            );\n        }\n        \n        return gradient;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Adds an event listener to RGraphs internal array so that RGraph can track them.\n    // This DOESN'T add the event listener to the canvas/window.\n    // \n    // 05/01/2014 TODO Used in the tooltips file, but is it necessary any more?\n    // 15/10/2019 Commented out\n    //\n    //RGraph.addEventListener =\n    //RGraph.AddEventListener = function (id, e, func)\n    //{\n    //    var type = arguments[3] ? arguments[3] : 'unknown';\n    //    \n    //    RGraph.Registry.get('event.handlers').push([id,e,func,type]);\n    //};\n\n\n\n\n\n\n\n\n    //\n    // Clears event listeners that have been installed by RGraph\n    // \n    // @param  args object An object consisting of:\n    //                      o id\n    // OR\n    //\n    // @param string id The ID of the canvas to clear event listeners for - or 'window' to clear\n    //                  the event listeners attached to the window\n    //\n    RGraph.clearEventListeners = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'id');\n\n        if (args.id && args.id === 'window') {\n\n            window.removeEventListener('mousedown', RGraph.window_mousedown_event_listener, false);\n            window.removeEventListener('mouseup', RGraph.window_mouseup_event_listener, false);\n\n        } else {\n            \n            var canvas = document.getElementById(args.id);\n\n            canvas.removeEventListener('mouseup', canvas.rgraph_mouseup_event_listener, false);\n            canvas.removeEventListener('mousemove', canvas.rgraph_mousemove_event_listener, false);\n            canvas.removeEventListener('mousedown', canvas.rgraph_mousedown_event_listener, false);\n            canvas.removeEventListener('click', canvas.rgraph_click_event_listener, false);\n        }\n    };\n\n\n\n\n\n\n\n    //\n    // Hides the annotating palette. It's here because it can be called\n    // from code other than the annotating code.\n    //\n    // No arguments\n    //\n    RGraph.hidePalette = function ()\n    {\n        var div = RGraph.Registry.get('palette');\n        \n        if(typeof div == 'object' && div) {\n            \n            div.style.visibility = 'hidden';\n            div.style.display = 'none';\n            \n            RGraph.Registry.set('palette', null);\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // Generates a random number between the minimum and maximum\n    // \n    // @param  args object An object consisting of:\n    //                      o min\n    //                      o max\n    //                      o decimals\n    // OR\n    //\n    // @param number min The minimum value\n    // @param number max The maximum value\n    // @param number     OPTIONAL Number of decimal places\n    //\n    RGraph.random = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'min,max,decimals');\n\n        var dp = args.decimals ? args.decimals : 0;\n        var r  = Math.random();\n        \n        return Number((((args.max - args.min) * r) + args.min).toFixed(dp));\n    };\n\n\n\n\n\n\n\n\n    //\n    // Returns an array of random values\n    //\n    // @param  args object An object consisting of:\n    //                      o count\n    //                      o min\n    //                      o max\n    //                      o decimals\n    // OR\n    //\n    //\n    RGraph.arrayRandom = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'count,min,max,decimals');\n\n        for(var i=0,arr=[]; i<args.count; i+=1) {\n            arr.push(\n                RGraph.random(\n                    args.min,\n                    args.max,\n                    args.decimals\n                )\n            );\n        }\n        \n        return arr;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Turns off shadow by setting blur to zero, the offsets to zero and the color to transparent black.\n    // \n    // @param  args object An object consisting of:\n    //                      o object\n    // OR\n    //\n    // @param object obj The chart object\n    //\n    RGraph.noShadow = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'object');\n\n        args.object.context.shadowColor   = 'rgba(0,0,0,0)';\n        args.object.context.shadowBlur    = 0;\n        args.object.context.shadowOffsetx = 0;\n        args.object.context.shadowOffsety = 0;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Sets the various shadow properties\n    // \n    // @param  args object An object consisting of:\n    //                      o object\n    //                      o prefix\n    // OR\n    // \n    // @param object obj     The chart object (only supplying the RGraph chart\n    //                       object turns the shadow off)\n    // OR\n    //\n    // @param object obj     The chart object\n    // @param string color   The color of the shadow\n    // @param number offsetx The offsetX value for the shadow\n    // @param number offsety The offsetY value for the shadow\n    // @param number blur    The blurring value for the shadow\n    //\n    RGraph.setShadow = function ()\n    {\n        // 1 Argument\n        if (   typeof arguments[0] === 'object'\n            && typeof arguments[0].object === 'object'\n            && typeof arguments[0].object.isrgraph\n            && typeof arguments[0].prefix === 'string'\n           ) {\n           \n           var args = arguments[0];\n\n            args.object.context.shadowColor   = args.object.properties[args.prefix + 'Color'];\n            args.object.context.shadowOffsetX = args.object.properties[args.prefix + 'Offsetx'];\n            args.object.context.shadowOffsetY = args.object.properties[args.prefix + 'Offsety'];\n            args.object.context.shadowBlur    = args.object.properties[args.prefix + 'Blur'];\n\n        // Turn Off the shadow\n        } else if (   arguments.length === 1\n                   && typeof arguments[0] === 'object'\n                   && typeof arguments[0].isrgraph) {\n            \n            var obj = arguments[0];\n\n            obj.context.shadowColor   = 'rgba(0,0,0,0)';\n            obj.context.shadowOffsetX = 0;\n            obj.context.shadowOffsetY = 0;\n            obj.context.shadowBlur    = 0;\n\n        // Separate arguments\n        } else {\n\n            var obj = arguments[0];\n    \n            obj.context.shadowColor   = arguments[1];\n            obj.context.shadowOffsetX = arguments[2];\n            obj.context.shadowOffsetY = arguments[3];\n            obj.context.shadowBlur    = arguments[4];\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // Sets an object in the RGraph registry\n    // \n    // @param  args object An object consisting of:\n    //                      o name\n    //                      o value\n    // OR\n    //\n    // @param string name The name of the value to set\n    //\n    RGraph.Registry.set = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'name,value');\n\n        // Convert uppercase letters to dot+lower case letter\n        args.name = args.name.replace(/([A-Z])/g, function (str)\n        {\n            return '.' + String(RegExp.$1).toLowerCase();\n        });\n\n        RGraph.Registry.store[args.name] = args.value;\n        \n        return args.value;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Gets an object from the RGraph registry\n    // \n    // @param  args object An object consisting of:\n    //                      o name\n    // OR\n    //\n    // @param string name The name of the value to fetch\n    //\n    RGraph.Registry.get = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'name');\n\n        // Convert uppercase letters to dot+lower case letter\n        args.name = args.name.replace(/([A-Z])/g, function (str)\n        {\n            return '.' + String(RegExp.$1).toLowerCase();\n        });\n\n\n        return RGraph.Registry.store[args.name];\n    };\n\n\n\n\n\n\n\n\n    //\n    // Converts the given number of degrees to radians. Angles in canvas are\n    // measured in radians. There are a .toDegrees() function and a toRadians()\n    // function too.\n    // \n    // @param  args object An object consisting of:\n    //                      o degrees\n    // OR\n    //\n    // @param number degrees The value to convert\n    //\n    RGraph.toRadians = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'degrees');\n\n        return args.degrees * (RGraph.PI / 180);\n    };\n\n    // Usage: RGraph.toDegrees(3.14) // 180ish\n    //\n    // @param  args object An object consisting of:\n    //                      o radians\n    // OR\n    //\n    // @param number radians The angle in radians to convert to degrees\n    //\n    RGraph.toDegrees = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'radians');\n\n        return args.radians * (180 / Math.PI);\n    };\n\n\n\n\n\n\n\n\n    //\n    // Generates logs for... log charts\n    // \n    // @param  args object An object consisting of:\n    //                      o number\n    //                      o base\n    // OR\n    //\n    // @param number n    The number to generate the log for\n    // @param number base The base to use\n    //\n    RGraph.log = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'number,base');\n\n        return Math.log(args.number) / (args.base ? Math.log(args.base) : 1);\n    };\n\n\n\n\n\n\n\n\n    //\n    // Determines if the given object is an array or not\n    // \n    // @param  args object An object consisting of:\n    //                      o object\n    // OR\n    //\n    // @param mixed obj The variable to test\n    //\n    RGraph.isArray = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'object');\n\n        if (args.object && args.object.constructor) {\n            var pos = args.object.constructor.toString().indexOf('Array');\n        } else {\n            return false;\n        }\n\n        return args.object != null &&\n               typeof pos === 'number' &&\n               pos > 0 &&\n               pos < 20;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Removes white-space from the start aqnd end of a string\n    // \n    // @param  args object An object consisting of:\n    //                      o str\n    // OR\n    //\n    // @param string str The string to trim\n    //\n    RGraph.trim = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'str');\n\n        return RGraph.ltrim(RGraph.rtrim(args.str));\n    };\n\n\n\n\n\n\n\n\n    //\n    // Trims the white-space from the start of a string\n    // \n    // @param  args object An object consisting of:\n    //                      o str\n    // OR\n    //\n    // @param string str The string to trim\n    //\n    RGraph.ltrim = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'str');\n\n        return args.str.replace(/^(\\s|\\0)+/, '');\n    };\n\n\n\n\n\n\n\n\n    //\n    // Trims the white-space off of the end of a string\n    // \n    // @param  args object An object consisting of:\n    //                      o str\n    // OR\n    //\n    // @param string str The string to trim\n    //\n    RGraph.rtrim = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'str');\n\n        return args.str.replace(/(\\s|\\0)+$/, '');\n    };\n\n\n\n\n\n\n\n\n    //\n    // Returns true/false as to whether the given variable is null or not\n    // \n    // @param  args object An object consisting of:\n    //                      o arg\n    // OR\n    //\n    // @param mixed arg The argument to check\n    //\n    RGraph.isNull = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'arg');\n\n        if (typeof args.arg === 'object' && !args.arg) {\n            return true;\n        }\n    \n        return false;\n    };\n\n\n\n\n\n\n\n\n    //\n    // This function facilitates a very limited way of making your charts\n    // whilst letting the rest of page continue - using  the setTimeout function\n    // \n    // @param  args object An object consisting of:\n    //                      o func\n    //                      o delay\n    // OR\n    //\n    // @param function func The function to run that creates the chart\n    //\n    RGraph.async = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'func,delay');\n\n        return setTimeout(args.func, args.delay ? args.delay : 1);\n    };\n\n\n\n\n\n\n\n\n    //\n    // Resets (more than just clears) the canvas and clears any pertinent objects\n    // from the ObjectRegistry\n    // \n    // @param  args object An object consisting of:\n    //                      o canvas\n    // OR\n    //\n    // @param object canvas The canvas object (as returned by document.getElementById() ).\n    //\n    RGraph.reset = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'canvas');\n\n        // If a string has been given then treat it as the ID of the canvas\n        if (typeof args.canvas === 'string') {\n            args.canvas = document.getElementById(args.canvas);\n        }\n\n        args.canvas.width = args.canvas.width;\n        \n        RGraph.ObjectRegistry.clear(args.canvas);\n        \n        args.canvas.__rgraph_aa_translated__ = false;\n\n        if (RGraph.text.domNodeCache && RGraph.text.domNodeCache.reset) {\n            RGraph.text.domNodeCache.reset(args.canvas);\n        }\n\n        // Create the node and dimension caches if they don't already exist\n        if (!RGraph.text.domNodeCache)          { RGraph.text.domNodeCache          = []; }\n        if (!RGraph.text.domNodeDimensionCache) { RGraph.text.domNodeDimensionCache = []; }\n\n        // Create/reset the specific canvas arrays in the caches\n        RGraph.text.domNodeCache[args.canvas.id]          = [];\n        RGraph.text.domNodeDimensionCache[args.canvas.id] = [];\n    };\n\n\n\n\n\n\n\n\n    //\n    // This function is due to be removed.\n    //\n    // 19/10/2019 Commented out\n    // \n    // @param string id The ID of what can be either the canvas tag or a DIV tag\n    //\n    //RGraph.getCanvasTag = function ()\n    //{\n    //    var args = RGraph.getArgs(arguments, 'id');\n    //\n    //    var id = typeof args.id === 'object' ? args.id.id : args.id;\n    //    \n    //    var canvas = document.getElementById(id);\n    //\n    //    return [id, canvas];\n    //};\n\n\n\n\n\n\n\n\n    //\n    // A wrapper function that encapsulate requestAnimationFrame\n    // \n    // @param  args object An object consisting of:\n    //                      o func\n    // OR\n    //\n    // @param function func The animation function\n    //\n    RGraph.Effects.updateCanvas = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'func');\n\n        window.requestAnimationFrame =    \n                window.requestAnimationFrame\n            || window.webkitRequestAnimationFrame\n            || window.msRequestAnimationFrame\n            || window.mozRequestAnimationFrame\n            || (function (func){setTimeout(func, 16.666);});\n        \n        window.requestAnimationFrame(args.func);\n    };\n\n\n\n\n\n\n\n\n    //\n    // This function returns an easing multiplier for effects so they eas out towards the\n    // end of the effect.\n    // \n    // @param  args object An object consisting of:\n    //                      o frames\n    //                      o frame\n    // OR\n    //\n    // @param number frames The total number of frames\n    // @param number frame  The frame number\n    //\n    RGraph.Effects.getEasingMultiplier = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'frames,frame');\n\n        return Math.pow(Math.sin((args.frame / args.frames) * RGraph.HALFPI), 3);\n    };\n\n\n\n\n\n\n\n\n    //\n    // This function converts an array of strings to an array of numbers. Its used by the meter/gauge\n    // style charts so that if you want you can pass in a string. It supports various formats:\n    // \n    // '45.2'\n    // '-45.2'\n    // ['45.2']\n    // ['-45.2']\n    // '45.2,45.2,45.2' // A CSV style string\n    // \n    // @param  args object An object consisting of:\n    //                      o string\n    //                      o separator (optional)\n    // OR\n    //\n    // @param number frames    The string or array to parse\n    // @param string separator Optional Use this instead of the default comma\n    //\n    RGraph.stringsToNumbers = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'string,separator');\n\n        // An optional separator to use intead of a comma\n        var sep = args.separator || ',';\n\n\n\n        // Remove preceding square brackets\n        if (typeof args.string === 'string' && args.string.trim().match(/^\\[ *\\d+$/)) {\n            args.string = args.string.replace('[', '');\n        }\n\n\n        // If it's already a number just return it\n        if (typeof args.string === 'number') {\n            return args.string;\n        }\n\n\n\n\n\n        if (typeof args.string === 'string') {\n            if (args.string.indexOf(sep) != -1) {\n                args.string = args.string.split(sep);\n            } else {\n                args.string = parseFloat(args.string);\n\n                if (isNaN(args.string)) {\n                    args.string = null;\n                }\n\n            }\n        }\n\n\n\n\n\n        if (typeof args.string === 'object' && !RGraph.isNull(args.string)) {\n            for (var i=0,len=args.string.length; i<len; i+=1) {\n                args.string[i] = RGraph.stringsToNumbers(\n                    args.string[i],\n                    args.separator\n                );\n            }\n        }\n\n        return args.string;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Drawing cache function. This function creates an off-screen canvas and draws [wwhatever] to it\n    // and then subsequent calls use that  instead of repeatedly drawing the same thing.\n    // \n    // @param  args object An object consisting of:\n    //                      o object\n    //                      o id\n    //                      o function\n    // OR\n    //\n    // @param object   obj  The graph object\n    // @param string   id   An ID string used to identify the relevant entry in the cache\n    // @param function func The drawing function. This will be called to do the draw.\n    //\n    RGraph.cachedDraw = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'object,id,function');\n\n\n\n\n        /////////////////////////////////////////\n        //\n        // This bypasses caching entirely:\n        //\n        // func(obj, obj.canvas, obj.context);\n        // return;\n        //\n        /////////////////////////////////////////\n\n\n\n\n\n        //If the cache entry exists - just copy it across to the main canvas\n        if (!RGraph.cache[args.id]) {\n\n            RGraph.cache[args.id] = {};\n\n            RGraph.cache[args.id].object = args.object;\n            RGraph.cache[args.id].canvas = document.createElement('canvas');\n\n            RGraph.cache[args.id].canvas.setAttribute('width', args.object.canvas.width);\n            RGraph.cache[args.id].canvas.setAttribute('height', args.object.canvas.height);\n            RGraph.cache[args.id].canvas.setAttribute('id', 'background_cached_canvas' + args.object.canvas.id);\n\n            RGraph.cache[args.id].canvas.__object__ = args.object;\n            RGraph.cache[args.id].context = RGraph.cache[args.id].canvas.getContext('2d');\n            \n            // Antialiasing on the cache canvas\n            RGraph.cache[args.id].context.translate(0.5,0.5);\n\n            // Call the function\n            args.function(\n                args.object,\n                RGraph.cache[args.id].canvas,\n                RGraph.cache[args.id].context\n            );\n        }\n\n        // Now copy the contents of the cached canvas over to the main one.\n        // The coordinates are -0.5 because of the anti-aliasing effect in\n        // use on the main canvas\n        args.object.context.drawImage(RGraph.cache[args.id].canvas,-0.5,-0.5);\n    };\n\n\n\n\n\n\n\n\n    //\n    // The function that runs through the supplied configuration and\n    // converts it to the RGraph style.\n    // \n    // @param  args object An object consisting of:\n    //                      o object\n    //                      o config\n    // OR\n    //\n    // @param object conf The config\n    // @param object      The settings for the object\n    //\n    RGraph.parseObjectStyleConfig = function ()\n    {\n        var args = RGraph.getArgs(arguments, 'object,config');\n\n        for (var i in args.config) {\n            if (typeof i === 'string') {\n                args.object.set(i, args.config[i]);\n            }\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // This function is a short-cut for the canvas path syntax (which can be rather\n    // verbose). You can read a description of it (which details all of the\n    // various options) on the RGraph blog (www.rgraph.net/blog). The function is\n    // added to the CanvasRenderingContext2D object so it becomes a context function.\n    // \n    // So you can use it like these examples show:\n    // \n    // 1. RGraph.path(context, 'b r 0 0 50 50 f red');\n    // 2. RGraph.path(context, 'b a 50 50 50 0 3.14 false f red');\n    // 3. RGraph.path(context, 'b m 5 100 bc 5 0 100 0 100 100 s red');\n    // 4. RGraph.path(context, 'b m 5 100 at 50 0 95 100 50 s red');\n    // 5. RGraph.path(context, 'sa b r 0 0 50 50 c b r 5 5 590 240 f red rs');\n    // 6. RGraph.path(context, 'ld [2,6] ldo 4 b r 5 5 590 240 f red');\n    // 7. RGraph.path(context, 'ga 0.25 b r 5 5 590 240 f red');\n    //\n    // You can also call it like this - as a member function of an RGraph object:\n    //\n    // 8 obj.path('b r % % % % f red s black', x, y, width, height);\n    // \n    // \n    // @param  args object An object consisting of:\n    //                      o object\n    //                      o path\n    //                      o args\n    // OR\n    // \n    // @param  args object An object consisting of:\n    //                      o context\n    //                      o path\n    //                      o args\n    // OR\n    //\n    // @param  args object The chart object\n    // @param  args string The path to draw\n    // @param  args array  An array of arguments for the path\n    //\n    // OR\n    //\n    // @param args context The canvas tags context\n    // @param args string  The path to draw\n    // @param args array   An array of arguments to the path\n    //\n    RGraph.path = function (args)\n    {\n        var arguments = Array.prototype.slice.call(arguments);\n\n        // Allow a single arg to be passed as well as multiple\n\n        // Object is passed\n        if (arguments.length === 1 && args.object && args.path) {\n            var context = args.object.context;\n            var p       = args.path;\n            var args    = args.args;\n        \n        // Context is passed\n        } else if (arguments.length === 1 && args.context && args.path) {\n            var context  = args.context;\n            var p        = args.path;\n            var args     = args.args;\n        \n        // Multiple args, object given\n        } else if (arguments.length >= 2 && arguments[0].isrgraph && arguments[0].context) {\n            var context = arguments[0].context;\n            var p       = arguments[1];\n            var args    = arguments.length > 2 ? arguments.slice(2) : [];\n        \n        // Multiple args, context given\n        } else if (arguments.length >= 2 && arguments[0].toString().indexOf('Context')) {\n            var context   = arguments[0];\n            var p         = arguments[1];\n            var args      = arguments.length > 2 ? arguments.slice(2) : [];\n        }\n\n        \n        // If the path was a string - split it then collapse quoted bits together\n        if (typeof p === 'string') {\n            p = splitstring(p);\n        }\n\n        // Store the last path on the RGraph object\n        RGraph.path.last = RGraph.arrayClone(p);\n\n        // Go through the path information.\n        for (var i=0,len=p.length; i<len; i+=1) {\n\n            switch (p[i]) {\n                case 'b':context.beginPath();break;\n                case 'c':context.closePath();break;\n                case 'm':context.moveTo(parseFloat(p[i+1]),parseFloat(p[i+2]));i+=2;break;\n                case 'l':context.lineTo(parseFloat(p[i+1]),parseFloat(p[i+2]));i+=2;break;\n                case 's':if(p[i+1])context.strokeStyle=p[i+1];context.stroke();i++;break;\n                case 'f':if(p[i+1]){context.fillStyle=p[i+1];}context.fill();i++;break;\n                case 'qc':context.quadraticCurveTo(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]));i+=4;break;\n                case 'bc':context.bezierCurveTo(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]),parseFloat(p[i+5]),parseFloat(p[i+6]));i+=6;break;\n                case 'r':context.rect(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]));i+=4;break;\n                case 'a':context.arc(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]),parseFloat(p[i+5]),p[i+6]==='true'||p[i+6]===true||p[i+6]===1||p[i+6]==='1'?true:false);i+=6;break;\n                case 'at':context.arcTo(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]),parseFloat(p[i+5]));i+=5;break;\n                case 'lw':context.lineWidth=parseFloat(p[i+1]);i++;break;\n                case 'e':context.ellipse(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]),parseFloat(p[i+5]),parseFloat(p[i+6]),parseFloat(p[i+7]),p[i+8] === 'true' ? true : false);i+=8;break;\n                case 'lj':context.lineJoin=p[i+1];i++;break;\n                case 'lc':context.lineCap=p[i+1];i++;break;\n                case 'sc':context.shadowColor=p[i+1];i++;break;\n                case 'sb':context.shadowBlur=parseFloat(p[i+1]);i++;break;\n                case 'sx':context.shadowOffsetX=parseFloat(p[i+1]);i++;break;\n                case 'sy':context.shadowOffsetY=parseFloat(p[i+1]);i++;break;\n                case 'fs':context.fillStyle=p[i+1];i++;break;\n                case 'ss':context.strokeStyle=p[i+1];i++;break;\n                case 'fr':context.fillRect(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]));i+=4;break;\n                case 'sr':context.strokeRect(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]));i+=4;break;\n                case 'cl':context.clip();break;\n                case 'sa':context.save();break;\n                case 'rs':context.restore();break;\n                case 'tr':context.translate(parseFloat(p[i+1]),parseFloat(p[i+2]));i+=2;break;\n                case 'sl':context.scale(parseFloat(p[i+1]), parseFloat(p[i+2]));i+=2;break;\n                case 'ro':context.rotate(parseFloat(p[i+1]));i++;break;\n                case 'tf':context.transform(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]),parseFloat(p[i+5]),parseFloat(p[i+6]));i+=6;break;\n                case 'stf':context.setTransform(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]),parseFloat(p[i+5]),parseFloat(p[i+6]));i+=6;break;\n                case 'cr':context.clearRect(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]));i+=4;break;\n                case 'ld':var parts = p[i+1];context.setLineDash(parts);i+=1;break;\n                case 'ldo':context.lineDashOffset=p[i+1];i++;break;\n                case 'fo':context.font=p[i+1];i++;break;\n                case 'ft':context.fillText(p[i+1], parseFloat(p[i+2]), parseFloat(p[i+3]));i+=3;break;\n                case 'st':context.strokeText(p[i+1], parseFloat(p[i+2]), parseFloat(p[i+3]));i+=3;break;\n                case 'ta':context.textAlign=p[i+1];i++;break;\n                case 'tbl':context.textBaseline=p[i+1];i++;break;\n                case 'ga':context.globalAlpha=parseFloat(p[i+1]);i++;break;\n                case 'gco':context.globalCompositeOperation=p[i+1];i++;break;\n                case 'fu':(p[i+1])(context.canvas.__object__);i++;break;\n                \n                // Empty option - ignore it\n                case '':break;\n                \n                // Unknown option\n                default: alert('[ERROR] Unknown option: ' + p[i]);\n            }\n        }\n        \n        function splitstring (p)\n        {\n            var ret = [], buffer = '', inquote = false, quote = '', substitutionIndex = 0;\n\n            // p ia string - not an array\n            for (var i=0; i<p.length; i+=1) {\n                \n                var chr = p[i],\n                    isWS = chr.match(/ /);\n\n                if (isWS) {\n                    if (!inquote) {\n\n                        // Get rid of any enclosing quotes\n                        if (buffer[0] === '\"' || buffer[0] === \"'\") {\n                            buffer = buffer.substr(1, buffer.length - 2);\n                        }\n\n\n                        // String substitution\n                        if (buffer.trim() === '%' && typeof args[substitutionIndex] !== 'undefined') {\n                            buffer = args[substitutionIndex++];\n                        }\n\n                        ret.push(buffer);\n                        buffer = '';\n                    } else {\n                        buffer += chr;\n                    }\n                } else {\n                    if (chr === \"'\" || chr === '\"') {\n                        inquote = !inquote;\n                    }\n\n                    buffer += chr;\n                }\n            }\n\n            // Do the last bit (including substitution)\n            if (buffer.trim() === '%' && args[substitutionIndex]) {\n                buffer = args[substitutionIndex++];\n            }\n\n            ret.push(buffer);\n\n            return ret;\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // This function gets the text properties when given a relevant prefix.\n    // So if you give it 'text' as the prefix you'll get the:\n    //\n    //  o textFont\n    //  o textSize\n    //  o textColor\n    //  o textBold\n    //  o textItalic\n    //\n    // ...properties. On the other hand if you give it 'yaxisScaleLabels'\n    // as the prefix you'll get:\n    //\n    //  o yaxisScaleLabelsFont\n    //  o yaxisScaleLabelsSize\n    //  o yaxisScaleLabelsColor\n    //  o yaxisScaleLabelsBold\n    //  o yaxisScaleLabelsItalic\n    // \n    // @param  args object An object consisting of:\n    //                      o object\n    //                      o prefix\n    //\n    RGraph.getTextConf = function (args)\n    {\n        var obj        = args.object,\n            properties = obj.properties,\n            prefix     = args.prefix;\n\n        // Has to be a seperate var statement\n        var font   = typeof properties[prefix + 'Font']   === 'string'  ? properties[prefix + 'Font']   : properties.textFont,\n            size   = typeof properties[prefix + 'Size']   === 'number'  ? properties[prefix + 'Size']   : properties.textSize,\n            color  = typeof properties[prefix + 'Color']  === 'string'  ? properties[prefix + 'Color']  : properties.textColor,\n            bold   = !RGraph.isNull(properties[prefix + 'Bold'])        ? properties[prefix + 'Bold']   : properties.textBold,\n            italic = !RGraph.isNull(properties[prefix + 'Italic'])      ? properties[prefix + 'Italic'] : properties.textItalic;\n\n        return {font: font, size: size, color: color, bold: bold, italic: italic};\n    };\n\n\n\n\n\n\n\n\n    //\n    // The responsive function. This installs the rules as stipulated\n    // in the rules array.\n    //\n    // @param object conf An object map of properties/arguments for the function.\n    //                    This should consist of:\n    //                     o maxWidth\n    //                     o width\n    //                     o height\n    //                     o options\n    //                     o css\n    //                     o parentCss\n    //                     o callback\n    //\n    RGraph.responsive = function (conf)\n    {\n        var obj = this;\n        \n        //\n        // Sort the configuration so that it descends in order of biggest screen\n        // to smallest\n        //\n        conf.sort(function (a, b)\n        {\n            var aNull = RGraph.isNull(a.maxWidth);\n            var bNull = RGraph.isNull(b.maxWidth);\n            \n            if (aNull && bNull) return 0;\n            if (aNull && !bNull) return -1;\n            if (!aNull && bNull) return 1;\n\n            return b.maxWidth - a.maxWidth;\n        });\n\n        //\n        // Preparse the configuration adding any missing minWidth values to the configuration\n        //\n        for (var i=0; i<conf.length; ++i) {\n            if (conf[i+1] && typeof conf[i+1].maxWidth === 'number') {\n                conf[i].minWidth = conf[i+1].maxWidth;\n            } else if (!conf[i+1]) {\n                conf[i].minWidth = 0;\n            }\n        }\n\n\n        //\n        // Loop through the configurations\n        //\n        for (var i=0; i<conf.length; ++i) {\n        \n            // Set the minimum and maximum\n            conf[i].minWidth = RGraph.isNull(conf[i].minWidth) ?      0 : conf[i].minWidth;\n            conf[i].maxWidth = RGraph.isNull(conf[i].maxWidth) ? 100000 : conf[i].maxWidth;\n            \n            // Create the media query string\n            var str = 'screen and (min-width: %1px) and (max-width: %2px)'.format(\n                conf[i].minWidth,\n                conf[i].maxWidth\n            );\n        \n            var mediaQuery = window.matchMedia(str);\n            (function (index)\n            {\n                mediaQuery.addListener(function (e)\n                {\n                    if (e.matches) {\n                        matchFunction(conf[index]);\n                    }\n                });\n            })(i);\n            \n            // An Initial test\n            if (   document.documentElement.clientWidth >= conf[i].minWidth\n                && document.documentElement.clientWidth < conf[i].maxWidth) {\n                matchFunction(conf[i]);\n            }\n        }\n        \n        //\n        // If a rule matches - this is the function that runs\n        //\n        function matchFunction (rule)\n        {\n            // If a width is defined for this rule set it\n            if (typeof rule.width === 'number') {\n                if (obj.get('textAccessible')) {\n                    obj.canvas.parentNode.style.width  = rule.width + 'px';\n                }\n                \n                obj.canvas.width = rule.width;\n                obj.canvas.__rgraph_aa_translated__ = false;\n            }\n\n            //\n            // If a height is defined for this rule set it\n            //\n            if (typeof rule.height === 'number') {\n                if (obj.get('textAccessible')) {\n                    obj.canvas.parentNode.style.height = rule.height + 'px';\n                }\n\n                obj.canvas.height = rule.height;\n                obj.canvas.__rgraph_aa_translated__ = false;\n            }\n\n            //\n            // Are there any options to be set?\n            //\n            if (typeof rule.options === 'object') {\n                for (var j in rule.options) {\n                    if (typeof j === 'string') {\n                        obj.set(j, rule.options[j]);\n                    }\n                }\n            }\n\n\n\n\n\n            //\n            // This function simply sets a CSS property on the object.\n            // It accommodates certain name changes\n            //\n            var setCSS = function (el, name, value)\n            {\n                var replacements = [\n                    ['float', 'cssFloat']\n                ];\n                \n                // Replace the name if necessary\n                for (var i=0; i<replacements.length; ++i) {\n                    if (name === replacements[i][0]) {\n                        name = replacements[i][1];\n                    }\n                }\n\n                el.style[name] = value;\n            };\n\n\n\n\n            //\n            // Are there any CSS properties to set on the canvas tag?\n            //\n            if (typeof rule.css === 'object') {\n                for (var j in rule.css) {\n                    if (typeof j === 'string') {\n                        if (obj.get('textAccessible')) {\n                            setCSS(obj.canvas.parentNode, j, rule.css[j]);\n                        } else {\n                            setCSS(obj.canvas, j, rule.css[j]);\n                        }\n                    }\n                }\n            }\n\n            //\n            // Are there any CSS properties to set on the canvas tahs PARENT?\n            //\n            if (typeof rule.parentCss === 'object') {\n                for (var j in rule.parentCss) {\n                    if (typeof j === 'string') {\n                        if (obj.get('textAccessible')) {\n                            setCSS(obj.canvas.parentNode.parentNode, j, rule.parentCss[j]);\n                        } else {\n                            setCSS(obj.canvas.parentNode, j, rule.parentCss[j])\n                        }\n                    }\n                }\n            }\n\n\n\n\n\n            RGraph.cache = [];\n            RGraph.resetColorsToOriginalValues(obj);\n            if (obj.get('textAccessible') && RGraph.text.domNodeCache && RGraph.text.domNodeCache.reset) {\n                RGraph.text.domNodeCache.reset(obj.canvas);\n            }\n\n            RGraph.redraw(obj.canvas);\n\n            // Run the callback function if it's defined\n            if (typeof rule.callback === 'function') {\n                (rule.callback)(obj);\n            }\n        }\n        \n        // Returning the object facilitates chaining\n        return obj;\n    };\n\n\n\n\n\n\n\n\n    //\n    // This function can be used to resize the canvas when the screen size changes. You\n    // specify various rules and they're then checked.\n    //\n    // @param object conf An object map of properties/arguments for the function.\n    //                    This should consist of:\n    //                     o maxWidth\n    //                     o width\n    //                     o height\n    //                     o options\n    //                     o css\n    //                     o parentCss\n    //                     o callback\n    // @param object       Optionally you can give a second object map to the function\n    //                     of options. There's only on option at the moment:\n    //                      o delay\n    //\n    // RGraph.responsiveOld\n    RGraph.responsive_old = function (conf)\n    {\n        var args = arguments[1] || {},\n            \n            // This function is added to each object in their constructors so the this\n            // variable is the chart object.\n            obj   = this,\n            \n            // The func variable becomes the function that is fired by the resize event\n            func  = null,\n            \n            // This is the timer reference\n            timer = null;\n        \n        // The resizie function will run This many milliseconds after the\n        // resize has \"finished\"\n        args.delay = typeof args.delay === 'number' ? args.delay : 200;\n\n        // [TODO] Store defaults that are used if there's no match\n        var func = function ()\n        {\n            // This is set to true if a rule matches\n            var matched = false;\n\n            // Loop through all of the rules\n            for (var i=0; i<conf.length; ++i) {\n\n                //\n                // If a maxWidth is stipulated test that\n                //\n                if (!matched && (document.documentElement.clientWidth <= conf[i].maxWidth || RGraph.isNull(conf[i].maxWidth))) {\n\n                    matched = true;\n\n                    // If a width is defined for this rule set it\n                    if (typeof conf[i].width === 'number') {\n                        if (obj.get('textAccessible')) {\n                            obj.canvas.parentNode.style.width  = conf[i].width + 'px';\n                        }\n                        \n                        obj.canvas.width = conf[i].width;\n                        obj.canvas.__rgraph_aa_translated__ = false;\n                    }\n\n\n\n\n                    //\n                    // If a height is defined for this rule set it\n                    //\n                    if (typeof conf[i].height === 'number') {\n                        if (obj.get('textAccessible')) {\n                            obj.canvas.parentNode.style.height = conf[i].height + 'px';\n                        }\n\n                        obj.canvas.height = conf[i].height;\n                        obj.canvas.__rgraph_aa_translated__ = false;\n                    }\n\n\n\n\n                    //\n                    // Are there any options to be set?\n                    //\n                    if (typeof conf[i].options === 'object' && typeof conf[i].options === 'object') {\n                        for (var j in conf[i].options) {\n                            if (typeof j === 'string') {\n                                obj.set(j, conf[i].options[j]);\n                            }\n                        }\n                    }\n\n\n                    //\n                    // This function simply sets a CSS property on the object.\n                    // It accommodates certain name changes\n                    //\n                    var setCSS = function (el, name, value)\n                    {\n                        var replacements = [\n                            ['float', 'cssFloat']\n                        ];\n                        \n                        // Replace the name if necessary\n                        for (var i=0; i<replacements.length; ++i) {\n                            if (name === replacements[i][0]) {\n                                name = replacements[i][1];\n                            }\n                        }\n\n                        el.style[name] = value;\n                    };\n\n\n\n\n                    //\n                    // Are there any CSS properties to set on the canvas tag?\n                    //\n                    if (typeof conf[i].css === 'object') {\n                        for (var j in conf[i].css) {\n                            if (typeof j === 'string') {\n                                if (obj.get('textAccessible')) {\n                                    setCSS(obj.canvas.parentNode, j, conf[i].css[j]);\n                                } else {\n                                    setCSS(obj.canvas, j, conf[i].css[j]);\n                                }\n                            }\n                        }\n                    }\n\n                    //\n                    // Are there any CSS properties to set on the canvas tahs PARENT?\n                    //\n                    if (typeof conf[i].parentCss === 'object') {\n                        for (var j in conf[i].parentCss) {\n                            if (typeof j === 'string') {\n                                if (obj.get('textAccessible')) {\n                                    setCSS(obj.canvas.parentNode.parentNode, j, conf[i].parentCss[j]);\n                                } else {\n                                    setCSS(obj.canvas.parentNode, j, conf[i].parentCss[j])\n                                }\n                            }\n                        }\n                    }\n\n\n                    // Redraw the chart\n                    RGraph.cache = [];\n                    RGraph.resetColorsToOriginalValues(obj);\n                    if (obj.get('textAccessible')) {\n                        RGraph.text.domNodeCache.reset(obj.canvas);\n                    }\n\n                    RGraph.redraw();\n\n\n                    // Run the callback function if it's defined\n                    if (typeof conf[i].callback === 'function') {\n                        (conf[i].callback)(obj);\n                    }\n                }\n            }\n        }\n\n\n\n\n\n\n        // Install the resize event listener\n        RGraph.responsive.window_resize_event_listener = function ()\n        {\n            // Set a new timer in order to fire the func() function\n            if (args.delay > 0) {\n                // Clear the timeout\n                clearTimeout(timer);\n                \n                // Start a new timer going\n                timer = setTimeout(func, args.delay);\n            \n            // If you don't want a delay before the resizing occurs\n            // then set the delay to zero and it will be fired immediately\n            } else {\n                func();\n            }\n        };\n        window.addEventListener(\n            'resize',\n            RGraph.responsive.window_resize_event_listener,\n            false\n        );\n\n        \n        // Call the function initially otherwise it may never run\n        func();\n        \n        // This facilitates chaining\n        return obj;\n    };\n\n\n\n\n\n\n\n\n    //\n    // A shortcut function for the RGraph.path() function. Saves\n    // approximately 40 characters, In each objects constructor\n    // it is added to the object so you can call it like this:\n    //\n    // myBar.path({\n    //     path: 'lw 10 b r % % % % s black f red'\n    //     args: [5,5,50,50]\n    // });\n    //\n    // Or like this (whichever you prefer):\n    //\n    // myBar.path(\n    //     'lw 10 b r % % % % s black f red',\n    //     5, 5, 50, 50\n    // );\n    //\n    RGraph.pathObjectFunction = function ()\n    {\n        // Siongle object argument\n        if (arguments.length === 1 && typeof arguments[0] === 'object') {\n            \n            var args = RGraph.getArgs(arguments, 'path,args');\n            \n            RGraph.path({\n                object: this,\n                  path: args.path,\n                  args: args.args\n            });\n        \n        // First arg is a string                \n        } else {\n        \n            var args = Array.prototype.slice.call(arguments, 1);\n\n            RGraph.path({\n                object: this,\n                  path: arguments[0],\n                  args: args\n            });\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // A common X axis drawing function that can be used by  the\n    // Bar, HBar, Line, Scatter functions. A long time coming - but\n    // this will eventually be joined by a common Y axis drawing\n    // function.\n    //\n    //@param object obj The chart object. All the properties are\n    //                  retrieved from this.\n    //\n    RGraph.drawXAxis = function (obj)\n    {\n        var properties      = obj.properties,\n            context         = obj.context,\n            tickmarksLength = (typeof properties.xaxisTickmarksLength === 'number' ? properties.xaxisTickmarksLength : 3),\n            isSketch        = (obj.type === 'bar' && properties.variant === 'sketch');\n\n\n\n\n\n\n        \n\n\n\n\n\n\n\n\n\n        //\n        // If the xaxisLabels property is defined then go through it converting\n        // null and undefined values to empty strings.\n        //\n        if (   typeof properties.xaxisLabels === 'object'\n            && !RGraph.isNull(properties.xaxisLabels)\n            && properties.xaxisLabels.length) {\n            \n            for (var i=0; i<properties.xaxisLabels.length; ++i) {\n                if (typeof properties.xaxisLabels[i] === 'undefined' || properties.xaxisLabels[i] === null) {\n                    properties.xaxisLabels[i] = '';\n                }\n            }\n        }\n\n        //\n        // Calculate the Y coordinate for the X axis\n        if ( (obj.type === 'hbar' || obj.type === 'gantt') && properties.xaxisPosition === 'bottom') {\n            var y = obj.canvas.height - properties.marginBottom;\n        } else if ( (obj.type === 'hbar' || obj.type === 'gantt') && properties.xaxisPosition === 'top') {\n            var y = properties.marginTop;\n        //} else if (obj.type === 'scatter' && properties.yaxisScaleInvert) {\n        //    var y = obj.getYCoord(properties.yaxisScaleMin > 0 ? properties.yaxisScaleMin : 0);\n        } else {\n            var y = obj.getYCoord(properties.yaxisScaleMin > 0 ? properties.yaxisScaleMin : 0);\n        }\n\n        // Special case for a Line chart with an inverted scale\n        if (obj.type === 'line' && properties.yaxisScaleInvert && properties.yaxisScaleMin === 0) {\n            y = obj.getYCoord(obj.scale2.max);\n        }\n\n        // Special case for a Scatter chart with an inverted scale\n        if (obj.type === 'scatter' && properties.yaxisScaleInvert) {\n            if (properties.yaxisScaleMin >= 0) {\n                y = obj.getYCoord(obj.scale2.max);\n            }\n        }\n\n        // Special case for positioning an X axis Drawing API object\n        if (obj.type === 'drawing.xaxis') {\n            if (properties.xaxisPosition === 'center') {\n                y = ((obj.canvas.height - properties.marginTop - properties.marginBottom) / 2) + properties.marginTop;\n            } else {\n                y = obj.y;\n            }\n        }\n\n        //\n        // Draw the axis\n        //\n        if (properties.xaxis) {\n\n            // Draw the axis\n            obj.path(\n                'lw % b m % % l % % s %',\n                properties.xaxisLinewidth,\n                properties.marginLeft - (isSketch ? 5 : 0),\n                \n                y - (isSketch ? 2 : 0),\n                \n                obj.canvas.width - properties.marginRight + (isSketch ? 7 : 0), y + (isSketch ? 2 : 0),\n                properties.xaxisColor\n            );\n\n                // Draw the tickmarks if necessary\n                if (!isSketch) {\n\n                    if (properties.xaxisTickmarks) {\n\n                        if (typeof properties.xaxisTickmarksCount === 'number') {\n                            var xaxisTickmarksCount = properties.xaxisTickmarksCount;\n\n                        // Bar - get number of tickmarks from the number of data points\n                        } else if (obj.type === 'bar') {\n                            var xaxisTickmarksCount = obj.data.length || 10;\n                            \n                        // HBar - get number of tickmarks from the xaxisLabelsCount property and default to 5\n                        } else if (obj.type === 'hbar') {\n                            var xaxisTickmarksCount = (properties.xaxisLabelsCount || 5);\n                        \n                        // Line - get the number of tickmarks from the number of datapoints\n                        } else if (obj.type === 'line') {\n                            var xaxisTickmarksCount = obj.data[0].length > 0 ? obj.data[0].length - 1 : 10;\n                        \n                        // Scatter - with a scale - get the number of tickmarks from the number of scale labels\n                        } else if (obj.type === 'scatter' && properties.scale) {\n                            var xaxisTickmarksCount = 5;\n\n                            \n                        // Scatter - with labels - get the number of tickmarks from the number of labels\n                        } else if (obj.type === 'scatter' && properties.xaxisLabels) {\n                            var xaxisTickmarksCount = properties.xaxisLabels.length;\n\n                        // Scatter - with no labels and no scale\n                        } else if (obj.type === 'scatter') {\n                            var xaxisTickmarksCount = 5;\n\n                        // Waterfall - get the number of tickmarks from the number of datapoints\n                        } else if (obj.type === 'waterfall') {\n                            var xaxisTickmarksCount = obj.data.length + (properties.total ? 1 : 0);\n                            \n                        // Drawing API X axis\n                        } else if (obj.type === 'drawing.xaxis') {\n\n                            if (properties.scale) {\n                                var xaxisTickmarksCount = properties.xaxisScaleLabelsCount;\n                            } else if (properties.xaxisLabels && properties.xaxisLabels.length) {\n                                var xaxisTickmarksCount = properties.xaxisLabels.length;\n                            } else {\n                                var xaxisTickmarksCount = 5;\n                            }\n\n                        //  Default to 5 tickmarks\n                        } else {\n                            xaxisTickmarksCount = 5;\n                        }\n                    } else {\n                        properties.xaxisTickmarksCount = 0;\n                    }\n\n\n\n\n\n\n\n\n\n                // Determine the Y start coordinate for the tickmarks\n                if (properties.xaxisPosition === 'center' && properties.yaxisScaleMin >= 0) {\n                    if (properties.yaxisScaleInvert) {\n                        var tickmarksYStart = obj.getYCoord(properties.yaxisScaleMax) - tickmarksLength;\n                        var tickmarksYEnd   = obj.getYCoord(properties.yaxisScaleMax) + tickmarksLength;\n                    } else {\n                        var tickmarksYStart = obj.getYCoord(properties.yaxisScaleMin) - tickmarksLength;\n                        var tickmarksYEnd   = obj.getYCoord(properties.yaxisScaleMin) + tickmarksLength;\n                    }\n\n                } else if (properties.xaxisPosition === 'center' || properties.yaxisScaleMin < 0) {\n                    if (properties.yaxisScaleInvert) {\n                        var tickmarksYStart = obj.getYCoord(obj.scale2.max) - tickmarksLength;\n                        var tickmarksYEnd   = obj.getYCoord(obj.scale2.max) + tickmarksLength;\n                    } else {\n                        var tickmarksYStart = obj.getYCoord(0) - tickmarksLength;\n                        var tickmarksYEnd   = obj.getYCoord(0) + tickmarksLength;\n                    }\n\n                    // Account for offset axes\n                    if (properties.yaxisScaleMin < 0 && properties.yaxisScaleMax > 0) {\n                        var tickmarksYStart = obj.getYCoord(0) - tickmarksLength;\n                        var tickmarksYEnd   = obj.getYCoord(0) + tickmarksLength;\n                    }\n\n                } else if (properties.xaxisPosition === 'top') {\n                    if (obj.getYCoord) {\n                        var tickmarksYStart = obj.getYCoord(0) - tickmarksLength;\n                        var tickmarksYEnd   = obj.getYCoord(0);\n                    } else {\n                        var tickmarksYStart = properties.marginTop - tickmarksLength;\n                        var tickmarksYEnd   = properties.marginTop;\n                    }\n\n                } else {\n\n                    if (obj.getYCoord) {\n                        if (obj.type === 'line' && properties.yaxisScaleInvert) {\n                            var tickmarksYStart = obj.getYCoord(obj.scale2.max);\n                            var tickmarksYEnd   = obj.getYCoord(obj.scale2.max) + tickmarksLength;\n                        \n                        } else if (obj.type === 'scatter' && properties.yaxisScaleInvert) {\n                            var tickmarksYStart = obj.getYCoord(obj.scale2.max);\n                            var tickmarksYEnd   = obj.getYCoord(obj.scale2.max) + tickmarksLength;\n\n                        } else if (obj.type === 'drawing.xaxis') {\n                            tickmarksYStart = obj.y;\n                            tickmarksYEnd   = obj.y + tickmarksLength;\n\n                        } else {\n                            var tickmarksYStart = obj.getYCoord(properties.yaxisScaleMin);\n                            var tickmarksYEnd   = obj.getYCoord(properties.yaxisScaleMin) + tickmarksLength;\n                        }\n\n                    } else {\n\n                        var tickmarksYStart = obj.canvas.height - properties.marginBottom;\n                        var tickmarksYEnd   = obj.canvas.height - properties.marginBottom + tickmarksLength;\n                    }\n                }\n\n\n\n\n\n\n\n                //if (!xaxisTickmarksCount) {\n                    //xaxisTickmarksCount = 10;\n                //}\n    \n                for (var i=0; i<=xaxisTickmarksCount; ++i) {\n\n                    // Don't draw the LEFT tickmark if there's a Y axis on the left or if specifically\n                    // told not to\n                    if (RGraph.isNull(properties.xaxisTickmarksLastLeft)) {\n\n                        if ( i === 0 && properties.yaxis && properties.yaxisPosition === 'left' && !(properties.xaxisScaleMax > 0 && properties.xaxisScaleMin < 0) ) {\n                            continue;\n                        }\n\n                    } else if (i === 0 && !properties.xaxisTickmarksLastLeft) {\n                        continue;\n                    }\n                    \n                    // Don't draw the RIGHT tickmark if there's a Y axis on the right or if specifically\n                    // told not to\n                    if (RGraph.isNull(properties.xaxisTickmarksLastRight)) {\n                        if (   i === xaxisTickmarksCount && properties.yaxis && properties.yaxisPosition === 'right') {\n                            continue;\n                        }\n                    } else if ( i === xaxisTickmarksCount && !properties.xaxisTickmarksLastRight ) {\n                        continue;\n                    }\n    \n                    var x = (((obj.canvas.width - properties.marginLeft - properties.marginRight) / xaxisTickmarksCount) * i) + properties.marginLeft;\n\n                    // If the chart is an HBar and the Y axis is in the center\n                    // then don't draw a tickmark at the same position as the\n                    // Y axis.\n                    if (obj.type === 'hbar' ) {\n                        if (properties.yaxisPosition === 'center' && x > obj.getXCoord(0) - 2 && x < obj.getXCoord(0) + 2) {\n                            continue;\n                        } else if (properties.yaxisPosition === 'left' && properties.xaxisScaleMin < 0 && properties.xaxisScaleMax > 0 && x > obj.getXCoord(0) - 2 && x < obj.getXCoord(0) + 2) {\n                            continue;\n                        }\n                    }\n    \n                    obj.path(\n                        'b m % % l % % s %',\n                        x, tickmarksYStart,\n                        x, tickmarksYEnd,\n                        properties.xaxisColor\n                    );\n                } // END loop thru xaxisTickmarksCount\n            } // END if (isSketch)\n        }\n        \n\n\n\n\n\n\n\n\n        //\n        // Draw the X axis labels if they're specified\n        //\n\n        //\n        // Text angle\n        //\n        if (properties.xaxisLabelsAngle != 0) {\n            \n            var valign =  'center';\n            var halign =  'right';\n            var angle  = 0 - properties.xaxisLabelsAngle;\n            \n            if (properties.xaxisPosition === 'top') {\n                var angle  = properties.xaxisLabelsAngle;\n            }\n            \n        } else {\n            var valign =  'top';\n            var halign =  'center';\n            var angle  = 0;\n        }\n\n        //\n        // Draw an X axis scale if requested. The HBar uses an X axis scale and the\n        // Scatter chart can (optionally) too\n        //\n        if (properties.xaxisScale) {\n        \n            var scale = obj.scale2;\n\n            //\n            // Get the scale for a Scatter chart X axis\n            //\n            if (obj.type === 'scatter') {\n                scale = obj.xscale2;\n\n            // Get the scale for a drawing API X axis\n            } else if (obj.type === 'drawing.xaxis') {\n                if (properties.xaxisScale) {\n                \n                    scale = RGraph.getScale({object: this, options: {\n                        'scale.max':          properties.xaxisScaleMax,\n                        'scale.min':          properties.xaxisScaleMin,\n                        'scale.decimals':     Number(properties.xaxisScaleDecimals),\n                        'scale.point':        properties.xaxisScalePoint,\n                        'scale.thousand':     properties.xaxisScaleThousand,\n                        'scale.round':        properties.xaxisScaleRound,\n                        'scale.units.pre':    properties.xaxisScaleUnitsPre,\n                        'scale.units.post':   properties.xaxisScaleUnitsPost,\n                        'scale.labels.count': properties.xaxisScaleLabelsCount,\n                        'scale.strict':       true\n                     }});\n\n                    for (var i=0; i<=properties.xaxisScaleLabelsCount; ++i) {\n                    \n                        var original = (((properties.xaxisScaleMax - properties.xaxisScaleMin) / properties.xaxisScaleLabelsCount) * i) + properties.xaxisScaleMin;\n                        var hmargin  = properties.marginInner;\n                    \n                        if (typeof properties.xaxisScaleFormatter === 'function') {\n                            var text =  (properties.xaxisScaleFormatter)(this, original)\n                        } else {\n                    \n                            text = RGraph.numberFormat({\n                                object:    obj,\n                                number:    original.toFixed(original === 0 ? 0 : properties.xaxisScaleDecimals),\n                                unitspre:  properties.xaxisScaleUnitsPre,\n                                unitspost: properties.xaxisScaleUnitsPost,\n                                point:     properties.xaxisScalePoint,\n                                thousand:  properties.xaxisScaleThousand\n                            });\n                        }\n                    }\n                }\n            }\n\n            for (var i=0; i<scale.labels.length; ++i) {\n\n                var section = (obj.canvas.width - properties.marginLeft - properties.marginRight) / scale.labels.length;\n                \n                if (properties.yaxisPosition === 'right') {\n                    var x = properties.marginLeft + (section * i);\n                } else if (properties.yaxisPosition === 'center') {\n                    section /= 2;\n                    var x = obj.getXCoord(0) + section + (section * i);\n                } else {\n                    var x = properties.marginLeft + (section * i) + section;\n                }\n                \n                var y = properties.xaxisPosition === 'top' ? obj.marginTop - (properties.xaxisTickmarksLength || 0) + properties.xaxisLabelsOffsety - 5 : (obj.canvas.height - properties.marginBottom) + (properties.xaxisTickmarksLength || 0) + properties.xaxisLabelsOffsety + 5;\n                \n                if (obj.type === 'drawing.xaxis') {\n                    if (properties.xaxisPosition === 'top') {\n                        y = obj.y - (properties.xaxisTickmarksLength || 0) + properties.xaxisLabelsOffsety;\n                    } else {\n                        y = obj.y + (properties.xaxisTickmarksLength || 0) + properties.xaxisLabelsOffsety + 5;\n                    }\n                }\n\n                RGraph.text({\n                  object: obj,\n          textConfPrefix: 'xaxisLabels',\n                    x:      x + properties.xaxisLabelsOffsetx,\n                    y:      y,\n                    text:   typeof properties.xaxisScaleFormatter === 'function' ? (properties.xaxisScaleFormatter)({object: obj, number: scale.values[i]}) : (properties.yaxisPosition === 'right' ? String(scale.labels[scale.labels.length - 1 - i]) : String(scale.labels[i])),\n                    valign: typeof properties.xaxisLabelsValign === 'string' ? properties.xaxisLabelsValign : (properties.xaxisPosition === 'top' ? 'bottom' : valign),\n                    halign: typeof properties.xaxisLabelsHalign === 'string' ? properties.xaxisLabelsHalign : halign,\n                    marker: false,\n                    angle:  angle,\n                    tag:    'xaxis.labels'\n                });\n\n                //\n                // If the chart is a HBar and the X axis is in the center then\n                // draw the negative side of the labels\n                //\n                if (obj.type === 'hbar' && properties.yaxisPosition === 'center') {\n                \n                        x = obj.getXCoord(0) - section - (section * i);\n                \n                        RGraph.text({\n                          object: obj,\n                  textConfPrefix: 'xaxisLabels',\n                            x:      x + properties.xaxisLabelsOffsetx,\n                            y:      properties.xaxisPosition === 'top' ? obj.marginTop - (properties.xaxisTickmarksLength || 0) + properties.xaxisLabelsOffsety - 5 : (obj.canvas.height - properties.marginBottom) + (properties.xaxisTickmarksLength || 0) + properties.xaxisLabelsOffsety + 5,\n                            text:   typeof properties.xaxisScaleFormatter === 'function' ? (properties.xaxisScaleFormatter)({object: obj, number: scale.values[i]}) : '-' + String(scale.labels[i]),\n                            valign: typeof properties.xaxisLabelsValign === 'string' ? properties.xaxisLabelsValign : (properties.xaxisPosition === 'top' ? 'bottom' : valign),\n                            halign: typeof properties.xaxisLabelsHalign === 'string' ? properties.xaxisLabelsHalign : halign,\n                            marker: false,\n                            angle:  angle,\n                            tag:    'xaxis.labels'\n                        });\n                }\n                \n                \n\n                //\n                // Draw the minimum label\n                //\n                var str = ((properties.xaxisScaleUnitsPre || '') + (properties.xaxisScaleMin || 0).toFixed(properties.xaxisScaleDecimals).replace(/\\./, properties.xaxisScalePoint) + (properties.xaxisScaleUnitsPost || ''));\n                str     = str.replace(/^(.+)-(\\d)/, '-$1$2');\n\n                RGraph.text({\n                  object:   obj,\n          textConfPrefix:   'xaxisLabels',\n                    x:      properties.yaxisPosition === 'right' ? obj.canvas.width - properties.marginRight + properties.xaxisLabelsOffsetx : (properties.yaxisPosition === 'center' ? obj.getXCoord(0) + properties.xaxisLabelsOffsetx : properties.marginLeft + properties.xaxisLabelsOffsetx),\n                    y:      y,\n                    text:   typeof properties.xaxisScaleFormatter === 'function' ? (properties.xaxisScaleFormatter)({object: obj, number: 0}) : str,\n                    valign: typeof properties.xaxisLabelsValign === 'string' ? properties.xaxisLabelsValign : (typeof properties.xaxisLabelsValign === 'string' ? properties.xaxisLabelsValign : (properties.xaxisPosition === 'top' ? 'bottom' : valign)),\n                    halign: typeof properties.xaxisLabelsHalign === 'string' ? properties.xaxisLabelsHalign : halign,\n                    marker: false,\n                    angle:  angle,\n                    tag:    'xaxis.labels'\n                });\n            }\n\n        } else if (properties.xaxisLabels && properties.xaxisLabels.length && (properties.xaxisLabelsPosition === 'section' || properties.xaxisLabelsPosition === 'edge') ) {\n\n            if (properties.xaxisLabelsPosition === 'edge') {\n                var section = (obj.canvas.width - properties.marginLeft - properties.marginRight - (properties.marginInner || 0) - (properties.marginInner || 0) ) / (properties.xaxisLabels.length - 1);\n            } else {\n                var section = (obj.canvas.width - properties.marginLeft - properties.marginRight) / properties.xaxisLabels.length;\n            }\n\n\n            for (var i=0; i<properties.xaxisLabels.length; ++i) {\n\n\n                if (properties.xaxisLabelsPosition === 'edge') {\n                    var x = properties.marginLeft + (properties.marginInner || 0) + (section * i);\n                } else {\n                    var x = properties.marginLeft + (section * i) + (section / 2) ;\n                }\n\n\n\n\n\n\n\n\n\n\n\n                // Allow for the Scatter chart labels to be at specific points\n                // along the X scale\n                if (typeof properties.xaxisLabels[i] === 'object' && obj.type === 'scatter') {\n\n                    var rightEdge = 0;\n                    var align     = properties.xaxisLabelsSpecificAlign === 'left' ? 'left' : 'center';\n                    var halign    = 'center'\n                    \n\n                    if (properties.xaxisLabels[i+1] && typeof properties.xaxisLabels[i+1][1] === 'number') {\n                        rightEdge = properties.xaxisLabels[i+1][1];\n\n                    } else {\n                        rightEdge = properties.xaxisScaleMax;\n                    }\n\n                    var leftEdge = properties.xaxisLabels[i][1];\n                    var x        = ((obj.getXCoord(rightEdge) - obj.getXCoord(leftEdge)) / 2) + obj.getXCoord(leftEdge);\n                    \n                    if (align === 'left') {\n                        x      = obj.getXCoord(leftEdge);\n                        halign = 'left';\n                    }\n\n                    if (RGraph.isNull(x)) {\n                        continue;\n                    }\n\n                    if (obj.type === 'drawing.xaxis') {\n                        if (properties.xaxisPosition === 'top') {\n                            y = obj.y - (properties.xaxisTickmarksLength || 0) + properties.xaxisLabelsOffsety;\n                        } else {\n                            y = obj.y + (properties.xaxisTickmarksLength || 0) + properties.xaxisLabelsOffsety + 5;\n                        }\n                    }\n\n                    var ret = RGraph.text({\n                   object:      obj,\n           textConfPrefix:      'xaxisLabels',\n                        x:      x + 5 + properties.xaxisLabelsOffsetx,\n                        y:      y + 5 + properties.xaxisLabelsOffsety,\n                        valign: valign,\n                        halign: angle != 0 ? 'right' : halign,\n                        text:   String(properties.xaxisLabels[i][0]),\n                        angle:  angle,\n                        marker: false,\n                        tag:    'labels.specific',\n                   cssClass:    RGraph.getLabelsCSSClassName({\n                                    object: obj,\n                                      name: 'xaxisLabelsClass',\n                                     index: i\n                                })\n                    });\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                    //\n                    // Draw the gray indicator line\n                    //\n                    obj.path('b m % % l % % s #bbb',\n                        Math.round(properties.marginLeft + (((properties.xaxisLabels[i][1] - properties.xaxisScaleMin) / (properties.xaxisScaleMax - properties.xaxisScaleMin )) * (obj.canvas.width - properties.marginLeft - properties.marginRight) )), obj.canvas.height - properties.marginBottom,\n                        Math.round(properties.marginLeft + (((properties.xaxisLabels[i][1] - properties.xaxisScaleMin) / (properties.xaxisScaleMax - properties.xaxisScaleMin))) * (obj.canvas.width - properties.marginLeft - properties.marginRight) ), obj.canvas.height - properties.marginBottom + 20\n                    );\n                    \n                    // Draw the final indicator line if we're on the final label\n                    if (i === properties.xaxisLabels.length - 1) {\n                        obj.path('b m % % l % % s #bbb',\n                            obj.canvas.width - properties.marginRight, obj.canvas.height - properties.marginBottom,\n                            obj.canvas.width - properties.marginRight, obj.canvas.height - properties.marginBottom + 20\n                        );\n                    }\n\n                // A regular label\n                } else {\n\n                    var y = properties.xaxisPosition === 'top' ? properties.marginTop + properties.xaxisLabelsOffsety - 5 : (obj.canvas.height - properties.marginBottom) + properties.xaxisLabelsOffsety + 5;\n\n                    if (obj.type === 'drawing.xaxis') {\n                        //y = obj.y + (properties.xaxisTickmarksLength || 0) + properties.xaxisLabelsOffsety + 5;\n                        if (obj.type === 'drawing.xaxis') {\n                            if (properties.xaxisPosition === 'top') {\n                                y = obj.y - (properties.xaxisTickmarksLength || 0) + properties.xaxisLabelsOffsety;\n                            } else {\n                                y = obj.y + (properties.xaxisTickmarksLength || 0) + properties.xaxisLabelsOffsety + 5;\n                            }\n                        }\n                    }\n\n                    var ret = RGraph.text({\n                      object:   obj,\n              \n              textConfPrefix:   'xaxisLabels',\n\n                        x:      x + properties.xaxisLabelsOffsetx,\n                        y:      y + properties.xaxisLabelsOffsety,\n                        \n                        text:   String(properties.xaxisLabels[i]),\n                        \n                        valign: typeof properties.xaxisLabelsValign === 'string' ? properties.xaxisLabelsValign : (properties.xaxisPosition === 'top' ? 'bottom' : valign),\n                        halign: typeof properties.xaxisLabelsHalign === 'string' ? properties.xaxisLabelsHalign : halign,\n                        \n                        marker: false,\n                        angle:  angle,\n                        tag:    'xaxis.labels',\n                        \n                   cssClass:    RGraph.getLabelsCSSClassName({\n                                    object: obj,\n                                      name: 'xaxisLabelsClass',\n                                     index: i\n                                })\n                    });\n                }\n            }\n        }\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n\n\n\n\n\n\n\n\n\n\n\n        //\n        // Draw the title\n        //\n        if (properties.xaxisTitle) {\n\n            var x = properties.marginLeft + ((obj.canvas.width - properties.marginLeft - properties.marginRight) / 2) + properties.xaxisTitleOffsetx;\n            var y = properties.xaxisPosition === 'top' ? properties.marginTop  - 7 + properties.xaxisTitleOffsety - properties.xaxisTickmarksLength : obj.canvas.height - properties.marginBottom + 7 + properties.xaxisTitleOffsety + properties.xaxisTickmarksLength;\n\n            if (obj.type === 'drawing.xaxis') {\n                y = obj.y  + 7 + properties.xaxisTitleOffsety + properties.xaxisTickmarksLength;\n            }\n\n            \n            // Get the size of the X axis labels\n            if (properties.xaxisScale || (properties.xaxisLabels && properties.xaxisLabels.length) ) {\n                var textConf = RGraph.getTextConf({\n                    object: obj,\n                    prefix: 'xaxisLabels'\n                });\n\n                if (properties.xaxisPosition === 'top') {\n                    y -= textConf.size * 1.5;\n                } else {\n                    y += textConf.size * 1.5;\n                }\n            }\n\n            // The xaxisTitlePos property\n            if (typeof properties.xaxisTitlePos === 'number') {\n                if (properties.xaxisPosition === 'top') {\n                    y = properties.marginTop * properties.xaxisTitlePos;\n                } else {\n                    y = obj.canvas.height - properties.marginBottom + (properties.marginBottom * properties.xaxisTitlePos);\n                }\n            }\n\n            // Specific X and Y coordinates for the title\n            if (typeof properties.xaxisTitleX === 'number') x = properties.xaxisTitleX;\n            if (typeof properties.xaxisTitleY === 'number') y = properties.xaxisTitleY;\n\n\n            RGraph.text({\n              object: obj,\n              textConfPrefix: 'xaxisTitle',\n                x:      x,\n                y:      y,\n                text:   properties.xaxisTitle.toString(),\n                valign: properties.xaxisPosition === 'top' ? (properties.xaxisTitleValign || 'bottom') : (properties.xaxisTitleValign || 'top'),\n                halign: properties.xaxisTitleHalign || 'center',\n                marker: false,\n                tag:    'xaxis.title'\n            });\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // A common X axis drawing function that can be used by  the\n    // Bar, HBar, Line, Scatter functions. A long time coming - but\n    // this will eventually be joined by a common Y axis drawing\n    // function.\n    //\n    //@param object obj The chart object. All the properties are\n    //                  retrieved from this.\n    //\n    RGraph.drawYAxis = function (obj)\n    {\n        var properties      = obj.properties,\n            context         = obj.context,\n            isSketch        = obj.type === 'bar' && properties.variant === 'sketch';\n            tickmarksLength = typeof properties.yaxisTickmarksLength === 'number' ? properties.yaxisTickmarksLength : 3;\n\n\n\n\n\n\n\n\n        \n\n\n\n\n\n\n\n\n\n        // If drawing a HBar or a Gantt chart then set the yaxisLabelsSpecific option\n        if (obj.type === 'hbar') {\n            properties.yaxisLabelsSpecific = properties.yaxisLabels;\n        }\n    \n        // Calculate the X coordinate for the Y axis\n        if ( (obj.type === 'hbar' || obj.type === 'gantt') && properties.yaxisPosition === 'left') {\n            var x = obj.getXCoord(0);\n\n        } else if ( (obj.type === 'hbar' || obj.type === 'gantt') && properties.yaxisPosition === 'right') {\n            var x = obj.canvas.width - properties.marginRight;\n        \n        } else if (obj.type === 'drawing.yaxis') {\n            var x = obj.x;\n        \n        } else {\n            var x = properties.yaxisPosition === 'right' ? obj.canvas.width - properties.marginRight : (obj.type === 'hbar' ? obj.getXCoord(0) : properties.marginLeft);\n        }\n\n        //\n        // Draw the Y axis\n        //\n        if (properties.yaxis) {\n\n            // Draw the axis\n            obj.path(\n                'lw % b m % % l % % s %',\n                properties.yaxisLinewidth,\n                x - (isSketch ? 5 : 0),     properties.marginTop - (isSketch ? 2 : 0),                \n                x + (isSketch ? 7 : 0),     obj.canvas.height - properties.marginBottom  + (isSketch ? 2 : 0),\n                properties.yaxisColor\n            );\n\n\n\n\n            // Draw the tickmarks for the Y axis if necessary\n            if (!isSketch) {\n                if (properties.yaxisTickmarks) {\n    \n                    if (typeof properties.yaxisTickmarksCount === 'number') {\n                        var yaxisTickmarksCount = properties.yaxisTickmarksCount;\n\n                    // Bar - get number of tickmarks from the number of data points\n                    } else if (obj.type === 'bar') {\n                        var yaxisTickmarksCount = properties.yaxisLabelsSpecific ? properties.yaxisLabelsSpecific.length - 1 : properties.yaxisLabelsCount;\n\n                    // HBar - get number of tickmarks from the xaxisLabelsCount property and default to 5\n                    } else if (obj.type === 'hbar') {\n                        var yaxisTickmarksCount = obj.data.length || 5;\n                    \n                    // Line - get the number of tickmarks from the number of datapoints\n                    } else if (obj.type === 'line') {\n                        var yaxisTickmarksCount = properties.yaxisLabelsSpecific ? properties.yaxisLabelsSpecific.length - 1  : properties.yaxisLabelsCount;\n                    \n                    // Scatter - with a scale - get the number of tickmarks from the number of scale labels\n                    } else if (obj.type === 'scatter') {\n                        var yaxisTickmarksCount = properties.yaxisLabelsCount;\n                    \n                    // Waterfall - get the number of tickmarks from the number of datapoints\n                    } else if (obj.type === 'waterfall') {\n                        var yaxisTickmarksCount = properties.yaxisLabelsCount;\n                        \n                    //  Default to 5 tickmarks\n                    } else {\n                        yaxisTickmarksCount = 5;\n                    }\n                } else {\n                    properties.yaxisTickmarksCount = 0;\n                }\n\n    \n    \n    \n\n    \n    \n                // Determine the X start/end coordinates for the tickmarks\n                if (properties.yaxisPosition === 'right') {\n                    var tickmarksXStart = x;\n                    var tickmarksXEnd   = x + tickmarksLength;\n    \n                //} else if (properties.yaxisPosition === 'center') {\n                //    var tickmarksXStart = x - tickmarksLength;\n                //    var tickmarksXEnd   = x + tickmarksLength;\n\n                } else {\n                    var tickmarksXStart = x;\n                    var tickmarksXEnd   = x - tickmarksLength;\n                }\n    \n                // Account for HBar offset axes\n                if (obj.type === 'hbar' && properties.xaxisScaleMin < 0 && properties.xaxisScaleMax > 0) {\n                    var tickmarksXStart = obj.getXCoord(0) - tickmarksLength;\n                    var tickmarksXEnd   = obj.getXCoord(0) + tickmarksLength;\n                }\n    \n    \n                //\n                // Now draw the tickmarks\n                //\n                for (var i=0; i<=yaxisTickmarksCount; ++i) {\n\n                    // Don't draw the TOP tickmark if there's an X axis at the top or if specifically\n                    // told not to\n                    if (RGraph.isNull(properties.yaxisTickmarksLastTop)) {\n                        if (i === 0 && properties.xaxis && properties.xaxisPosition === 'top') {\n                            continue;\n                        }\n                    } else if (i === 0 && !properties.yaxisTickmarksLastTop) {\n                        continue;\n                    }\n                    \n                    // Don't draw the BOTTOM tickmark if there's an X axis at the bottom or if specifically\n                    // told not to\n                    if (RGraph.isNull(properties.yaxisTickmarksLastBottom)) {\n\n                        if (i === yaxisTickmarksCount && properties.xaxis && properties.xaxisPosition === 'bottom') {\n                            continue;\n                        }\n                    } else if (i === yaxisTickmarksCount && !properties.yaxisTickmarksLastBottom) {\n                        continue;\n                    }\n\n                    var y           = (((obj.canvas.height - properties.marginTop - properties.marginBottom) / yaxisTickmarksCount) * i) + properties.marginTop;\n                    \n                    if (obj.getYCoord) {\n                        var xaxisYCoord = obj.getYCoord(0);\n                    } else if (obj.getXCoord) {\n                        var xaxisYCoord = obj.getXCoord(0);\n                    } else {\n                        var xaxisYCoord = obj.marginTop;\n                    }\n\n                    if (    properties.xaxis\n                        && (properties.xaxisPosition === 'center' || (properties.xaxisPosition === 'bottom' && properties.yaxisScaleMin < 0 && properties.yaxisScaleMax > 0))\n                        && y > (xaxisYCoord - 1)\n                        && y < (xaxisYCoord + 1)) {\n                        continue;\n                    }\n\n                    obj.path(\n                        'b m % % l % % s %',\n                        tickmarksXStart, y,\n                        tickmarksXEnd,   y,\n                        properties.yaxisColor\n                    );\n                    \n                    // if the X axis is offset (eg -10,0,10,20,30,40) draw an extra\n                    // tickmark at the bottom of the axes\n                    if (properties.yaxisScaleMin < 0 && properties.yaxisScaleMax > 0) {\n                        obj.path(\n                            'b m % % l % % s %',\n                            tickmarksXStart, obj.canvas.height - properties.marginBottom,\n                            tickmarksXEnd,   obj.canvas.height - properties.marginBottom,\n                            properties.yaxisColor\n                        );\n                    }\n\n                    // if the chart is:\n                    // o A Scatter chart\n                    // o X axis is in the center\n                    // o The scale is inverted\n                    if (obj.type === 'scatter' && properties.xaxisPosition === 'center' && properties.yaxisScaleInvert) {\n                        obj.path(\n                            'b m % % l % % s %',\n                            tickmarksXStart,   properties.marginTop,\n                            tickmarksXEnd,     properties.marginTop,\n                            properties.yaxisColor\n                        );\n                    }\n                } // END for loop thru yaxisTickmarksCount\n            } // END if (!isSketch)\n        }\n\n\n\n\n\n\n\n\n        //\n        // The text angle - this does not apply to the Y axis so these\n        // are just the alignments\n        //\n        var valign =  'center',\n            halign =  'right',\n            angle  = 0;\n        \n        \n        \n\n\n        //\n        // Draw a Y axis scale.\n        //\n        if (properties.yaxisScale && !properties.yaxisLabelsSpecific) {\n            if (obj.type === 'drawing.yaxis') {\n                if (properties.yaxisScale) {\n\n                    obj.scale2 = RGraph.getScale({object: obj, options: {\n                        'scale.max':          properties.yaxisScaleMax,\n                        'scale.min':          properties.yaxisScaleMin,\n                        'scale.decimals':     Number(properties.yaxisScaleDecimals),\n                        'scale.point':        properties.yaxisScalePoint,\n                        'scale.thousand':     properties.yaxisScaleThousand,\n                        'scale.round':        properties.yaxisScaleRound,\n                        'scale.units.pre':    properties.yaxisScaleUnitsPre,\n                        'scale.units.post':   properties.yaxisScaleUnitsPost,\n                        'scale.labels.count': properties.yaxisScaleLabelsCount,\n                        'scale.strict':       true\n                     }});\n\n                    for (var i=0; i<=properties.yaxisScaleLabelsCount; ++i) {\n                    \n                        var original = (((properties.yaxisScaleMax - properties.yaxisScaleMin) / properties.yaxisScaleLabelsCount) * i) + properties.yaxisScaleMin;\n                        var hmargin  = properties.marginInner;\n                    \n                        if (typeof properties.yaxisScaleFormatter === 'function') {\n                            var text =  (properties.yaxisScaleFormatter)(this, original)\n                        } else {\n                    \n                            text = RGraph.numberFormat({\n                                object:    obj,\n                                number:    original.toFixed(original === 0 ? 0 : properties.yaxisScaleDecimals),\n                                unitspre:  properties.yaxisScaleUnitsPre,\n                                unitspost: properties.yaxisScaleUnitsPost,\n                                point:     properties.yaxisScalePoint,\n                                thousand:  properties.yaxisScaleThousand\n                            });\n                        }\n                    }\n                }\n            }\n\n            var scale           = obj.scale2;\n            obj.maxLabelLength = Math.max(\n                obj.maxLabelLength,\n                obj.context.measureText(obj.scale2.labels[4]).width// * 2 // Don't know why this was doubled...?\n            );\n\n\n            //\n            // X axis position in the center\n            //\n            if (properties.xaxisPosition === 'center') {\n            \n                var halfHeight = ((obj.canvas.height - properties.marginTop - properties.marginBottom) / 2);\n                \n                // Draw the top halves labels\n                for (var i=0; i<scale.labels.length; ++i) {\n\n                    var section = (obj.canvas.height - properties.marginTop - properties.marginBottom) / (scale.labels.length * 2);\n                    var y       = properties.marginTop + (section * i);\n\n                    RGraph.text({\n                      object:   obj,\n              textConfPrefix:   'yaxisLabels',\n                        x:      properties.yaxisPosition === 'right' ? x + (properties.yaxisTickmarksLength || 0) + properties.yaxisLabelsOffsetx + 5 : x - (properties.yaxisTickmarksLength || 0) + properties.yaxisLabelsOffsetx - 5,\n                        y:      properties.yaxisScaleInvert ? halfHeight + properties.marginTop - (section * i) + properties.yaxisLabelsOffsety : properties.marginTop + (section * i) + properties.yaxisLabelsOffsety,\n                        text:   String(scale.labels[scale.labels.length - 1 - i]),\n                        valign: typeof properties.yaxisLabelsValign === 'string' ? properties.yaxisLabelsValign : valign,\n                        halign: typeof properties.yaxisLabelsHalign === 'string' ? properties.yaxisLabelsHalign : (properties.yaxisPosition === 'right' ? 'left' : halign),\n                        marker: false,\n                        angle:  angle,\n                        tag:    'yaxis.labels'\n                    });\n                }\n\n                // Draw the bottom half\n                for (var i=0; i<scale.labels.length; ++i) {\n                \n                    if (i === 0 && properties.yaxisScaleInvert) continue;\n\n                    var section = (obj.canvas.height - properties.marginTop - properties.marginBottom) / (scale.labels.length * 2);\n                    var y       = properties.marginTop + ((obj.canvas.height - properties.marginTop - properties.marginBottom) / 2) + (section * i) + section;\n    \n                    RGraph.text({\n                      object:   obj,\n              textConfPrefix:   'yaxisLabels',\n                        x:      properties.yaxisPosition === 'right' ? x + (properties.yaxisTickmarksLength || 0) + properties.yaxisLabelsOffsetx + 5 : x - (properties.yaxisTickmarksLength || 0) + properties.yaxisLabelsOffsetx - 5,\n                        y:      properties.yaxisScaleInvert ? halfHeight + properties.marginTop + (section * i) : y + properties.yaxisLabelsOffsety,\n                        text:   '-' + (properties.yaxisScaleInvert ? String(scale.labels[scale.labels.length - i - 1]) : String(scale.labels[i])),\n                        valign: typeof properties.yaxisLabelsValign === 'string' ? properties.yaxisLabelsValign : valign,\n                        halign: typeof properties.yaxisLabelsHalign === 'string' ? properties.yaxisLabelsHalign : (properties.yaxisPosition === 'right' ? 'left' : halign),\n                        marker: false,\n                        angle:  angle,\n                        tag:    'yaxis.labels'\n                    });\n                }\n\n\n                //\n                // Draw the zero label\n                //\n                RGraph.text({\n                  object:   obj,\n          textConfPrefix:   'yaxisLabels',\n                    x:      properties.yaxisPosition === 'right' ? x + 5 + (properties.yaxisTickmarksLength || 0) + properties.yaxisLabelsOffsetx : x - 5 - (properties.yaxisTickmarksLength || 0) + properties.yaxisLabelsOffsetx,\n                    y:      properties.yaxisScaleInvert ? properties.marginTop + properties.yaxisLabelsOffsety : properties.marginTop + ((obj.canvas.height - properties.marginBottom - properties.marginTop) / 2) + properties.yaxisLabelsOffsety,\n                    text:   typeof properties.yaxisScaleFormatter === 'function' ? (properties.yaxisScaleFormatter)({object: this,number: 0,unitspre: properties.yaxisScaleUnitsPre,unitspost: properties.yaxisScaleUnitsPost,point: properties.yaxisScalePoint,thousand: properties.yaxisScaleThousand,formatter: properties.yaxisScaleFormatter}) : (properties.yaxisScaleUnitsPre || '') + properties.yaxisScaleMin.toFixed(properties.yaxisScaleDecimals).replace(/\\./, properties.yaxisScalePoint) + (properties.yaxisScaleUnitsPost || ''),\n                    valign: typeof properties.yaxisLabelsValign === 'string' ? properties.yaxisLabelsValign : valign,\n                    halign: typeof properties.yaxisLabelsHalign === 'string' ? properties.yaxisLabelsHalign : (properties.yaxisPosition === 'right' ? 'left' : halign),\n                    marker: false,\n                    angle:  angle,\n                    tag:    'yaxis.labels'\n                });\n                \n\n                //\n                // Draw the zero label for the bottom half if the scale is inverted\n                //\n                if (properties.yaxisScaleInvert) {\n                    RGraph.text({\n                      object:   obj,\n              textConfPrefix:   'yaxisLabels',\n                        x:      properties.yaxisPosition === 'right' ? x + 5 + (properties.yaxisTickmarksLength || 0) + properties.yaxisLabelsOffsetx : x - 5 - (properties.yaxisTickmarksLength || 0) + properties.yaxisLabelsOffsetx,\n                        y:      obj.canvas.height - properties.marginBottom + properties.yaxisLabelsOffsety,\n                        text:   typeof properties.yaxisScaleFormatter === 'function' ? (properties.yaxisScaleFormatter)({object: this,number: 0,unitspre: properties.yaxisScaleUnitsPre,unitspost: properties.yaxisScaleUnitsPost,point: properties.yaxisScalePoint,thousand: properties.yaxisScaleThousand,formatter: properties.yaxisScaleFormatter}) : (properties.yaxisScaleUnitsPre || '') + properties.yaxisScaleMin.toFixed(properties.yaxisScaleDecimals).replace(/\\./, properties.yaxisScalePoint) + (properties.yaxisScaleUnitsPost || ''),\n                        valign: typeof properties.yaxisLabelsValign === 'string' ? properties.yaxisLabelsValign : valign,\n                        halign: typeof properties.yaxisLabelsHalign === 'string' ? properties.yaxisLabelsHalign : (properties.yaxisPosition === 'right' ? 'left' : halign),\n                        marker: false,\n                        angle:  angle,\n                        tag:    'yaxis.labels'\n                    });\n                }\n\n            //\n            // X axis at the top\n            //\n            } else if (properties.xaxisPosition === 'top') {\n                for (var i=0; i<scale.labels.length; ++i) {\n            \n                    var section = (obj.canvas.height - properties.marginTop - properties.marginBottom) / scale.labels.length;\n                    \n                    // Account for inverting the scale\n                    if (properties.yaxisScaleInvert) {\n                        var y = obj.canvas.height - properties.marginBottom - (section * i) - section - section;\n                    } else {\n                        var y = properties.marginTop + (section * i);\n                    }\n            \n                    RGraph.text({\n                      object:   obj,\n              textConfPrefix:   'yaxisLabels',\n                        x:      properties.yaxisPosition === 'right' ? x + (properties.yaxisTickmarksLength || 0) + properties.yaxisLabelsOffsetx + 5 : x - (properties.yaxisTickmarksLength || 0) + properties.yaxisLabelsOffsetx - 5,\n                        y:      y + section + properties.yaxisLabelsOffsety,\n                        text:   '-' + String(scale.labels[i]),\n                        valign: typeof properties.yaxisLabelsValign === 'string' ? properties.yaxisLabelsValign : valign,\n                        halign: typeof properties.yaxisLabelsHalign === 'string' ? properties.yaxisLabelsHalign : (properties.yaxisPosition === 'right' ? 'left' : halign),\n                        marker: false,\n                        angle:  angle,\n                        tag:    'yaxis.labels'\n                    });\n                }\n                    \n                    \n            \n                //\n                // Draw the zero label\n                //\n\n                RGraph.text({\n                  object:   obj,\n            textConfPrefix:   'yaxisLabels',\n                    x:      properties.yaxisPosition === 'right' ? x + 5 + (properties.yaxisTickmarksLength || 0) + properties.yaxisLabelsOffsetx : x - 5 - (properties.yaxisTickmarksLength || 0) + properties.yaxisLabelsOffsetx,\n                    y:      properties.yaxisScaleInvert ? obj.canvas.height - properties.marginBottom + properties.yaxisLabelsOffsety : properties.marginTop + properties.yaxisLabelsOffsety,\n                    text:   typeof properties.yaxisScaleFormatter === 'function' ? (properties.yaxisScaleFormatter)({object: this,number: 0,unitspre: properties.yaxisScaleUnitsPre,unitspost: properties.yaxisScaleUnitsPost,point: properties.yaxisScalePoint,thousand: properties.yaxisScaleThousand,formatter: properties.yaxisScaleFormatter}) : (properties.yaxisScaleUnitsPre || '') + properties.yaxisScaleMin.toFixed(properties.yaxisScaleDecimals).replace(/\\./, properties.yaxisScalePoint) + (properties.yaxisScaleUnitsPost || ''),\n                    valign: typeof properties.yaxisLabelsValign === 'string' ? properties.yaxisLabelsValign : valign,\n                    halign: typeof properties.yaxisLabelsHalign === 'string' ? properties.yaxisLabelsHalign : (properties.yaxisPosition === 'right' ? 'left' : halign),\n                    marker: false,\n                    angle:  angle,\n                    tag:    'yaxis.labels'\n                });\n            //\n            // X axis position at the bottom\n            //\n            } else {\n                for (var i=0; i<scale.labels.length; ++i) {\n\n                    var section = (obj.canvas.height - properties.marginTop - properties.marginBottom) / scale.labels.length;\n                    var y       = properties.marginTop + (section * (i + (properties.yaxisScaleInvert ? 1 : 0)) );\n    \n                    RGraph.text({\n                      object:   obj,\n              textConfPrefix:   'yaxisLabels',\n                        x:      properties.yaxisPosition === 'right' ? x + (properties.yaxisTickmarksLength || 0) + properties.yaxisLabelsOffsetx + 5 : x - (properties.yaxisTickmarksLength || 0) + properties.yaxisLabelsOffsetx - 5,\n                        y:      y + properties.yaxisLabelsOffsety,\n                        text:   String(properties.yaxisScaleInvert ? scale.labels[i] : scale.labels[scale.labels.length - 1 - i]),\n                        valign: typeof properties.yaxisLabelsValign === 'string' ? properties.yaxisLabelsValign : valign,\n                        halign: typeof properties.yaxisLabelsHalign === 'string' ? properties.yaxisLabelsHalign : (properties.yaxisPosition === 'right' ? 'left' : halign),\n                        marker: false,\n                        angle:  angle,\n                        tag:    'yaxis.labels'\n                    });\n                }\n                    \n                    \n\n                var zerolabel = RGraph.numberFormat({\n                    object:    obj,\n                    number:    properties.yaxisScaleMin.toFixed(properties.yaxisScaleDecimals),\n                    unitspre:  properties.yaxisScaleUnitsPre,\n                    unitspost: properties.yaxisScaleUnitsPost,\n                    point:     properties.yaxisScalePoint,\n                    thousand:  properties.yaxisScaleThousand\n                });\n\n                //\n                // Draw the zero label\n                //\n                RGraph.text({\n                  object:   obj,\n          textConfPrefix:   'yaxisLabels',\n                    x:      properties.yaxisPosition === 'right' ? x + 5 + (properties.yaxisTickmarksLength || 0) + properties.yaxisLabelsOffsetx : x - 5 - (properties.yaxisTickmarksLength || 0) + properties.yaxisLabelsOffsetx,\n                    y:      properties.yaxisScaleInvert ? properties.marginTop : obj.canvas.height - properties.marginBottom + properties.yaxisLabelsOffsety,\n                    text:   typeof properties.yaxisScaleFormatter === 'function'\n                                ? (properties.yaxisScaleFormatter)({object: this,number: 0,unitspre: properties.yaxisScaleUnitsPre,unitspost: properties.yaxisScaleUnitsPost,point: properties.yaxisScalePoint,thousand: properties.yaxisScaleThousand,formatter: properties.yaxisScaleFormatter})\n                                : zerolabel,\n                    valign: typeof properties.yaxisLabelsValign === 'string' ? properties.yaxisLabelsValign : valign,\n                    halign: typeof properties.yaxisLabelsHalign === 'string' ? properties.yaxisLabelsHalign : (properties.yaxisPosition === 'right' ? 'left' : halign),\n                    marker: false,\n                    angle:  angle,\n                    tag:    'yaxis.labels'\n                });\n            }\n        \n        //\n        // Draw labels instead of a scale\n        //\n        } else if (properties.yaxisLabelsSpecific && properties.yaxisLabelsSpecific.length && (properties.yaxisLabelsPosition === 'section' || properties.yaxisLabelsPosition === 'edge') ) {\n\n            var section        = (obj.canvas.height - properties.marginTop - properties.marginBottom) / (properties.yaxisLabelsSpecific.length - (properties.yaxisLabelsPosition === 'section' ? 0 : 1));\n            obj.maxLabelLength = 0;\n\n            for (var i=0; i<properties.yaxisLabelsSpecific.length; ++i) {\n\n                var y = properties.marginTop  + (section * i) + (properties.yaxisLabelsPosition === 'section' ? section / 2 : 0);\n\n                var ret = RGraph.text({\n                  object:   obj,\n          textConfPrefix:   'yaxisLabels',\n                    x:      obj.type === 'drawing.yaxis'\n                                ? (properties.yaxisPosition === 'right' ? obj.x + 7 + properties.yaxisLabelsOffsetx : obj.x - 5 + properties.yaxisLabelsOffsetx)\n                                : (properties.yaxisPosition === 'right' ? x + properties.yaxisLabelsOffsetx + 5 : properties.marginLeft - 5 + properties.yaxisLabelsOffsetx),\n                    y:      y + properties.yaxisLabelsOffsety,\n                    text:   String(properties.yaxisLabelsSpecific[i] || ''),\n                    valign: typeof properties.yaxisLabelsValign === 'string' ? properties.yaxisLabelsValign : 'center',\n                    halign: typeof properties.yaxisLabelsHalign === 'string' ? properties.yaxisLabelsHalign : (properties.yaxisPosition === 'right' ? 'left' : 'right'),\n                    marker: false,\n                    tag:    'yaxis.labels',\n               cssClass:    RGraph.getLabelsCSSClassName({\n                                object: obj,\n                                  name: 'yaxisLabelsClass',\n                                 index: i\n                              })\n                });\n\n                obj.maxLabelLength = Math.max(\n                    obj.maxLabelLength,\n                    obj.context.measureText(String(properties.yaxisLabelsSpecific[i])).width * 2\n                );\n            }\n        }\n\n\n\n\n\n\n\n\n\n\n\n\n\n        //\n        // Draw the title\n        //\n        if (properties.yaxisTitle) {\n\n            //\n            // Get the text width of the labels so that the position of the title\n            // can be adjusted\n            //\n            if (obj.type === 'gantt') {\n                for (var i=0, maxLabelLength=0; i<properties.yaxisLabels.length;++i) {\n                \n                    var textConf = RGraph.getTextConf({\n                        object: obj,\n                        prefix: 'yaxisLabels'\n                    });\n\n                    maxLabelLength = Math.max(maxLabelLength, RGraph.measureText(\n                        properties.yaxisLabels[i],\n                        textConf.bold,\n                        textConf.font,\n                        textConf.size\n                    )[0]);\n                }\n            } else if (obj.scale2 && obj.scale2.labels) {\n\n                var textConf = RGraph.getTextConf({\n                    object: obj,\n                    prefix: 'yaxisLabels'\n                });\n\n                var maxLabelLength = RGraph.measureText(\n                    obj.scale2.labels[obj.scale2.labels.length - 1],\n                    textConf.bold,\n                    textConf.font,\n                    textConf.size\n                )[0];\n            }\n\n\n            // If the chart is an HBar chart then the maximum length of the labels\n            // needs to be calculated so that the title doesn't overlap them\n            if (\n                    (obj.type === 'hbar' && properties.yaxisLabels && properties.yaxisLabels.length)\n                 || (obj.type === 'drawing.yaxis' && properties.yaxisLabelsSpecific && properties.yaxisLabelsSpecific.length)\n               ) {\n                maxLabelLength = (function (labels)\n                {\n                    var textConf = RGraph.getTextConf({\n                        object: obj,\n                        prefix: 'yaxisLabels'\n                    });\n\n                    for (var i=0,max=0; i<labels.length; ++i) {\n                        var dim = RGraph.measureText(\n                            labels[i],\n                            textConf.bold,\n                            textConf.font,\n                            textConf.size\n                        );\n                        max = Math.max(max, dim[0]);\n                    }\n\n                    return max;\n                })(obj.type === 'drawing.yaxis' ? properties.yaxisLabelsSpecific : properties.yaxisLabels);\n            }\n\n            var x = properties.yaxisPosition === 'right' ? (obj.canvas.width - properties.marginRight) + 5 + maxLabelLength + 10 : properties.marginLeft - 5 - maxLabelLength - 10;\n            var y = ((obj.canvas.height - properties.marginTop - properties.marginBottom) / 2) + properties.marginTop;\n            \n            if (obj.type === 'drawing.yaxis') {\n                var x = properties.yaxisPosition === 'right'\n                            ? obj.x + 5 + maxLabelLength + 10\n                            : obj.x - 5 - maxLabelLength - 10;\n            }\n\n\n            // The yaxisTitlePos property\n            if (typeof properties.yaxisTitlePos === 'number') {\n                if (properties.yaxisPosition === 'right') {\n                    x = obj.canvas.width - (properties.marginRight * properties.yaxisTitlePos);\n                } else {\n                    x = properties.marginLeft * properties.yaxisTitlePos;\n                }\n            }\n\n            // Specific X and Y coordinates for the title\n            if (typeof properties.yaxisTitleOffsetx === 'number') x += properties.yaxisTitleOffsetx;\n            if (typeof properties.yaxisTitleOffsety === 'number') y += properties.yaxisTitleOffsety;\n\n            // Specific X and Y coordinates for the title\n            if (typeof properties.yaxisTitleX === 'number') x = properties.yaxisTitleX;\n            if (typeof properties.yaxisTitleY === 'number') y = properties.yaxisTitleY;\n\n\n\n            RGraph.text({\n              object:       obj,\n            textConfPrefix: 'yaxisTitle',\n                x:          x,\n                y:          y,\n                text:       properties.yaxisTitle.toString(),\n                valign:     properties.yaxisTitleValign || 'bottom',\n                halign:     properties.yaxisTitleHalign || 'center',\n                marker:     false,\n                accessible: typeof properties.yaxisTitleAccessible === 'boolean' ? properties.yaxisTitleAccessible : undefined,\n                angle:      -45,\n                angle:      properties.yaxisPosition === 'right' ? 90 : -90,\n                tag:        'yaxis.title'\n            });\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // Returns the CSS className for labels\n    //\n    // @param object object The RGraph object\n    // @param string name   The name of the property you wish to set\n    //\n    RGraph.getLabelsCSSClassName = function ()\n    {\n        var args       = RGraph.getArgs(arguments, 'object,name,index');\n        var properties = args.object.properties;\n        var value      = '';\n\n        if (typeof properties[args.name] === 'string') {\n            value = properties[args.name];\n        } else {\n            if (typeof properties[args.name] === 'object' && typeof properties[args.name][args.index] === 'string') {\n                value = properties[args.name][args.index];\n            }\n        }\n\n        return value;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Label substitution. This allows you to use dynamic\n    // labels if you want like this:\n    //\n    // ...\n    // names: ['Richard','Jerry','Lucy'],\n    // xaxisLabels: '%{names:[%{index}]}: %{value_formatted}'\n    // ...\n    //\n    //@param object args This can be an object which contains the following\n    //                   things:\n    //                           args.text      The text on which to perform the substitution on\n    //                                          (ie the original label)\n    //                           args.object    The chart object\n    //                           args.index     The index of the label\n    //                           args.value     The value of the data point\n    //                           args.decimals  The number of decimals\n    //                           args.point     The decimal character\n    //                           args.thousand  The thousand separator\n    //                           args.unitsPre  The units that are prepended to the number\n    //                           args.unitsPost The units that are appended to the number\n    //                          \n    //\n    RGraph.labelSubstitution = function (args)\n    {\n          //////////////////////\n         // Must be a string //\n        //////////////////////\n        var text = String(args.text);\n\n          /////////////////////////////////////////////////////////////////\n         // If there's no template tokens in the string simply reurn it //\n        /////////////////////////////////////////////////////////////////\n        if (!text.match(/%{.*?}/)) {\n            return text;\n        }\n\n          //////////////////////////////////////////\n         // This allows for escaping the percent //\n        //////////////////////////////////////////\n        var text = text.replace(/%%/g, '___--PERCENT--___');\n\n\n\n\n\n          ////////////////////////////////////\n         // Replace the index of the label //\n        ////////////////////////////////////\n        text = text.replace(/%{index}/g, args.index);\n\n\n\n          ////////////////////////////////////////////////////////////////////\n         // Do property substitution when there's an index to the property //\n        ////////////////////////////////////////////////////////////////////\n        var reg = /%{prop(?:erty)?:([_a-z0-9]+)\\[([0-9]+)\\]}/i;\n\n        while (text.match(reg)) {\n\n            var property = RegExp.$1,\n                index    = parseInt(RegExp.$2);\n\n            if (args.object.properties[property]) {\n                text = text.replace(\n                    reg,\n                    args.object.properties[property][index] || ''\n                );\n\n            // Get rid of the text if there was nothing to replace the template bit with\n            } else {\n                text = text.replace(reg,'');\n            }\n                \n            RegExp.lastIndex = null;\n        }\n\n\n          ////////////////////////////////////\n         // Replace this: %{property:xxx}% //\n        ////////////////////////////////////\n        while (text.match(/%{property:([_a-z0-9]+)}/i)) {\n            var str = '%{property:' + RegExp.$1 + '}';\n            text    = text.replace(str, args.object.properties[RegExp.$1]);\n        }\n\n\n\n         ////////////////////////////////\n        // Replace this: %{prop:xxx}% //\n        ///////////////////////////////\n        while (text.match(/%{prop:([_a-z0-9]+)}/i)) {\n            var str = '%{prop:' + RegExp.$1 + '}';\n            text    = text.replace(str, args.object.properties[RegExp.$1]);\n        }\n\n\n\n          /////////////////////////////////////////////////////////\n         // Replace this: %{value} and this: %{value_formatted} //\n        ////////////////////////////////////////////////////////\n        while (text.match(/%{value(?:_formatted)?}/i)) {\n            \n            var value = args.value;\n\n            if (text.match(/%{value_formatted}/i)) {\n                text = text.replace(\n                    '%{value_formatted}',\n                    typeof value === 'number' ? RGraph.numberFormat({\n                        object:    args.object,\n                        number:    value.toFixed(args.decimals),\n                        thousand:  args.thousand  || ',',\n                        point:     args.point     || '.',\n                        unitspre:  args.unitsPre  || '',\n                        unitspost: args.unitsPost || ''\n                    }) : null\n                );\n            } else {\n                text = text.replace('%{value}', value);\n            }\n        }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n          ////////////////////////////////////////////////////////////////\n         // Do global substitution when there's an index to the global //\n        ////////////////////////////////////////////////////////////////\n        var reg = /%{global:([_a-z0-9.]+)\\[([0-9]+)\\]}/i;\n\n        while (text.match(reg)) {\n\n            var name  = RegExp.$1,\n                index = parseInt(RegExp.$2);\n\n            if (eval(name)[index]) {\n                text = text.replace(\n                    reg,\n                    eval(name)[index] || ''\n                );\n\n            // Get rid of the text if there was nothing to replace the template bit with\n            } else {\n                text = text.replace(reg,'');\n            }\n                \n            RegExp.lastIndex = null;\n        }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n          //////////////////////////////////////////////////\n         // Do global substitution when there's no index //\n        //////////////////////////////////////////////////\n        var reg = /%{global:([_a-z0-9.]+)}/i;\n\n        while (text.match(reg)) {\n\n            var name = RegExp.$1;\n\n            if (eval(name)) {\n                text = text.replace(\n                    reg,\n                    eval(name) || ''\n                );\n\n            // Get rid of the text if there was nothing to replace the template bit with\n            } else {\n                text = text.replace(reg,'');\n            }\n                \n            RegExp.lastIndex = null;\n        }\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n\n\n        ///////////////////////////////////\n        // And lastly - call any functions\n        // MUST be last\n        //////////////////////////////////\n        var regexp = /%{function:([_A-Za-z0-9]+)\\((.*?)\\)}/;\n        \n        // Temporarily replace carriage returns and line feeds with CR and LF\n        // so the the s option is not needed\n        text = text.replace(/\\r/,'|CR|');\n        text = text.replace(/\\n/,'|LF|');\n\n        while (text.match(regexp)) {\n\n            var str  = RegExp.$1 + '(' + RegExp.$2 + ')';\n            \n            for (var i=0,len=str.length; i<len; ++i) {\n                str  = str.replace(/\\r?\\n/, \"\\\\n\");\n            }\n            \n            RGraph.Registry.set('label-templates-function-object', args.object);\n\n            var func = new Function ('return ' + str);\n            var ret  = func();\n\n            text = text.replace(regexp, ret)\n        }\n\n\n\n\n\n\n\n        // Replace line returns with br tags\n        text = text.replace(/\\r?\\n/g, '<br />');\n        text = text.replace(/___--PERCENT--___/g, '%')\n\n        // Replace CR and LF with the relevant character\n        text = text.replace(/\\|CR\\|/, '\\r');\n        text = text.replace(/\\|LF\\|/, '\\n');\n\n\n        return text.toString();\n    };\n\n\n\n\n\n\n\n\n    //\n    // This splits a basic comma separated value string\n    // into JSON.\n    //\n    // @param  string str The string to split\n    // @return object     The resulting JSON object\n    //\n    RGraph.splitString = function (str)\n    {\n        var re = new RegExp('([\"\\'a-z0-9]+) *= *', 'ig');\n        str = str.replace(re, '\"$1\":');\n\n        str = str.replace(/\"\"/g, '\"');\n        str = str.replace(/''/g, '\"');\n        str = str.replace(/:'/g, ':\"');\n        str = str.replace(/' *,/g, '\",');\n        str = str.trim().replace(/,$/, '');\n\n        var ret = JSON.parse('{' + str + '}');\n\n        return ret;\n    };\n\n\n\n\n\n\n\n\n    //\n    // A set of functions which help you get data from the GET\n    // string (the query string).\n    //\n    RGraph.GET.raw = function ()\n    {\n        return location.search;\n    };\n\n\n\n\n\n\n\n\n    RGraph.GET.parse = function ()\n    {\n        if (!RGraph.isNull(RGraph.GET.__parts__)) {\n            return RGraph.GET.__parts__;\n        }\n\n        var raw   = RGraph.GET.raw().replace(/^\\?/, '');\n        var parts = raw.split(/\\&/);\n        \n        // Loop thru each part splitting it\n        for (var i=0; i<parts.length; ++i) {\n            var tmp = parts[i].split('=');\n\n            parts[tmp[0]] = decodeURI(tmp[1]);\n        }\n        \n        // Store the parsed query-string\n        RGraph.GET.__parts__ = parts;\n        \n        return parts;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Get a string of text from the query string. No special\n    // processing is done here.\n    //\n    // @param string key The part to get\n    //\n    RGraph.GET.text =\n    RGraph.GET.string = function (key)\n    {\n        var parts = RGraph.GET.parse();\n        \n        if (!parts[key]) {\n            return null;\n        }\n\n        return String(parts[key]);\n    };\n\n\n\n\n\n\n\n\n    //\n    //  This fetches a number from the query string. It\n    // trims leading zeros and reurns a number (not a\n    // string).\n    //\n    // @param string key The part to get \n    //\n    RGraph.GET.number = function (key)\n    {\n        var parts = RGraph.GET.parse();\n        \n        if (!parts[key]) {\n            return null;\n        }\n\n        return Number(parts[key]);\n    };\n\n\n\n\n\n\n\n\n    //\n    // Fetches a JSON object from the query string. It must be\n    // valid JSON and is an easy way to pass multiple values\n    //using the query string. For example:\n    //\n    // /foo.html?json={\"data\":[4,8,6],\"labels\":[\"John\",\"Luis\",\"Bob\"]}\n    // \n    // @param string key The part to get\n    //\n    RGraph.GET.json =\n    RGraph.GET.object = function (key)\n    {\n        var parts = RGraph.GET.parse();\n        \n        if (!parts[key]) {\n            return null;\n        }\n\n        return JSON.parse(parts[key]);\n    };\n\n\n\n\n\n\n\n\n    //\n    // This allows you to easily pass a  list of numbers over the\n    // query string. For example:\n    //\n    // /test.html?data=5,8,6,3,5,4,6\n    //\n    // @param string key      The part to get\n    // @param string OPTIONAL The seperator to use (defaults to a\n    //                        comma)\n    //\n    RGraph.GET.list  =\n    RGraph.GET.array = function (key)\n    {\n        var parts = RGraph.GET.parse();\n        \n        if (!parts[key]) {\n            return null;\n        }\n        \n        \n        if (!arguments[1]) {\n            var sep = ',';\n        } else {\n            var sep = arguments[1];\n        }\n        \n        var arr = parts[key].split(sep);\n        \n        // Remove any starting or trailing square brackets\n        arr[0] = arr[0].replace(/^\\[/, '');\n        arr[arr.length - 1] = arr[arr.length - 1].replace(/\\]$/, '');\n\n        // Convert strings to numbers\n        for (var i=0; i<arr.length; ++i) {\n            \n            // Get rid of surrounding quotes\n            arr[i] = arr[i].replace(/^('|\")/,'');\n            arr[i] = arr[i].replace(/('|\")$/,'');\n\n            if (Number(arr[i])) {\n                arr[i] = Number(arr[i]);\n            }\n        }\n\n        return arr;\n    };\n\n\n\n\n\n\n\n\n    // Some utility functions that help identify the type of an object\n    //\n    // Note that isUndefined() should be used like this or you'll get an\n    // error (with the window. prefix):\n    //\n    //        RGraph.isUndefined(window.foo)\n    //\n    RGraph.isString    = function (obj){return typeof obj === 'string';};\n    RGraph.isNumber    = function (obj){return typeof obj === 'number';};\n    RGraph.isBool      =\n    RGraph.isBoolean   = function (obj){return typeof obj === 'boolean';};\n    //RGraph.isArray Defined above\n    RGraph.isObject    = function(obj){return (obj && typeof obj === 'object' && obj.constructor.toString().toLowerCase().indexOf('object') > 0) ? true : false;};\n    //RGraph.isNull  Defined above\n    RGraph.isFunction  = function (obj){return typeof obj === 'function';};\n    RGraph.isUndefined = function (obj){return typeof obj === 'undefined';};\n\n\n\n\n\n\n\n\n// End module pattern\n})(window, document);\n\n\n\n\n\n\n\n\n    //\n    // Uses the alert() function to show the structure of the given variable\n    // \n    // @param mixed v The variable to print/alert the structure of\n    //\n    window.$p = function (v)\n    {\n        RGraph.pr(arguments[0], arguments[1], arguments[3]);\n    };\n\n\n\n\n\n\n\n\n    //\n    // A shorthand for the default alert() function\n    //\n    // @param mixed v The variable to alert\n    //\n    window.$a = function (v)\n    {\n        alert(v);\n    };\n\n\n\n\n\n\n\n\n    //\n    // Short-hand for console.log\n    // \n    // @param mixed v The variable to log to the console\n    //\n    window.$c  =\n    window.$cl = function (v)\n    {\n        return console.log(v);\n    };\n\n\n\n\n\n\n\n\n    //\n    // A debug function that takes the message that you give and if a textarea output\n    // window doesn't yet exists creates one and prepends the msg to it.\n    // \n    // @param mixed v The variable to log to the window\n    //\n    window.$d = function (m)\n    {\n        var width  = 600;\n        var height = 600;\n\n        // Create the debug window if necessary\n        if (!this.rgraph_debug_textarea) {\n                this.rgraph_debug_textarea = document.createElement('textarea');\n                this.rgraph_debug_textarea.style.position = 'fixed';\n                this.rgraph_debug_textarea.style.left     = '10px';\n                this.rgraph_debug_textarea.style.top      = '10px';\n                this.rgraph_debug_textarea.style.width    = width + 'px';\n                this.rgraph_debug_textarea.style.height   = height + 'px';\n                this.rgraph_debug_textarea.style.opacity  = '0.25';\n                this.rgraph_debug_textarea.style.zIndex   = '99999';\n                this.rgraph_debug_textarea.style.border   = '2px solid black';\n                this.rgraph_debug_textarea.style.backgroundColor = 'yellow'\n                this.rgraph_debug_textarea.style.color = 'black';\n                this.rgraph_debug_textarea.style.fontSize = '16pt';\n                this.rgraph_debug_textarea.style.fontWeight = 'bold';\n                this.rgraph_debug_textarea.wrap = 'off';\n            document.body.appendChild(this.rgraph_debug_textarea);\n            \n            // Restore the W/H coords from localstorage\n            if  (window.localStorage.rgraph_debug_textarea_w) this.rgraph_debug_textarea.style.width   = window.localStorage.rgraph_debug_textarea_w;\n            if  (window.localStorage.rgraph_debug_textarea_h) this.rgraph_debug_textarea.style.height  = window.localStorage.rgraph_debug_textarea_h;\n\n            this.rgraph_debug_textarea.onmouseover   = function (e) {e.target.style.opacity = 1;};\n            this.rgraph_debug_textarea.onmousedown   = function (e) {if (e.ctrlKey) {e.preventDefault();e.stopPropagation();this.mousedown = true;this.pickupX = e.offsetX;this.pickupY = e.offsetY; return false;}};\n            this.rgraph_debug_textarea.onmouseout    = function (e) {this.style.opacity = 0.25;};\n            this.rgraph_debug_textarea.ondblclick = function (e)\n            {\n                if (confirm('Clear the log?')) {\n                    this.value = '';\n                }\n            };\n            \n            window.onmouseup = function (e) {this.rgraph_debug_textarea.mousedown = false;};\n            window.addEventListener('mousemove', function (e)\n            {\n                if (this.rgraph_debug_textarea.mousedown) {\n                    window.localStorage.rgraph_debug_textarea_w = this.rgraph_debug_textarea.offsetWidth + 'px';\n                    window.localStorage.rgraph_debug_textarea_h = this.rgraph_debug_textarea.offsetHeight + 'px';\n                }\n            }, false);\n        }\n        \n        \n        // Create a timestamp and log it to the textarea\n        var date = new Date();\n        var hour = date.getHours();\n        var min  = date.getMinutes();\n            min  = String(min).length === 1 ? '0' + min : min;\n        var sec  = date.getSeconds();\n            sec  = String(sec).length === 1 ? '0' + sec : sec;\n\n\n        //\n        // Handles circular references\n        //\n        function  getCircularReplacer()\n        {\n            var seen = [];\n            \n            return function (key, value)\n            {\n                if (typeof value === 'object' && value !== null) {\n                    \n                    // Loop thru the seen array and check that the object is not in there already\n                    for (var i=0; i<seen.length; ++i) {\n                        if (seen[i] === value) {\n                            return;\n                        }\n                    }\n\n                    seen.push(value);\n                }\n\n                return value;\n            };\n        };\n\n        // Add the message to the debug window\n        this.rgraph_debug_textarea.value = \"[%1:%2:%3] %4\\r\\n%5\".format(\n            hour,\n            min,\n            sec,\n            JSON.stringify(m, getCircularReplacer()),\n            this.rgraph_debug_textarea.value\n        );\n    };\n\n\n\n\n\n\n\n\n    //\n    // A basic string formatting function. Use it like this:\n    // \n    // var str = '{0} {1} {2}'.format('a', 'b', 'c');\n    // \n    // Outputs: a b c\n    //\n    // @param ... Replacements to use in the string\n    //\n    String.prototype.format = function()\n    {\n        //\n        // Allow for this type of formatting: {myVar} $myVar $myVar$ %myVar% [myVar]\n        //\n        if (arguments.length === 0) {\n        \n            var s = this;\n        \n            // Allow for {myVar} style\n            if (s.match(/{[a-z0-9]+?}/i)) {\n                var s = this.replace(/{[a-z0-9]+?}/gi, function(str, idx)\n                {\n                    str = str.substr(1)\n                    str = str.substr(0, str.length - 1)\n    \n                    return window[str];\n                });\n            }\n\n            return s;\n        }\n\n\n\n\n        var args = arguments;\n        \n        for (var i in args) {\n            if (RGraph.isNull(args[i])) {\n                args[i] = 'null';\n            }\n        }\n\n        var s = this.replace(/{(\\d+)}/g, function(str, idx)\n        {\n          return typeof args[idx - 1] !== 'undefined' ? args[idx - 1] : str;\n        });\n\n        \n        // Save percentage signs that are escaped with either another\n        // percent or a backslash\n        s = s.replace(/(?:%|\\\\)%(\\d)/g,'__PPEERRCCEENNTT__$1');\n\n        s = s.replace(/%(\\d+)/g, function(str, idx)\n        {\n          return typeof args[idx - 1] !== 'undefined' ? args[idx - 1] : str;\n        });\n\n        // Now replace those saved percentage signs with a percentage sign\n        return s.replace('__PPEERRCCEENNTT__', '%');\n    };",["58","59"],"C:\\Users\\Michael Wilke\\Desktop\\Scout\\frontend\\src\\components\\RGraph.bar.js",["60","61","62","63","64","65","66","67","68","69","70","71","72","73","74","75","76","77","78","79","80","81","82","83","84","85","86","87","88","89","90","91","92","93","94","95","96","97","98","99","100","101","102","103","104","105","106","107","108","109","110","111","112","113","114","115","116","117","118","119","120","121","122","123","124","125","126","127","128","129","130","131","132","133","134","135","136","137","138","139","140","141","142","143","144","145","146","147","148","149","150","151","152","153","154","155","156","157","158","159","160","161","162","163","164","165","166","167","168","169","170","171","172","173","174","175","176","177","178","179","180","181","182","183","184","185","186","187","188","189","190","191","192","193","194","195","196","197","198","199","200","201","202","203","204","205","206","207","208","209","210","211","212","213","214","215","216","217","218","219","220","221","222","223","224","225","226","227","228","229","230","231","232","233","234","235","236","237","238","239","240","241","242","243","244","245","246","247","248","249","250","251","252","253","254","255","256","257","258","259","260","261","262","263","264","265","266","267","268","269","270","271","272","273","274","275","276","277","278","279","280","281","282","283","284","285","286","287","288","289","290","291","292","293","294","295","296","297","298","299","300","301","302","303","304","305","306","307","308","309","310","311","312","313","314","315","316","317","318","319","320","321","322","323","324","325","326","327","328","329","330","331","332","333","334","335","336","337","338","339","340","341","342","343","344","345","346","347","348","349","350","351","352","353","354","355","356","357","358","359","360","361","362","363","364","365","366","367","368","369","370","371","372","373","374","375","376"],[],{"ruleId":"377","replacedBy":"378"},{"ruleId":"379","replacedBy":"380"},{"ruleId":"381","severity":1,"message":"382","line":2,"column":35,"nodeType":"383","messageId":"384","endLine":2,"endColumn":40},{"ruleId":"381","severity":1,"message":"385","line":2,"column":42,"nodeType":"383","messageId":"384","endLine":2,"endColumn":48},{"ruleId":"381","severity":1,"message":"386","line":5,"column":8,"nodeType":"383","messageId":"384","endLine":5,"endColumn":17},{"ruleId":"381","severity":1,"message":"387","line":6,"column":8,"nodeType":"383","messageId":"384","endLine":6,"endColumn":13},{"ruleId":"388","severity":1,"message":"389","line":13,"column":11,"nodeType":"390","endLine":13,"endColumn":61},{"ruleId":"381","severity":1,"message":"391","line":23,"column":7,"nodeType":"383","messageId":"384","endLine":23,"endColumn":11},{"ruleId":"381","severity":1,"message":"392","line":6,"column":7,"nodeType":"383","messageId":"384","endLine":6,"endColumn":16},{"ruleId":"377","replacedBy":"393"},{"ruleId":"379","replacedBy":"394"},{"ruleId":null,"fatal":true,"severity":2,"message":"395","line":6704,"column":12},{"ruleId":"377","replacedBy":"396"},{"ruleId":"379","replacedBy":"397"},{"ruleId":"398","severity":2,"message":"399","line":12,"column":5,"nodeType":"383","messageId":"400","endLine":12,"endColumn":11},{"ruleId":"398","severity":2,"message":"399","line":17,"column":5,"nodeType":"383","messageId":"400","endLine":17,"endColumn":11},{"ruleId":"398","severity":2,"message":"399","line":34,"column":39,"nodeType":"383","messageId":"400","endLine":34,"endColumn":45},{"ruleId":"398","severity":2,"message":"399","line":35,"column":75,"nodeType":"383","messageId":"400","endLine":35,"endColumn":81},{"ruleId":"401","severity":1,"message":"402","line":151,"column":13,"nodeType":"403","messageId":"404","endLine":151,"endColumn":33},{"ruleId":"398","severity":2,"message":"399","line":339,"column":16,"nodeType":"383","messageId":"400","endLine":339,"endColumn":22},{"ruleId":"398","severity":2,"message":"399","line":348,"column":49,"nodeType":"383","messageId":"400","endLine":348,"endColumn":55},{"ruleId":"398","severity":2,"message":"399","line":357,"column":27,"nodeType":"383","messageId":"400","endLine":357,"endColumn":33},{"ruleId":"405","severity":1,"message":"406","line":359,"column":18,"nodeType":"383","messageId":"407","endLine":359,"endColumn":19},{"ruleId":"398","severity":2,"message":"399","line":366,"column":30,"nodeType":"383","messageId":"400","endLine":366,"endColumn":36},{"ruleId":"398","severity":2,"message":"399","line":380,"column":25,"nodeType":"383","messageId":"400","endLine":380,"endColumn":31},{"ruleId":"398","severity":2,"message":"399","line":388,"column":26,"nodeType":"383","messageId":"400","endLine":388,"endColumn":32},{"ruleId":"398","severity":2,"message":"399","line":393,"column":13,"nodeType":"383","messageId":"400","endLine":393,"endColumn":19},{"ruleId":"398","severity":2,"message":"399","line":393,"column":38,"nodeType":"383","messageId":"400","endLine":393,"endColumn":44},{"ruleId":"398","severity":2,"message":"399","line":394,"column":13,"nodeType":"383","messageId":"400","endLine":394,"endColumn":19},{"ruleId":"398","severity":2,"message":"399","line":400,"column":27,"nodeType":"383","messageId":"400","endLine":400,"endColumn":33},{"ruleId":"398","severity":2,"message":"399","line":471,"column":13,"nodeType":"383","messageId":"400","endLine":471,"endColumn":19},{"ruleId":"398","severity":2,"message":"399","line":486,"column":17,"nodeType":"383","messageId":"400","endLine":486,"endColumn":23},{"ruleId":"408","severity":1,"message":"409","line":561,"column":40,"nodeType":"410","messageId":"404","endLine":561,"endColumn":42},{"ruleId":"408","severity":1,"message":"409","line":561,"column":75,"nodeType":"410","messageId":"404","endLine":561,"endColumn":77},{"ruleId":"398","severity":2,"message":"399","line":590,"column":13,"nodeType":"383","messageId":"400","endLine":590,"endColumn":19},{"ruleId":"398","severity":2,"message":"399","line":621,"column":17,"nodeType":"383","messageId":"400","endLine":621,"endColumn":23},{"ruleId":"398","severity":2,"message":"399","line":633,"column":17,"nodeType":"383","messageId":"400","endLine":633,"endColumn":23},{"ruleId":"398","severity":2,"message":"399","line":653,"column":17,"nodeType":"383","messageId":"400","endLine":653,"endColumn":23},{"ruleId":"398","severity":2,"message":"399","line":662,"column":13,"nodeType":"383","messageId":"400","endLine":662,"endColumn":19},{"ruleId":"398","severity":2,"message":"399","line":670,"column":13,"nodeType":"383","messageId":"400","endLine":670,"endColumn":19},{"ruleId":"398","severity":2,"message":"399","line":678,"column":17,"nodeType":"383","messageId":"400","endLine":678,"endColumn":23},{"ruleId":"398","severity":2,"message":"399","line":686,"column":13,"nodeType":"383","messageId":"400","endLine":686,"endColumn":19},{"ruleId":"398","severity":2,"message":"399","line":723,"column":17,"nodeType":"383","messageId":"400","endLine":723,"endColumn":23},{"ruleId":"408","severity":1,"message":"409","line":723,"column":33,"nodeType":"410","messageId":"404","endLine":723,"endColumn":35},{"ruleId":"398","severity":2,"message":"399","line":733,"column":46,"nodeType":"383","messageId":"400","endLine":733,"endColumn":52},{"ruleId":"398","severity":2,"message":"399","line":743,"column":49,"nodeType":"383","messageId":"400","endLine":743,"endColumn":55},{"ruleId":"398","severity":2,"message":"399","line":759,"column":13,"nodeType":"383","messageId":"400","endLine":759,"endColumn":19},{"ruleId":"398","severity":2,"message":"399","line":764,"column":13,"nodeType":"383","messageId":"400","endLine":764,"endColumn":19},{"ruleId":"381","severity":1,"message":"411","line":783,"column":17,"nodeType":"383","messageId":"384","endLine":783,"endColumn":22},{"ruleId":"381","severity":1,"message":"412","line":784,"column":17,"nodeType":"383","messageId":"384","endLine":784,"endColumn":22},{"ruleId":"381","severity":1,"message":"413","line":785,"column":17,"nodeType":"383","messageId":"384","endLine":785,"endColumn":25},{"ruleId":"398","severity":2,"message":"399","line":793,"column":31,"nodeType":"383","messageId":"400","endLine":793,"endColumn":37},{"ruleId":"398","severity":2,"message":"399","line":825,"column":73,"nodeType":"383","messageId":"400","endLine":825,"endColumn":79},{"ruleId":"405","severity":1,"message":"414","line":844,"column":29,"nodeType":"383","messageId":"407","endLine":844,"endColumn":34},{"ruleId":"398","severity":2,"message":"399","line":844,"column":80,"nodeType":"383","messageId":"400","endLine":844,"endColumn":86},{"ruleId":"398","severity":2,"message":"399","line":844,"column":126,"nodeType":"383","messageId":"400","endLine":844,"endColumn":132},{"ruleId":"405","severity":1,"message":"414","line":847,"column":29,"nodeType":"383","messageId":"407","endLine":847,"endColumn":34},{"ruleId":"398","severity":2,"message":"399","line":856,"column":37,"nodeType":"383","messageId":"400","endLine":856,"endColumn":43},{"ruleId":"398","severity":2,"message":"399","line":869,"column":31,"nodeType":"383","messageId":"400","endLine":869,"endColumn":37},{"ruleId":"398","severity":2,"message":"399","line":896,"column":17,"nodeType":"383","messageId":"400","endLine":896,"endColumn":23},{"ruleId":"398","severity":2,"message":"399","line":905,"column":17,"nodeType":"383","messageId":"400","endLine":905,"endColumn":23},{"ruleId":"381","severity":1,"message":"415","line":915,"column":17,"nodeType":"383","messageId":"384","endLine":915,"endColumn":28},{"ruleId":"416","severity":1,"message":"417","line":915,"column":33,"nodeType":"383","messageId":"418","endLine":915,"endColumn":39},{"ruleId":"398","severity":2,"message":"419","line":946,"column":22,"nodeType":"383","messageId":"400","endLine":946,"endColumn":25},{"ruleId":"398","severity":2,"message":"419","line":946,"column":46,"nodeType":"383","messageId":"400","endLine":946,"endColumn":49},{"ruleId":"398","severity":2,"message":"399","line":954,"column":21,"nodeType":"383","messageId":"400","endLine":954,"endColumn":27},{"ruleId":"405","severity":1,"message":"420","line":955,"column":25,"nodeType":"383","messageId":"407","endLine":955,"endColumn":31},{"ruleId":"398","severity":2,"message":"399","line":955,"column":35,"nodeType":"383","messageId":"400","endLine":955,"endColumn":41},{"ruleId":"405","severity":1,"message":"420","line":957,"column":25,"nodeType":"383","messageId":"407","endLine":957,"endColumn":31},{"ruleId":"398","severity":2,"message":"399","line":957,"column":35,"nodeType":"383","messageId":"400","endLine":957,"endColumn":41},{"ruleId":"408","severity":1,"message":"409","line":968,"column":34,"nodeType":"410","messageId":"404","endLine":968,"endColumn":36},{"ruleId":"408","severity":1,"message":"409","line":972,"column":30,"nodeType":"410","messageId":"404","endLine":972,"endColumn":32},{"ruleId":"408","severity":1,"message":"409","line":1035,"column":37,"nodeType":"410","messageId":"404","endLine":1035,"endColumn":39},{"ruleId":"381","severity":1,"message":"421","line":1039,"column":33,"nodeType":"383","messageId":"384","endLine":1039,"endColumn":45},{"ruleId":"408","severity":1,"message":"409","line":1084,"column":57,"nodeType":"410","messageId":"404","endLine":1084,"endColumn":59},{"ruleId":"408","severity":1,"message":"409","line":1095,"column":44,"nodeType":"410","messageId":"404","endLine":1095,"endColumn":46},{"ruleId":"408","severity":1,"message":"409","line":1095,"column":64,"nodeType":"410","messageId":"404","endLine":1095,"endColumn":66},{"ruleId":"408","severity":1,"message":"409","line":1095,"column":83,"nodeType":"410","messageId":"404","endLine":1095,"endColumn":85},{"ruleId":"408","severity":1,"message":"409","line":1095,"column":105,"nodeType":"410","messageId":"404","endLine":1095,"endColumn":107},{"ruleId":"408","severity":1,"message":"409","line":1097,"column":41,"nodeType":"410","messageId":"404","endLine":1097,"endColumn":43},{"ruleId":"398","severity":2,"message":"399","line":1098,"column":33,"nodeType":"383","messageId":"400","endLine":1098,"endColumn":39},{"ruleId":"408","severity":1,"message":"409","line":1155,"column":41,"nodeType":"410","messageId":"404","endLine":1155,"endColumn":43},{"ruleId":"408","severity":1,"message":"409","line":1258,"column":48,"nodeType":"410","messageId":"404","endLine":1258,"endColumn":50},{"ruleId":"408","severity":1,"message":"409","line":1277,"column":44,"nodeType":"410","messageId":"404","endLine":1277,"endColumn":46},{"ruleId":"408","severity":1,"message":"409","line":1349,"column":103,"nodeType":"410","messageId":"404","endLine":1349,"endColumn":105},{"ruleId":"405","severity":1,"message":"422","line":1355,"column":29,"nodeType":"383","messageId":"407","endLine":1355,"endColumn":37},{"ruleId":"408","severity":1,"message":"409","line":1370,"column":42,"nodeType":"410","messageId":"404","endLine":1370,"endColumn":44},{"ruleId":"405","severity":1,"message":"420","line":1397,"column":33,"nodeType":"383","messageId":"407","endLine":1397,"endColumn":39},{"ruleId":"408","severity":1,"message":"409","line":1400,"column":42,"nodeType":"410","messageId":"404","endLine":1400,"endColumn":44},{"ruleId":"381","severity":1,"message":"423","line":1404,"column":33,"nodeType":"383","messageId":"384","endLine":1404,"endColumn":44},{"ruleId":"398","severity":2,"message":"399","line":1404,"column":48,"nodeType":"383","messageId":"400","endLine":1404,"endColumn":54},{"ruleId":"408","severity":1,"message":"409","line":1447,"column":35,"nodeType":"410","messageId":"404","endLine":1447,"endColumn":37},{"ruleId":"405","severity":1,"message":"424","line":1448,"column":37,"nodeType":"383","messageId":"407","endLine":1448,"endColumn":43},{"ruleId":"408","severity":1,"message":"409","line":1462,"column":41,"nodeType":"410","messageId":"404","endLine":1462,"endColumn":43},{"ruleId":"405","severity":1,"message":"425","line":1464,"column":37,"nodeType":"383","messageId":"407","endLine":1464,"endColumn":50},{"ruleId":"405","severity":1,"message":"426","line":1465,"column":37,"nodeType":"383","messageId":"407","endLine":1465,"endColumn":52},{"ruleId":"408","severity":1,"message":"409","line":1469,"column":39,"nodeType":"410","messageId":"404","endLine":1469,"endColumn":41},{"ruleId":"408","severity":1,"message":"409","line":1493,"column":39,"nodeType":"410","messageId":"404","endLine":1493,"endColumn":41},{"ruleId":"398","severity":2,"message":"399","line":1533,"column":29,"nodeType":"383","messageId":"400","endLine":1533,"endColumn":35},{"ruleId":"398","severity":2,"message":"427","line":1535,"column":34,"nodeType":"383","messageId":"400","endLine":1535,"endColumn":35},{"ruleId":"398","severity":2,"message":"427","line":1535,"column":39,"nodeType":"383","messageId":"400","endLine":1535,"endColumn":40},{"ruleId":"398","severity":2,"message":"427","line":1535,"column":64,"nodeType":"383","messageId":"400","endLine":1535,"endColumn":65},{"ruleId":"398","severity":2,"message":"427","line":1537,"column":71,"nodeType":"383","messageId":"400","endLine":1537,"endColumn":72},{"ruleId":"398","severity":2,"message":"427","line":1538,"column":70,"nodeType":"383","messageId":"400","endLine":1538,"endColumn":71},{"ruleId":"398","severity":2,"message":"427","line":1538,"column":90,"nodeType":"383","messageId":"400","endLine":1538,"endColumn":91},{"ruleId":"398","severity":2,"message":"427","line":1538,"column":110,"nodeType":"383","messageId":"400","endLine":1538,"endColumn":111},{"ruleId":"398","severity":2,"message":"427","line":1538,"column":130,"nodeType":"383","messageId":"400","endLine":1538,"endColumn":131},{"ruleId":"398","severity":2,"message":"427","line":1539,"column":68,"nodeType":"383","messageId":"400","endLine":1539,"endColumn":69},{"ruleId":"398","severity":2,"message":"427","line":1539,"column":88,"nodeType":"383","messageId":"400","endLine":1539,"endColumn":89},{"ruleId":"398","severity":2,"message":"427","line":1539,"column":108,"nodeType":"383","messageId":"400","endLine":1539,"endColumn":109},{"ruleId":"398","severity":2,"message":"427","line":1539,"column":128,"nodeType":"383","messageId":"400","endLine":1539,"endColumn":129},{"ruleId":"408","severity":1,"message":"409","line":1574,"column":103,"nodeType":"410","messageId":"404","endLine":1574,"endColumn":105},{"ruleId":"405","severity":1,"message":"428","line":1576,"column":29,"nodeType":"383","messageId":"407","endLine":1576,"endColumn":41},{"ruleId":"405","severity":1,"message":"420","line":1595,"column":33,"nodeType":"383","messageId":"407","endLine":1595,"endColumn":39},{"ruleId":"405","severity":1,"message":"429","line":1597,"column":33,"nodeType":"383","messageId":"407","endLine":1597,"endColumn":39},{"ruleId":"408","severity":1,"message":"409","line":1607,"column":42,"nodeType":"410","messageId":"404","endLine":1607,"endColumn":44},{"ruleId":"408","severity":1,"message":"409","line":1614,"column":42,"nodeType":"410","messageId":"404","endLine":1614,"endColumn":44},{"ruleId":"405","severity":1,"message":"424","line":1615,"column":37,"nodeType":"383","messageId":"407","endLine":1615,"endColumn":43},{"ruleId":"405","severity":1,"message":"420","line":1616,"column":37,"nodeType":"383","messageId":"407","endLine":1616,"endColumn":43},{"ruleId":"408","severity":1,"message":"409","line":1618,"column":49,"nodeType":"410","messageId":"404","endLine":1618,"endColumn":51},{"ruleId":"405","severity":1,"message":"424","line":1619,"column":37,"nodeType":"383","messageId":"407","endLine":1619,"endColumn":43},{"ruleId":"405","severity":1,"message":"424","line":1622,"column":37,"nodeType":"383","messageId":"407","endLine":1622,"endColumn":43},{"ruleId":"405","severity":1,"message":"420","line":1623,"column":37,"nodeType":"383","messageId":"407","endLine":1623,"endColumn":43},{"ruleId":"408","severity":1,"message":"409","line":1661,"column":41,"nodeType":"410","messageId":"404","endLine":1661,"endColumn":43},{"ruleId":"405","severity":1,"message":"425","line":1663,"column":37,"nodeType":"383","messageId":"407","endLine":1663,"endColumn":50},{"ruleId":"405","severity":1,"message":"426","line":1664,"column":37,"nodeType":"383","messageId":"407","endLine":1664,"endColumn":52},{"ruleId":"398","severity":2,"message":"399","line":1801,"column":29,"nodeType":"383","messageId":"400","endLine":1801,"endColumn":35},{"ruleId":"405","severity":1,"message":"430","line":1806,"column":42,"nodeType":"383","messageId":"407","endLine":1806,"endColumn":43},{"ruleId":"398","severity":2,"message":"399","line":1828,"column":17,"nodeType":"383","messageId":"400","endLine":1828,"endColumn":23},{"ruleId":"398","severity":2,"message":"399","line":1838,"column":13,"nodeType":"383","messageId":"400","endLine":1838,"endColumn":19},{"ruleId":"398","severity":2,"message":"399","line":1882,"column":27,"nodeType":"383","messageId":"400","endLine":1882,"endColumn":33},{"ruleId":"381","severity":1,"message":"431","line":1885,"column":17,"nodeType":"383","messageId":"384","endLine":1885,"endColumn":23},{"ruleId":"381","severity":1,"message":"432","line":1886,"column":17,"nodeType":"383","messageId":"384","endLine":1886,"endColumn":24},{"ruleId":"408","severity":1,"message":"409","line":1891,"column":42,"nodeType":"410","messageId":"404","endLine":1891,"endColumn":44},{"ruleId":"398","severity":2,"message":"399","line":1911,"column":35,"nodeType":"383","messageId":"400","endLine":1911,"endColumn":41},{"ruleId":"398","severity":2,"message":"399","line":1928,"column":48,"nodeType":"383","messageId":"400","endLine":1928,"endColumn":54},{"ruleId":"398","severity":2,"message":"399","line":1929,"column":39,"nodeType":"383","messageId":"400","endLine":1929,"endColumn":45},{"ruleId":"381","severity":1,"message":"431","line":1988,"column":17,"nodeType":"383","messageId":"384","endLine":1988,"endColumn":23},{"ruleId":"398","severity":2,"message":"399","line":1989,"column":31,"nodeType":"383","messageId":"400","endLine":1989,"endColumn":37},{"ruleId":"408","severity":1,"message":"409","line":2002,"column":42,"nodeType":"410","messageId":"404","endLine":2002,"endColumn":44},{"ruleId":"381","severity":1,"message":"433","line":2007,"column":21,"nodeType":"383","messageId":"384","endLine":2007,"endColumn":27},{"ruleId":"398","severity":2,"message":"399","line":2016,"column":39,"nodeType":"383","messageId":"400","endLine":2016,"endColumn":45},{"ruleId":"398","severity":2,"message":"399","line":2016,"column":65,"nodeType":"383","messageId":"400","endLine":2016,"endColumn":71},{"ruleId":"398","severity":2,"message":"399","line":2019,"column":35,"nodeType":"383","messageId":"400","endLine":2019,"endColumn":41},{"ruleId":"408","severity":1,"message":"409","line":2059,"column":28,"nodeType":"410","messageId":"404","endLine":2059,"endColumn":30},{"ruleId":"398","severity":2,"message":"399","line":2063,"column":35,"nodeType":"383","messageId":"400","endLine":2063,"endColumn":41},{"ruleId":"405","severity":1,"message":"434","line":2064,"column":21,"nodeType":"383","messageId":"407","endLine":2064,"endColumn":27},{"ruleId":"405","severity":1,"message":"435","line":2065,"column":21,"nodeType":"383","messageId":"407","endLine":2065,"endColumn":27},{"ruleId":"408","severity":1,"message":"409","line":2076,"column":42,"nodeType":"410","messageId":"404","endLine":2076,"endColumn":44},{"ruleId":"408","severity":1,"message":"409","line":2086,"column":49,"nodeType":"410","messageId":"404","endLine":2086,"endColumn":51},{"ruleId":"405","severity":1,"message":"414","line":2087,"column":21,"nodeType":"383","messageId":"407","endLine":2087,"endColumn":26},{"ruleId":"405","severity":1,"message":"414","line":2091,"column":21,"nodeType":"383","messageId":"407","endLine":2091,"endColumn":26},{"ruleId":"408","severity":1,"message":"409","line":2122,"column":26,"nodeType":"410","messageId":"404","endLine":2122,"endColumn":28},{"ruleId":"408","severity":1,"message":"409","line":2132,"column":33,"nodeType":"410","messageId":"404","endLine":2132,"endColumn":35},{"ruleId":"398","severity":2,"message":"399","line":2200,"column":21,"nodeType":"383","messageId":"400","endLine":2200,"endColumn":27},{"ruleId":"398","severity":2,"message":"399","line":2217,"column":27,"nodeType":"383","messageId":"400","endLine":2217,"endColumn":33},{"ruleId":"381","severity":1,"message":"436","line":2218,"column":17,"nodeType":"383","messageId":"384","endLine":2218,"endColumn":22},{"ruleId":"398","severity":2,"message":"399","line":2257,"column":42,"nodeType":"383","messageId":"400","endLine":2257,"endColumn":48},{"ruleId":"398","severity":2,"message":"399","line":2257,"column":78,"nodeType":"383","messageId":"400","endLine":2257,"endColumn":84},{"ruleId":"408","severity":1,"message":"409","line":2257,"column":115,"nodeType":"410","messageId":"404","endLine":2257,"endColumn":117},{"ruleId":"398","severity":2,"message":"399","line":2261,"column":31,"nodeType":"383","messageId":"400","endLine":2261,"endColumn":37},{"ruleId":"398","severity":2,"message":"399","line":2265,"column":21,"nodeType":"383","messageId":"400","endLine":2265,"endColumn":27},{"ruleId":"408","severity":1,"message":"409","line":2267,"column":70,"nodeType":"410","messageId":"404","endLine":2267,"endColumn":72},{"ruleId":"398","severity":2,"message":"399","line":2269,"column":39,"nodeType":"383","messageId":"400","endLine":2269,"endColumn":45},{"ruleId":"398","severity":2,"message":"399","line":2273,"column":37,"nodeType":"383","messageId":"400","endLine":2273,"endColumn":43},{"ruleId":"398","severity":2,"message":"399","line":2281,"column":21,"nodeType":"383","messageId":"400","endLine":2281,"endColumn":27},{"ruleId":"398","severity":2,"message":"399","line":2282,"column":21,"nodeType":"383","messageId":"400","endLine":2282,"endColumn":27},{"ruleId":"398","severity":2,"message":"399","line":2301,"column":62,"nodeType":"383","messageId":"400","endLine":2301,"endColumn":68},{"ruleId":"398","severity":2,"message":"399","line":2302,"column":62,"nodeType":"383","messageId":"400","endLine":2302,"endColumn":68},{"ruleId":"405","severity":1,"message":"437","line":2325,"column":17,"nodeType":"383","messageId":"407","endLine":2325,"endColumn":23},{"ruleId":"405","severity":1,"message":"406","line":2327,"column":26,"nodeType":"383","messageId":"407","endLine":2327,"endColumn":27},{"ruleId":"398","severity":2,"message":"399","line":2383,"column":28,"nodeType":"383","messageId":"400","endLine":2383,"endColumn":34},{"ruleId":"398","severity":2,"message":"399","line":2393,"column":38,"nodeType":"383","messageId":"400","endLine":2393,"endColumn":44},{"ruleId":"398","severity":2,"message":"399","line":2396,"column":49,"nodeType":"383","messageId":"400","endLine":2396,"endColumn":55},{"ruleId":"408","severity":1,"message":"409","line":2415,"column":37,"nodeType":"410","messageId":"404","endLine":2415,"endColumn":39},{"ruleId":"398","severity":2,"message":"399","line":2427,"column":33,"nodeType":"383","messageId":"400","endLine":2427,"endColumn":39},{"ruleId":"405","severity":1,"message":"406","line":2454,"column":26,"nodeType":"383","messageId":"407","endLine":2454,"endColumn":27},{"ruleId":"405","severity":1,"message":"438","line":2457,"column":29,"nodeType":"383","messageId":"407","endLine":2457,"endColumn":30},{"ruleId":"405","severity":1,"message":"439","line":2458,"column":29,"nodeType":"383","messageId":"407","endLine":2458,"endColumn":30},{"ruleId":"405","severity":1,"message":"440","line":2459,"column":29,"nodeType":"383","messageId":"407","endLine":2459,"endColumn":30},{"ruleId":"405","severity":1,"message":"441","line":2460,"column":29,"nodeType":"383","messageId":"407","endLine":2460,"endColumn":30},{"ruleId":"408","severity":1,"message":"409","line":2482,"column":42,"nodeType":"410","messageId":"404","endLine":2482,"endColumn":44},{"ruleId":"408","severity":1,"message":"409","line":2482,"column":64,"nodeType":"410","messageId":"404","endLine":2482,"endColumn":66},{"ruleId":"442","severity":1,"message":"443","line":2486,"column":37,"nodeType":"383","messageId":"444","endLine":2486,"endColumn":38},{"ruleId":"398","severity":2,"message":"399","line":2557,"column":17,"nodeType":"383","messageId":"400","endLine":2557,"endColumn":23},{"ruleId":"381","severity":1,"message":"445","line":2576,"column":17,"nodeType":"383","messageId":"384","endLine":2576,"endColumn":21},{"ruleId":"381","severity":1,"message":"446","line":2577,"column":17,"nodeType":"383","messageId":"384","endLine":2577,"endColumn":23},{"ruleId":"381","severity":1,"message":"447","line":2578,"column":17,"nodeType":"383","messageId":"384","endLine":2578,"endColumn":22},{"ruleId":"381","severity":1,"message":"448","line":2579,"column":17,"nodeType":"383","messageId":"384","endLine":2579,"endColumn":21},{"ruleId":"381","severity":1,"message":"449","line":2580,"column":17,"nodeType":"383","messageId":"384","endLine":2580,"endColumn":21},{"ruleId":"381","severity":1,"message":"450","line":2589,"column":17,"nodeType":"383","messageId":"384","endLine":2589,"endColumn":23},{"ruleId":"381","severity":1,"message":"451","line":2592,"column":17,"nodeType":"383","messageId":"384","endLine":2592,"endColumn":22},{"ruleId":"398","severity":2,"message":"399","line":2592,"column":31,"nodeType":"383","messageId":"400","endLine":2592,"endColumn":37},{"ruleId":"381","severity":1,"message":"452","line":2595,"column":17,"nodeType":"383","messageId":"384","endLine":2595,"endColumn":28},{"ruleId":"381","severity":1,"message":"453","line":2596,"column":17,"nodeType":"383","messageId":"384","endLine":2596,"endColumn":26},{"ruleId":"381","severity":1,"message":"454","line":2597,"column":17,"nodeType":"383","messageId":"384","endLine":2597,"endColumn":27},{"ruleId":"381","severity":1,"message":"455","line":2598,"column":17,"nodeType":"383","messageId":"384","endLine":2598,"endColumn":26},{"ruleId":"381","severity":1,"message":"456","line":2599,"column":17,"nodeType":"383","messageId":"384","endLine":2599,"endColumn":26},{"ruleId":"398","severity":2,"message":"399","line":2607,"column":28,"nodeType":"383","messageId":"400","endLine":2607,"endColumn":34},{"ruleId":"398","severity":2,"message":"399","line":2613,"column":13,"nodeType":"383","messageId":"400","endLine":2613,"endColumn":19},{"ruleId":"405","severity":1,"message":"457","line":2626,"column":29,"nodeType":"383","messageId":"407","endLine":2626,"endColumn":34},{"ruleId":"398","severity":2,"message":"399","line":2630,"column":25,"nodeType":"383","messageId":"400","endLine":2630,"endColumn":31},{"ruleId":"398","severity":2,"message":"399","line":2642,"column":82,"nodeType":"383","messageId":"400","endLine":2642,"endColumn":88},{"ruleId":"405","severity":1,"message":"457","line":2674,"column":29,"nodeType":"383","messageId":"407","endLine":2674,"endColumn":34},{"ruleId":"405","severity":1,"message":"458","line":2675,"column":29,"nodeType":"383","messageId":"407","endLine":2675,"endColumn":35},{"ruleId":"405","severity":1,"message":"459","line":2676,"column":29,"nodeType":"383","messageId":"407","endLine":2676,"endColumn":35},{"ruleId":"398","severity":2,"message":"399","line":2679,"column":25,"nodeType":"383","messageId":"400","endLine":2679,"endColumn":31},{"ruleId":"398","severity":2,"message":"399","line":2691,"column":82,"nodeType":"383","messageId":"400","endLine":2691,"endColumn":88},{"ruleId":"405","severity":1,"message":"457","line":2725,"column":37,"nodeType":"383","messageId":"407","endLine":2725,"endColumn":42},{"ruleId":"405","severity":1,"message":"458","line":2726,"column":37,"nodeType":"383","messageId":"407","endLine":2726,"endColumn":43},{"ruleId":"405","severity":1,"message":"459","line":2728,"column":37,"nodeType":"383","messageId":"407","endLine":2728,"endColumn":43},{"ruleId":"408","severity":1,"message":"460","line":2729,"column":52,"nodeType":"410","messageId":"404","endLine":2729,"endColumn":54},{"ruleId":"398","severity":2,"message":"399","line":2731,"column":33,"nodeType":"383","messageId":"400","endLine":2731,"endColumn":39},{"ruleId":"398","severity":2,"message":"399","line":2743,"column":104,"nodeType":"383","messageId":"400","endLine":2743,"endColumn":110},{"ruleId":"405","severity":1,"message":"406","line":2777,"column":26,"nodeType":"383","messageId":"407","endLine":2777,"endColumn":27},{"ruleId":"405","severity":1,"message":"461","line":2777,"column":30,"nodeType":"383","messageId":"407","endLine":2777,"endColumn":33},{"ruleId":"405","severity":1,"message":"462","line":2777,"column":46,"nodeType":"383","messageId":"407","endLine":2777,"endColumn":61},{"ruleId":"405","severity":1,"message":"457","line":2780,"column":29,"nodeType":"383","messageId":"407","endLine":2780,"endColumn":34},{"ruleId":"405","severity":1,"message":"458","line":2781,"column":29,"nodeType":"383","messageId":"407","endLine":2781,"endColumn":35},{"ruleId":"408","severity":1,"message":"460","line":2781,"column":44,"nodeType":"410","messageId":"404","endLine":2781,"endColumn":46},{"ruleId":"405","severity":1,"message":"459","line":2782,"column":29,"nodeType":"383","messageId":"407","endLine":2782,"endColumn":35},{"ruleId":"408","severity":1,"message":"460","line":2782,"column":44,"nodeType":"410","messageId":"404","endLine":2782,"endColumn":46},{"ruleId":"398","severity":2,"message":"399","line":2784,"column":25,"nodeType":"383","messageId":"400","endLine":2784,"endColumn":31},{"ruleId":"398","severity":2,"message":"399","line":2796,"column":92,"nodeType":"383","messageId":"400","endLine":2796,"endColumn":98},{"ruleId":"398","severity":2,"message":"399","line":2798,"column":74,"nodeType":"383","messageId":"400","endLine":2798,"endColumn":80},{"ruleId":"398","severity":2,"message":"399","line":2799,"column":74,"nodeType":"383","messageId":"400","endLine":2799,"endColumn":80},{"ruleId":"405","severity":1,"message":"457","line":2824,"column":29,"nodeType":"383","messageId":"407","endLine":2824,"endColumn":34},{"ruleId":"405","severity":1,"message":"458","line":2825,"column":29,"nodeType":"383","messageId":"407","endLine":2825,"endColumn":35},{"ruleId":"408","severity":1,"message":"460","line":2825,"column":44,"nodeType":"410","messageId":"404","endLine":2825,"endColumn":46},{"ruleId":"405","severity":1,"message":"459","line":2826,"column":29,"nodeType":"383","messageId":"407","endLine":2826,"endColumn":35},{"ruleId":"408","severity":1,"message":"460","line":2826,"column":44,"nodeType":"410","messageId":"404","endLine":2826,"endColumn":46},{"ruleId":"398","severity":2,"message":"399","line":2828,"column":25,"nodeType":"383","messageId":"400","endLine":2828,"endColumn":31},{"ruleId":"398","severity":2,"message":"399","line":2840,"column":96,"nodeType":"383","messageId":"400","endLine":2840,"endColumn":102},{"ruleId":"398","severity":2,"message":"399","line":2914,"column":34,"nodeType":"383","messageId":"400","endLine":2914,"endColumn":40},{"ruleId":"398","severity":2,"message":"399","line":2939,"column":13,"nodeType":"383","messageId":"400","endLine":2939,"endColumn":19},{"ruleId":"398","severity":2,"message":"399","line":2959,"column":41,"nodeType":"383","messageId":"400","endLine":2959,"endColumn":47},{"ruleId":"398","severity":2,"message":"399","line":2974,"column":92,"nodeType":"383","messageId":"400","endLine":2974,"endColumn":98},{"ruleId":"398","severity":2,"message":"399","line":2974,"column":138,"nodeType":"383","messageId":"400","endLine":2974,"endColumn":144},{"ruleId":"398","severity":2,"message":"399","line":2983,"column":25,"nodeType":"383","messageId":"400","endLine":2983,"endColumn":31},{"ruleId":"398","severity":2,"message":"399","line":2988,"column":21,"nodeType":"383","messageId":"400","endLine":2988,"endColumn":27},{"ruleId":"398","severity":2,"message":"399","line":2989,"column":21,"nodeType":"383","messageId":"400","endLine":2989,"endColumn":27},{"ruleId":"463","severity":2,"message":"464","line":3021,"column":17,"nodeType":"465","messageId":"466","endLine":3022,"endColumn":57},{"ruleId":"467","severity":1,"message":"468","line":3021,"column":37,"nodeType":"469","messageId":"470","endLine":3021,"endColumn":38},{"ruleId":"398","severity":2,"message":"471","line":3022,"column":17,"nodeType":"383","messageId":"400","endLine":3022,"endColumn":23},{"ruleId":"398","severity":2,"message":"471","line":3026,"column":17,"nodeType":"383","messageId":"400","endLine":3026,"endColumn":23},{"ruleId":"398","severity":2,"message":"471","line":3028,"column":17,"nodeType":"383","messageId":"400","endLine":3028,"endColumn":23},{"ruleId":"398","severity":2,"message":"399","line":3028,"column":27,"nodeType":"383","messageId":"400","endLine":3028,"endColumn":33},{"ruleId":"398","severity":2,"message":"471","line":3028,"column":43,"nodeType":"383","messageId":"400","endLine":3028,"endColumn":49},{"ruleId":"398","severity":2,"message":"471","line":3028,"column":68,"nodeType":"383","messageId":"400","endLine":3028,"endColumn":74},{"ruleId":"398","severity":2,"message":"471","line":3028,"column":75,"nodeType":"383","messageId":"400","endLine":3028,"endColumn":81},{"ruleId":"398","severity":2,"message":"399","line":3034,"column":34,"nodeType":"383","messageId":"400","endLine":3034,"endColumn":40},{"ruleId":"398","severity":2,"message":"471","line":3048,"column":34,"nodeType":"383","messageId":"400","endLine":3048,"endColumn":40},{"ruleId":"398","severity":2,"message":"471","line":3049,"column":55,"nodeType":"383","messageId":"400","endLine":3049,"endColumn":61},{"ruleId":"398","severity":2,"message":"471","line":3052,"column":25,"nodeType":"383","messageId":"400","endLine":3052,"endColumn":31},{"ruleId":"398","severity":2,"message":"471","line":3059,"column":25,"nodeType":"383","messageId":"400","endLine":3059,"endColumn":31},{"ruleId":"398","severity":2,"message":"471","line":3059,"column":37,"nodeType":"383","messageId":"400","endLine":3059,"endColumn":43},{"ruleId":"398","severity":2,"message":"399","line":3067,"column":21,"nodeType":"383","messageId":"400","endLine":3067,"endColumn":27},{"ruleId":"398","severity":2,"message":"399","line":3068,"column":21,"nodeType":"383","messageId":"400","endLine":3068,"endColumn":27},{"ruleId":"398","severity":2,"message":"399","line":3105,"column":17,"nodeType":"383","messageId":"400","endLine":3105,"endColumn":23},{"ruleId":"472","severity":1,"message":"473","line":3112,"column":96,"nodeType":"474","messageId":"475","endLine":3112,"endColumn":97,"suggestions":"476"},{"ruleId":"472","severity":1,"message":"473","line":3122,"column":90,"nodeType":"474","messageId":"475","endLine":3122,"endColumn":91,"suggestions":"477"},{"ruleId":"398","severity":2,"message":"399","line":3135,"column":29,"nodeType":"383","messageId":"400","endLine":3135,"endColumn":35},{"ruleId":"405","severity":1,"message":"478","line":3151,"column":21,"nodeType":"383","messageId":"407","endLine":3151,"endColumn":25},{"ruleId":"405","severity":1,"message":"406","line":3153,"column":26,"nodeType":"383","messageId":"407","endLine":3153,"endColumn":27},{"ruleId":"398","severity":2,"message":"399","line":3154,"column":25,"nodeType":"383","messageId":"400","endLine":3154,"endColumn":31},{"ruleId":"398","severity":2,"message":"399","line":3155,"column":56,"nodeType":"383","messageId":"400","endLine":3155,"endColumn":62},{"ruleId":"398","severity":2,"message":"399","line":3157,"column":32,"nodeType":"383","messageId":"400","endLine":3157,"endColumn":38},{"ruleId":"405","severity":1,"message":"430","line":3159,"column":34,"nodeType":"383","messageId":"407","endLine":3159,"endColumn":35},{"ruleId":"398","severity":2,"message":"399","line":3163,"column":56,"nodeType":"383","messageId":"400","endLine":3163,"endColumn":62},{"ruleId":"405","severity":1,"message":"479","line":3170,"column":21,"nodeType":"383","messageId":"407","endLine":3170,"endColumn":26},{"ruleId":"398","severity":2,"message":"399","line":3170,"column":29,"nodeType":"383","messageId":"400","endLine":3170,"endColumn":35},{"ruleId":"398","severity":2,"message":"399","line":3183,"column":40,"nodeType":"383","messageId":"400","endLine":3183,"endColumn":46},{"ruleId":"398","severity":2,"message":"399","line":3187,"column":61,"nodeType":"383","messageId":"400","endLine":3187,"endColumn":67},{"ruleId":"405","severity":1,"message":"480","line":3201,"column":33,"nodeType":"383","messageId":"407","endLine":3201,"endColumn":37},{"ruleId":"398","severity":2,"message":"399","line":3211,"column":17,"nodeType":"383","messageId":"400","endLine":3211,"endColumn":23},{"ruleId":"398","severity":2,"message":"399","line":3219,"column":21,"nodeType":"383","messageId":"400","endLine":3219,"endColumn":27},{"ruleId":"398","severity":2,"message":"399","line":3227,"column":25,"nodeType":"383","messageId":"400","endLine":3227,"endColumn":31},{"ruleId":"398","severity":2,"message":"399","line":3229,"column":43,"nodeType":"383","messageId":"400","endLine":3229,"endColumn":49},{"ruleId":"398","severity":2,"message":"399","line":3241,"column":41,"nodeType":"383","messageId":"400","endLine":3241,"endColumn":47},{"ruleId":"398","severity":2,"message":"399","line":3248,"column":25,"nodeType":"383","messageId":"400","endLine":3248,"endColumn":31},{"ruleId":"381","severity":1,"message":"481","line":3274,"column":22,"nodeType":"383","messageId":"384","endLine":3274,"endColumn":23},{"ruleId":"416","severity":1,"message":"482","line":3282,"column":17,"nodeType":"383","messageId":"418","endLine":3282,"endColumn":26},{"ruleId":"398","severity":2,"message":"399","line":3299,"column":38,"nodeType":"383","messageId":"400","endLine":3299,"endColumn":44},{"ruleId":"398","severity":2,"message":"399","line":3302,"column":74,"nodeType":"383","messageId":"400","endLine":3302,"endColumn":80},{"ruleId":"483","severity":1,"message":"484","line":3336,"column":63,"nodeType":"485","messageId":"486","endLine":3336,"endColumn":65},{"ruleId":"483","severity":1,"message":"484","line":3336,"column":83,"nodeType":"485","messageId":"486","endLine":3336,"endColumn":85},{"ruleId":"483","severity":1,"message":"484","line":3338,"column":63,"nodeType":"485","messageId":"486","endLine":3338,"endColumn":65},{"ruleId":"483","severity":1,"message":"484","line":3338,"column":84,"nodeType":"485","messageId":"486","endLine":3338,"endColumn":86},{"ruleId":"483","severity":1,"message":"484","line":3340,"column":63,"nodeType":"485","messageId":"486","endLine":3340,"endColumn":65},{"ruleId":"483","severity":1,"message":"484","line":3340,"column":83,"nodeType":"485","messageId":"486","endLine":3340,"endColumn":85},{"ruleId":"483","severity":1,"message":"484","line":3342,"column":63,"nodeType":"485","messageId":"486","endLine":3342,"endColumn":65},{"ruleId":"483","severity":1,"message":"484","line":3342,"column":84,"nodeType":"485","messageId":"486","endLine":3342,"endColumn":86},{"ruleId":"398","severity":2,"message":"399","line":3346,"column":65,"nodeType":"383","messageId":"400","endLine":3346,"endColumn":71},{"ruleId":"398","severity":2,"message":"399","line":3365,"column":26,"nodeType":"383","messageId":"400","endLine":3365,"endColumn":32},{"ruleId":"398","severity":2,"message":"399","line":3423,"column":17,"nodeType":"383","messageId":"400","endLine":3423,"endColumn":23},{"ruleId":"398","severity":2,"message":"399","line":3423,"column":62,"nodeType":"383","messageId":"400","endLine":3423,"endColumn":68},{"ruleId":"398","severity":2,"message":"399","line":3427,"column":17,"nodeType":"383","messageId":"400","endLine":3427,"endColumn":23},{"ruleId":"398","severity":2,"message":"399","line":3446,"column":27,"nodeType":"383","messageId":"400","endLine":3446,"endColumn":33},{"ruleId":"398","severity":2,"message":"399","line":3480,"column":27,"nodeType":"383","messageId":"400","endLine":3480,"endColumn":33},{"ruleId":"398","severity":2,"message":"399","line":3486,"column":30,"nodeType":"383","messageId":"400","endLine":3486,"endColumn":36},{"ruleId":"381","severity":1,"message":"487","line":3511,"column":17,"nodeType":"383","messageId":"384","endLine":3511,"endColumn":18},{"ruleId":"398","severity":2,"message":"399","line":3514,"column":30,"nodeType":"383","messageId":"400","endLine":3514,"endColumn":36},{"ruleId":"398","severity":2,"message":"488","line":3515,"column":17,"nodeType":"383","messageId":"400","endLine":3515,"endColumn":23},{"ruleId":"398","severity":2,"message":"488","line":3520,"column":19,"nodeType":"383","messageId":"400","endLine":3520,"endColumn":25},{"ruleId":"398","severity":2,"message":"488","line":3522,"column":20,"nodeType":"383","messageId":"400","endLine":3522,"endColumn":26},{"ruleId":"398","severity":2,"message":"488","line":3528,"column":19,"nodeType":"383","messageId":"400","endLine":3528,"endColumn":25},{"ruleId":"398","severity":2,"message":"488","line":3538,"column":28,"nodeType":"383","messageId":"400","endLine":3538,"endColumn":34},{"ruleId":"381","severity":1,"message":"489","line":3539,"column":21,"nodeType":"383","messageId":"384","endLine":3539,"endColumn":24},{"ruleId":"398","severity":2,"message":"488","line":3539,"column":28,"nodeType":"383","messageId":"400","endLine":3539,"endColumn":34},{"ruleId":"398","severity":2,"message":"488","line":3552,"column":24,"nodeType":"383","messageId":"400","endLine":3552,"endColumn":30},{"ruleId":"398","severity":2,"message":"399","line":3709,"column":9,"nodeType":"383","messageId":"400","endLine":3709,"endColumn":15},{"ruleId":"398","severity":2,"message":"399","line":3718,"column":9,"nodeType":"383","messageId":"400","endLine":3718,"endColumn":15},{"ruleId":"398","severity":2,"message":"399","line":3735,"column":5,"nodeType":"383","messageId":"400","endLine":3735,"endColumn":11},{"ruleId":"398","severity":2,"message":"399","line":3743,"column":13,"nodeType":"383","messageId":"400","endLine":3743,"endColumn":19},{"ruleId":"405","severity":1,"message":"406","line":3751,"column":18,"nodeType":"383","messageId":"407","endLine":3751,"endColumn":19},{"ruleId":"408","severity":1,"message":"409","line":3765,"column":38,"nodeType":"410","messageId":"404","endLine":3765,"endColumn":40},{"ruleId":"398","severity":2,"message":"399","line":3807,"column":13,"nodeType":"383","messageId":"400","endLine":3807,"endColumn":19},{"ruleId":"398","severity":2,"message":"399","line":3827,"column":5,"nodeType":"383","messageId":"400","endLine":3827,"endColumn":11},{"ruleId":"398","severity":2,"message":"399","line":3844,"column":5,"nodeType":"383","messageId":"400","endLine":3844,"endColumn":11},{"ruleId":"398","severity":2,"message":"399","line":3846,"column":13,"nodeType":"383","messageId":"400","endLine":3846,"endColumn":19},{"ruleId":"490","severity":1,"message":"491","line":3852,"column":90,"nodeType":"492","messageId":"404","endLine":3852,"endColumn":94},{"ruleId":"398","severity":2,"message":"399","line":3878,"column":5,"nodeType":"383","messageId":"400","endLine":3878,"endColumn":11},{"ruleId":"398","severity":2,"message":"399","line":3886,"column":22,"nodeType":"383","messageId":"400","endLine":3886,"endColumn":28},{"ruleId":"398","severity":2,"message":"493","line":3890,"column":14,"nodeType":"383","messageId":"400","endLine":3890,"endColumn":15},{"ruleId":"398","severity":2,"message":"493","line":3892,"column":33,"nodeType":"383","messageId":"400","endLine":3892,"endColumn":34},{"ruleId":"398","severity":2,"message":"493","line":3892,"column":58,"nodeType":"383","messageId":"400","endLine":3892,"endColumn":59},{"ruleId":"398","severity":2,"message":"399","line":3901,"column":31,"nodeType":"383","messageId":"400","endLine":3901,"endColumn":37},{"ruleId":"398","severity":2,"message":"399","line":3903,"column":19,"nodeType":"383","messageId":"400","endLine":3903,"endColumn":25},{"ruleId":"401","severity":1,"message":"494","line":3910,"column":17,"nodeType":"403","messageId":"404","endLine":3910,"endColumn":22},{"ruleId":"401","severity":1,"message":"495","line":3911,"column":17,"nodeType":"403","messageId":"404","endLine":3911,"endColumn":22},{"ruleId":"398","severity":2,"message":"399","line":3917,"column":31,"nodeType":"383","messageId":"400","endLine":3917,"endColumn":37},"no-native-reassign",["496"],"no-negated-in-lhs",["497"],"no-unused-vars","'Route' is defined but never used.","Identifier","unusedVar","'Switch' is defined but never used.","'graphCard' is defined but never used.","'graph' is defined but never used.","jsx-a11y/alt-text","img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","JSXOpeningElement","'Home' is assigned a value but never used.","'useStyles' is assigned a value but never used.",["496"],["497"],"Parsing error: Binding 'arguments' in strict mode. (6704:12)",["496"],["497"],"no-undef","'RGraph' is not defined.","undef","no-dupe-keys","Duplicate key 'yaxisTitleAccessible'.","ObjectExpression","unexpected","no-redeclare","'i' is already defined.","redeclared","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","'prevX' is assigned a value but never used.","'prevY' is assigned a value but never used.","'decimals' is assigned a value but never used.","'value' is already defined.","'orig_height' is assigned a value but never used.","no-use-before-define","'height' was used before it was defined.","usedBeforeDefined","'len' is not defined.","'height' is already defined.","'sketchOffset' is assigned a value but never used.","'barWidth' is already defined.","'totalHeight' is assigned a value but never used.","'startY' is already defined.","'prevFillStyle' is already defined.","'prevStrokeStyle' is already defined.","'k' is not defined.","'redrawCoords' is already defined.","'startX' is already defined.","'j' is already defined.","'canvas' is assigned a value but never used.","'context' is assigned a value but never used.","'mouseY' is assigned a value but never used.","'mouseX' is already defined.","'mouseY' is already defined.","'shape' is assigned a value but never used.","'colors' is already defined.","'x' is already defined.","'y' is already defined.","'w' is already defined.","'h' is already defined.","no-self-assign","'y' is assigned to itself.","selfAssignment","'bold' is assigned a value but never used.","'italic' is assigned a value but never used.","'color' is assigned a value but never used.","'font' is assigned a value but never used.","'size' is assigned a value but never used.","'coords' is assigned a value but never used.","'ldata' is assigned a value but never used.","'text_italic' is assigned a value but never used.","'text_bold' is assigned a value but never used.","'text_color' is assigned a value but never used.","'text_font' is assigned a value but never used.","'text_size' is assigned a value but never used.","'angle' is already defined.","'halign' is already defined.","'valign' is already defined.","Expected '!==' and instead saw '!='.","'len' is already defined.","'sequentialIndex' is already defined.","no-unused-expressions","Expected an assignment or function call and instead saw an expression.","ExpressionStatement","unusedExpression","no-sequences","Unexpected use of comma operator.","SequenceExpression","unexpectedCommaExpression","'colors' is not defined.","no-useless-escape","Unnecessary escape character: \\-.","Literal","unnecessaryEscape",["498","499"],["500","501"],"'ymax' is already defined.","'scale' is already defined.","'diff' is already defined.","'x' is assigned a value but never used.","'halfwidth' was used before it was defined.","no-mixed-operators","Unexpected mix of '&&' and '||'. Use parentheses to clarify the intended order of operations.","LogicalExpression","unexpectedMixedOperator","'e' is assigned a value but never used.","'coords' is not defined.","'top' is assigned a value but never used.","no-eval","eval can be harmful.","CallExpression","'i' is not defined.","Duplicate key 'xaxis'.","Duplicate key 'yaxis'.","no-global-assign","no-unsafe-negation",{"messageId":"502","fix":"503","desc":"504"},{"messageId":"505","fix":"506","desc":"507"},{"messageId":"502","fix":"508","desc":"504"},{"messageId":"505","fix":"509","desc":"507"},"removeEscape",{"range":"510","text":"511"},"Remove the `\\`. This maintains the current functionality.","escapeBackslash",{"range":"512","text":"513"},"Replace the `\\` with `\\\\` to include the actual backslash character.",{"range":"514","text":"511"},{"range":"515","text":"513"},[119610,119611],"",[119610,119610],"\\",[120174,120175],[120174,120174]]