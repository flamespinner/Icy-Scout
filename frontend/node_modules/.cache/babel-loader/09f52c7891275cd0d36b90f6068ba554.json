{"ast":null,"code":"import * as d3 from \"d3\";\nimport dataTransform from \"../dataTransform\";\nimport { colorParse } from \"../colorHelper\";\n/**\n * Reusable 3D Area Chart Component\n *\n * @module\n */\n\nexport default function () {\n  /* Default Properties */\n  let dimensions = {\n    x: 40,\n    y: 40,\n    z: 5\n  };\n  let color = \"blue\";\n  let transparency = 0.1;\n  let classed = \"d3X3dArea\";\n  let smoothed = d3.curveMonotoneX;\n  /* Scales */\n\n  let xScale;\n  let yScale;\n  /**\n   * Initialise Data and Scales\n   *\n   * @private\n   * @param {Array} data - Chart data.\n   */\n\n  const init = function (data) {\n    const {\n      columnKeys,\n      valueMax\n    } = dataTransform(data).summary();\n    const valueExtent = [0, valueMax];\n    const {\n      x: dimensionX,\n      y: dimensionY\n    } = dimensions;\n\n    if (typeof xScale === \"undefined\") {\n      xScale = d3.scalePoint().domain(columnKeys).range([0, dimensionX]);\n    }\n\n    if (typeof yScale === \"undefined\") {\n      yScale = d3.scaleLinear().domain(valueExtent).range([0, dimensionY]);\n    }\n  };\n  /**\n   * Constructor\n   *\n   * @constructor\n   * @alias area\n   * @param {d3.selection} selection - The chart holder D3 selection.\n   */\n\n\n  const my = function (selection) {\n    selection.each(function (data) {\n      init(data);\n      const element = d3.select(this).classed(classed, true).attr(\"id\", d => d.key);\n\n      const areaData = function (data) {\n        const dimensionX = dimensions.x;\n\n        if (smoothed) {\n          data = dataTransform(data).smooth(smoothed);\n          const keys = d3.extent(data.values.map(d => d.key));\n          xScale = d3.scaleLinear().domain(keys).range([0, dimensionX]);\n        }\n\n        let values = data.values; // Convert values into IFS coordinates\n\n        let coords = values.map((pointThis, indexThis, array) => {\n          let indexNext = indexThis + 1;\n\n          if (indexNext >= array.length) {\n            return null;\n          }\n\n          let pointNext = array[indexNext];\n          let x1 = xScale(pointThis.key);\n          let x2 = xScale(pointNext.key);\n          let y1 = yScale(pointThis.value);\n          let y2 = yScale(pointNext.value);\n          return [x1, 0, 0, x1, y1, 0, x2, y2, 0, x2, 0, 0];\n        }).filter(d => d !== null);\n        data.point = coords.map(d => d.join(\" \")).join(\" \");\n        data.coordIndex = coords.map((d, i) => {\n          const offset = i * 4;\n          return [offset, offset + 1, offset + 2, offset + 3, -1].join(\" \");\n        }).join(\" \");\n        return [data];\n      };\n\n      const shape = el => {\n        const shape = el.append(\"Shape\");\n        /*\n        // FIXME: x3dom cannot have empty IFS nodes, we must to use .html() rather than .append() & .attr().\n        shape.append(\"IndexedFaceset\")\n        \t.attr(\"coordIndex\", (d) => d.coordIndex)\n        \t.append(\"Coordinate\")\n        \t.attr(\"point\", (d) => d.point);\n        \tshape.append(\"Appearance\")\n        \t.append(\"Material\")\n        \t.attr(\"diffuseColor\", colorParse(color))\n        \t.attr(\"transparency\", transparency);\n        */\n\n        shape.html(d => `\n\t\t\t\t\t<IndexedFaceset coordIndex=\"${d.coordIndex}\" solid=\"false\">\n\t\t\t\t\t\t<Coordinate point=\"${d.point}\"></Coordinate>\n\t\t\t\t\t</IndexedFaceset>\n\t\t\t\t\t<Appearance>\n\t\t\t\t\t\t<Material diffuseColor=\"${colorParse(color)}\" transparency=\"${transparency}\"></Material>\n\t\t\t\t\t</Appearance>\n\t\t\t\t`);\n      };\n\n      const area = element.selectAll(\".area\").data(d => areaData(d), d => d.key);\n      area.enter().append(\"Group\").classed(\"area\", true).call(shape).merge(area);\n      const areaTransition = area.transition().select(\"Shape\");\n      areaTransition.select(\"IndexedFaceset\").attr(\"coordIndex\", d => d.coordIndex).select(\"Coordinate\").attr(\"point\", d => d.point);\n      areaTransition.select(\"Appearance\").select(\"Material\").attr(\"diffuseColor\", colorParse(color));\n      area.exit().remove();\n    });\n  };\n  /**\n   * Dimensions Getter / Setter\n   *\n   * @param {{x: {number}, y: {number}, z: {number}}} _v - 3D Object dimensions.\n   * @returns {*}\n   */\n\n\n  my.dimensions = function (_v) {\n    if (!arguments.length) return dimensions;\n    dimensions = _v;\n    return this;\n  };\n  /**\n   * X Scale Getter / Setter\n   *\n   * @param {d3.scale} _v - D3 scale.\n   * @returns {*}\n   */\n\n\n  my.xScale = function (_v) {\n    if (!arguments.length) return xScale;\n    xScale = _v;\n    return my;\n  };\n  /**\n   * Y Scale Getter / Setter\n   *\n   * @param {d3.scale} _v - D3 scale.\n   * @returns {*}\n   */\n\n\n  my.yScale = function (_v) {\n    if (!arguments.length) return yScale;\n    yScale = _v;\n    return my;\n  };\n  /**\n   * Color Getter / Setter\n   *\n   * @param {string} _v - Color (e.g. \"red\" or \"#ff0000\").\n   * @returns {*}\n   */\n\n\n  my.color = function (_v) {\n    if (!arguments.length) return color;\n    color = _v;\n    return my;\n  };\n  /**\n   * Smooth Interpolation Getter / Setter\n   *\n   * Options:\n   *   d3.curveBasis\n   *   d3.curveLinear\n   *   d3.curveMonotoneX\n   *\n   * @param {d3.curve} _v.\n   * @returns {*}\n   */\n\n\n  my.smoothed = function (_v) {\n    if (!arguments.length) return smoothed;\n    smoothed = _v;\n    return my;\n  };\n\n  return my;\n}","map":{"version":3,"sources":["C:/Users/Michael Wilke/Desktop/Scout/frontend/node_modules/d3-x3d/src/component/area.js"],"names":["d3","dataTransform","colorParse","dimensions","x","y","z","color","transparency","classed","smoothed","curveMonotoneX","xScale","yScale","init","data","columnKeys","valueMax","summary","valueExtent","dimensionX","dimensionY","scalePoint","domain","range","scaleLinear","my","selection","each","element","select","attr","d","key","areaData","smooth","keys","extent","values","map","coords","pointThis","indexThis","array","indexNext","length","pointNext","x1","x2","y1","value","y2","filter","point","join","coordIndex","i","offset","shape","el","append","html","area","selectAll","enter","call","merge","areaTransition","transition","exit","remove","_v","arguments"],"mappings":"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","sourcesContent":["import * as d3 from \"d3\";\nimport dataTransform from \"../dataTransform\";\nimport { colorParse } from \"../colorHelper\";\n\n\n/**\n * Reusable 3D Area Chart Component\n *\n * @module\n */\nexport default function() {\n\n\t/* Default Properties */\n\tlet dimensions = { x: 40, y: 40, z: 5 };\n\tlet color = \"blue\";\n\tlet transparency = 0.1;\n\tlet classed = \"d3X3dArea\";\n\tlet smoothed = d3.curveMonotoneX;\n\n\t/* Scales */\n\tlet xScale;\n\tlet yScale;\n\n\t/**\n\t * Initialise Data and Scales\n\t *\n\t * @private\n\t * @param {Array} data - Chart data.\n\t */\n\tconst init = function(data) {\n\t\tconst { columnKeys, valueMax } = dataTransform(data).summary();\n\t\tconst valueExtent = [0, valueMax];\n\t\tconst { x: dimensionX, y: dimensionY } = dimensions;\n\n\t\tif (typeof xScale === \"undefined\") {\n\t\t\txScale = d3.scalePoint()\n\t\t\t\t.domain(columnKeys)\n\t\t\t\t.range([0, dimensionX]);\n\t\t}\n\n\t\tif (typeof yScale === \"undefined\") {\n\t\t\tyScale = d3.scaleLinear()\n\t\t\t\t.domain(valueExtent)\n\t\t\t\t.range([0, dimensionY]);\n\t\t}\n\t};\n\n\t/**\n\t * Constructor\n\t *\n\t * @constructor\n\t * @alias area\n\t * @param {d3.selection} selection - The chart holder D3 selection.\n\t */\n\tconst my = function(selection) {\n\t\tselection.each(function(data) {\n\t\t\tinit(data);\n\n\t\t\tconst element = d3.select(this)\n\t\t\t\t.classed(classed, true)\n\t\t\t\t.attr(\"id\", (d) => d.key);\n\n\t\t\tconst areaData = function(data) {\n\t\t\t\tconst dimensionX = dimensions.x;\n\n\t\t\t\tif (smoothed) {\n\t\t\t\t\tdata = dataTransform(data).smooth(smoothed);\n\n\t\t\t\t\tconst keys = d3.extent(data.values.map((d) => d.key));\n\t\t\t\t\txScale = d3.scaleLinear()\n\t\t\t\t\t\t.domain(keys)\n\t\t\t\t\t\t.range([0, dimensionX]);\n\t\t\t\t}\n\n\t\t\t\tlet values = data.values;\n\n\t\t\t\t// Convert values into IFS coordinates\n\t\t\t\tlet coords = values.map((pointThis, indexThis, array) => {\n\t\t\t\t\tlet indexNext = indexThis + 1;\n\t\t\t\t\tif (indexNext >= array.length) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tlet pointNext = array[indexNext];\n\n\t\t\t\t\tlet x1 = xScale(pointThis.key);\n\t\t\t\t\tlet x2 = xScale(pointNext.key);\n\t\t\t\t\tlet y1 = yScale(pointThis.value);\n\t\t\t\t\tlet y2 = yScale(pointNext.value);\n\n\t\t\t\t\treturn [x1, 0, 0, x1, y1, 0, x2, y2, 0, x2, 0, 0];\n\t\t\t\t}).filter((d) => d !== null);\n\n\t\t\t\tdata.point = coords.map((d) => d.join(\" \")).join(\" \");\n\t\t\t\tdata.coordIndex = coords.map((d, i) => {\n\t\t\t\t\tconst offset = i * 4;\n\t\t\t\t\treturn [offset, offset + 1, offset + 2, offset + 3, -1].join(\" \");\n\t\t\t\t}).join(\" \");\n\n\t\t\t\treturn [data];\n\t\t\t};\n\n\t\t\tconst shape = (el) => {\n\t\t\t\tconst shape = el.append(\"Shape\");\n\n\t\t\t\t/*\n\t\t\t\t// FIXME: x3dom cannot have empty IFS nodes, we must to use .html() rather than .append() & .attr().\n\t\t\t\tshape.append(\"IndexedFaceset\")\n\t\t\t\t\t.attr(\"coordIndex\", (d) => d.coordIndex)\n\t\t\t\t\t.append(\"Coordinate\")\n\t\t\t\t\t.attr(\"point\", (d) => d.point);\n\n\t\t\t\tshape.append(\"Appearance\")\n\t\t\t\t\t.append(\"Material\")\n\t\t\t\t\t.attr(\"diffuseColor\", colorParse(color))\n\t\t\t\t\t.attr(\"transparency\", transparency);\n\t\t\t\t*/\n\n\t\t\t\tshape.html((d) => `\n\t\t\t\t\t<IndexedFaceset coordIndex=\"${d.coordIndex}\" solid=\"false\">\n\t\t\t\t\t\t<Coordinate point=\"${d.point}\"></Coordinate>\n\t\t\t\t\t</IndexedFaceset>\n\t\t\t\t\t<Appearance>\n\t\t\t\t\t\t<Material diffuseColor=\"${colorParse(color)}\" transparency=\"${transparency}\"></Material>\n\t\t\t\t\t</Appearance>\n\t\t\t\t`);\n\t\t\t};\n\n\t\t\tconst area = element.selectAll(\".area\")\n\t\t\t\t.data((d) => areaData(d), (d) => d.key);\n\n\t\t\tarea.enter()\n\t\t\t\t.append(\"Group\")\n\t\t\t\t.classed(\"area\", true)\n\t\t\t\t.call(shape)\n\t\t\t\t.merge(area);\n\n\t\t\tconst areaTransition = area.transition().select(\"Shape\");\n\n\t\t\tareaTransition.select(\"IndexedFaceset\")\n\t\t\t\t.attr(\"coordIndex\", (d) => d.coordIndex)\n\t\t\t\t.select(\"Coordinate\")\n\t\t\t\t.attr(\"point\", (d) => d.point);\n\n\t\t\tareaTransition.select(\"Appearance\")\n\t\t\t\t.select(\"Material\")\n\t\t\t\t.attr(\"diffuseColor\", colorParse(color));\n\n\t\t\tarea.exit()\n\t\t\t\t.remove();\n\t\t});\n\t};\n\n\t/**\n\t * Dimensions Getter / Setter\n\t *\n\t * @param {{x: {number}, y: {number}, z: {number}}} _v - 3D Object dimensions.\n\t * @returns {*}\n\t */\n\tmy.dimensions = function(_v) {\n\t\tif (!arguments.length) return dimensions;\n\t\tdimensions = _v;\n\t\treturn this;\n\t};\n\n\t/**\n\t * X Scale Getter / Setter\n\t *\n\t * @param {d3.scale} _v - D3 scale.\n\t * @returns {*}\n\t */\n\tmy.xScale = function(_v) {\n\t\tif (!arguments.length) return xScale;\n\t\txScale = _v;\n\t\treturn my;\n\t};\n\n\t/**\n\t * Y Scale Getter / Setter\n\t *\n\t * @param {d3.scale} _v - D3 scale.\n\t * @returns {*}\n\t */\n\tmy.yScale = function(_v) {\n\t\tif (!arguments.length) return yScale;\n\t\tyScale = _v;\n\t\treturn my;\n\t};\n\n\t/**\n\t * Color Getter / Setter\n\t *\n\t * @param {string} _v - Color (e.g. \"red\" or \"#ff0000\").\n\t * @returns {*}\n\t */\n\tmy.color = function(_v) {\n\t\tif (!arguments.length) return color;\n\t\tcolor = _v;\n\t\treturn my;\n\t};\n\n\t/**\n\t * Smooth Interpolation Getter / Setter\n\t *\n\t * Options:\n\t *   d3.curveBasis\n\t *   d3.curveLinear\n\t *   d3.curveMonotoneX\n\t *\n\t * @param {d3.curve} _v.\n\t * @returns {*}\n\t */\n\tmy.smoothed = function(_v) {\n\t\tif (!arguments.length) return smoothed;\n\t\tsmoothed = _v;\n\t\treturn my;\n\t};\n\n\treturn my;\n}\n"]},"metadata":{},"sourceType":"module"}