{"ast":null,"code":"import * as d3 from \"d3\";\nimport * as d3Interpolate from \"d3-interpolate-curve\";\n/**\n * Data Transform\n *\n * @module\n * @returns {Object}\n */\n\nexport default function dataTransform(data) {\n  const SINGLE_SERIES = 1;\n  const MULTI_SERIES = 2;\n  const coordinates = [\"x\", \"y\", \"z\"];\n  /**\n   * Data Type (Single or Multi Series)\n   *\n   * @param data\n   */\n\n  const dataType = function (data) {\n    return data.key !== undefined ? SINGLE_SERIES : MULTI_SERIES;\n  };\n  /************* HELPER FUNCTIONS *******************/\n\n  /**\n   * Union Two Arrays\n   *\n   * @private\n   * @param {Array} array1 - First Array.\n   * @param {Array} array2 - Second Array.\n   * @returns {Array}\n   */\n\n\n  const union = function (array1, array2) {\n    const ret = [];\n    let arr;\n\n    if (array1.length > array2.length) {\n      arr = array2.concat(array1);\n    } else {\n      arr = array1.concat(array2);\n    }\n\n    let len = arr.length;\n    const assoc = {};\n\n    while (len--) {\n      const item = arr[len];\n\n      if (!assoc[item]) {\n        ret.unshift(item);\n        assoc[item] = true;\n      }\n    }\n\n    return ret;\n  };\n  /**\n   * How Many Decimal Places?\n   *\n   * @private\n   * @param {number} num - Float Number.\n   * @returns {number}\n   */\n\n\n  const decimalPlaces = function (num) {\n    const match = (\"\" + num).match(/(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/);\n\n    if (!match) {\n      return 0;\n    }\n\n    return Math.max(0, // Number of digits right of decimal point.\n    (match[1] ? match[1].length : 0 // Adjust for scientific notation.\n    ) - (match[2] ? +match[2] : 0));\n  };\n  /************* SINGLE SERIES FUNCTIONS ************/\n\n  /**\n   * Row Key (Single Series)\n   *\n   * @returns {Array}\n   */\n\n\n  const singleRowKey = function (data) {\n    return d3.values(data)[0];\n  };\n  /**\n   * Row Total (Single Series)\n   *\n   * @returns {number}\n   */\n\n\n  const singleRowTotal = function (data) {\n    return d3.sum(data.values, d => d.value);\n  };\n  /**\n   * Row Value Keys (Single Series)\n   *\n   * @returns {Array}\n   */\n\n\n  const singleRowValueKeys = function (data) {\n    return data.values.length ? Object.keys(data.values[0]) : [];\n  };\n  /**\n   * Column Keys (Single Series)\n   *\n   * @returns {Array}\n   */\n\n\n  const singleColumnKeys = function (data) {\n    return d3.values(data.values).map(d => d.key);\n  };\n  /**\n   * Value Min (Single Series)\n   *\n   * @returns {number}\n   */\n\n\n  const singleValueMin = function (data) {\n    return d3.min(data.values, d => +d.value);\n  };\n  /**\n   * Value Max (Single Series)\n   *\n   * @returns {number}\n   */\n\n\n  const singleValueMax = function (data) {\n    return d3.max(data.values, d => +d.value);\n  };\n  /**\n   * Value Extent (Single Series)\n   *\n   * @returns {Array}\n   */\n\n\n  const singleValueExtent = function (data) {\n    return d3.extent(data.values, d => +d.value);\n  };\n  /**\n   * Coordinates Min (Single Series)\n   *\n   * @returns {Object}\n   */\n\n\n  const singleCoordinatesMin = function (data) {\n    return coordinates.reduce((maximums, coord) => {\n      maximums[coord] = d3.min(data.values, d => +d[coord]);\n      return maximums;\n    }, {});\n  };\n  /**\n   * Coordinates Max (Single Series)\n   *\n   * @returns {Object}\n   */\n\n\n  const singleCoordinatesMax = function (data) {\n    return coordinates.reduce((maximums, coord) => {\n      maximums[coord] = d3.max(data.values, d => +d[coord]);\n      return maximums;\n    }, {});\n  };\n  /**\n   * Coordinates Extent (Single Series)\n   *\n   * @returns {Object}\n   */\n\n\n  const singleCoordinatesExtent = function (data) {\n    return coordinates.reduce((extents, coord) => {\n      extents[coord] = d3.extent(data.values, d => +d[coord]);\n      return extents;\n    }, {});\n  };\n  /**\n   * Thresholds (Single Series)\n   *\n   * @returns {Array}\n   */\n\n\n  const singleThresholds = function (data) {\n    const bands = [0.15, 0.40, 0.55, 0.90];\n    const min = singleValueMin(data);\n    const max = singleValueMax(data);\n    const distance = max - min;\n    return bands.map(v => Number((min + v * distance).toFixed(singleMaxDecimalPlace(data))));\n  };\n  /**\n   * Max Decimal Place (Single Series)\n   *\n   * @returns {number}\n   */\n\n\n  const singleMaxDecimalPlace = function (data) {\n    return data.values.reduce((places, d) => {\n      places = d3.max([places, decimalPlaces(d.value)]); // toFixed must be between 0 and 20\n\n      return places > 20 ? 20 : places;\n    }, 0);\n  };\n  /**\n   * Single Series Summary\n   *\n   * @returns {Object}\n   */\n\n\n  const singleSummary = function (data) {\n    return {\n      dataType: dataType(data),\n      rowKey: singleRowKey(data),\n      rowTotal: singleRowTotal(data),\n      columnKeys: singleColumnKeys(data),\n      valueMin: singleValueMin(data),\n      valueMax: singleValueMax(data),\n      valueExtent: singleValueExtent(data),\n      coordinatesMin: singleCoordinatesMin(data),\n      coordinatesMax: singleCoordinatesMax(data),\n      coordinatesExtent: singleCoordinatesExtent(data),\n      maxDecimalPlace: singleMaxDecimalPlace(data),\n      thresholds: singleThresholds(data),\n      rowValuesKeys: singleRowValueKeys(data)\n    };\n  };\n  /************* MULTI SERIES FUNCTIONS *************/\n\n  /**\n   * Row Keys (Multi Series)\n   *\n   * @returns {Array}\n   */\n\n\n  const multiRowKeys = function (data) {\n    return data.map(d => d.key);\n  };\n  /**\n   * Row Totals (Multi Series)\n   *\n   * @returns {Object}\n   */\n\n\n  const multiRowTotals = function (data) {\n    return data.reduce((totals, row) => {\n      totals[row.key] = singleRowTotal(row);\n      return totals;\n    }, {});\n  };\n  /**\n   * Row Totals Max (Multi Series)\n   *\n   * @returns {number}\n   */\n\n\n  const multiRowTotalsMax = function (data) {\n    return d3.max(d3.values(multiRowTotals(data)));\n  };\n  /**\n   * Row Value Keys (Multi Series)\n   *\n   * @returns {Array}\n   */\n\n\n  const multiRowValueKeys = function (data) {\n    return data.length ? Object.keys(data[0].values[0]) : [];\n  };\n  /**\n   * Column Keys (Multi Series)\n   *\n   * @returns {Array}\n   */\n\n\n  const multiColumnKeys = function (data) {\n    return data.reduce((keys, row) => {\n      const tmp = [];\n      row.values.forEach((d, i) => {\n        tmp[i] = d.key;\n      });\n      keys = union(keys, tmp);\n      return keys;\n    }, []);\n  };\n  /**\n   * Column Totals (Multi Series)\n   *\n   * @returns {Object}\n   */\n\n\n  const multiColumnTotals = function (data) {\n    return data.reduce((totals, row) => {\n      row.values.forEach(d => {\n        const columnName = d.key;\n        totals[columnName] = typeof totals[columnName] === \"undefined\" ? 0 : totals[columnName];\n        totals[columnName] += d.value;\n      });\n      return totals;\n    }, {});\n  };\n  /**\n   * Column Totals Max (Multi Series)\n   *\n   * @returns {number}\n   */\n\n\n  const multiColumnTotalsMax = function (data) {\n    return d3.max(d3.values(multiColumnTotals(data)));\n  };\n  /**\n   * Value Min (Multi Series)\n   *\n   * @returns {number}\n   */\n\n\n  const multiValueMin = function (data) {\n    return d3.min(data.map(row => singleValueMin(row)));\n  };\n  /**\n   * Value Max (Multi Series)\n   *\n   * @returns {number}\n   */\n\n\n  const multiValueMax = function (data) {\n    return d3.max(data.map(row => singleValueMax(row)));\n  };\n  /**\n   * Value Extent (Multi Series)\n   *\n   * @returns {Array}\n   */\n\n\n  const multiValueExtent = function (data) {\n    return [multiValueMin(data), multiValueMax(data)];\n  };\n  /**\n   * Coordinates Min (Multi Series)\n   *\n   * @returns {Object}\n   */\n\n\n  const multiCoordinatesMin = function (data) {\n    return data.map(row => singleCoordinatesMin(row)).reduce((minimums, row) => {\n      coordinates.forEach(coord => {\n        minimums[coord] = coord in minimums ? d3.min([minimums[coord], +row[coord]]) : row[coord];\n      });\n      return minimums;\n    }, {});\n  };\n  /**\n   * Coordinates Max (Multi Series)\n   *\n   * @returns {Object}\n   */\n\n\n  const multiCoordinatesMax = function (data) {\n    return data.map(row => singleCoordinatesMax(row)).reduce((maximums, row) => {\n      coordinates.forEach(coord => {\n        maximums[coord] = coord in maximums ? d3.max([maximums[coord], +row[coord]]) : row[coord];\n      });\n      return maximums;\n    }, {});\n  };\n  /**\n   * Coordinates Extent (Multi Series)\n   *\n   * @returns {Object}\n   */\n\n\n  const multiCoordinatesExtent = function (data) {\n    return coordinates.reduce((extents, coord) => {\n      extents[coord] = [multiCoordinatesMin(data)[coord], multiCoordinatesMax(data)[coord]];\n      return extents;\n    }, {});\n  };\n  /**\n   * Thresholds (Multi Series)\n   *\n   * @returns {Array}\n   */\n\n\n  const multiThresholds = function (data) {\n    const bands = [0.15, 0.40, 0.55, 0.90];\n    const min = multiValueMin(data);\n    const max = multiValueMax(data);\n    const distance = max - min;\n    return bands.map(v => Number((min + v * distance).toFixed(multiMaxDecimalPlace(data))));\n  };\n  /**\n   * Max Decimal Place (Multi Series)\n   *\n   * @returns {number}\n   */\n\n\n  const multiMaxDecimalPlace = function (data) {\n    return d3.max(d3.map(data).values().reduce((places, row, i) => {\n      places[i] = singleMaxDecimalPlace(row);\n      return places;\n    }, []));\n  };\n  /**\n   * Multi Series Summary\n   *\n   * @returns {Object}\n   */\n\n\n  const multiSummary = function (data) {\n    return {\n      dataType: dataType(data),\n      rowKeys: multiRowKeys(data),\n      rowTotals: multiRowTotals(data),\n      rowTotalsMax: multiRowTotalsMax(data),\n      columnKeys: multiColumnKeys(data),\n      columnTotals: multiColumnTotals(data),\n      columnTotalsMax: multiColumnTotalsMax(data),\n      valueMin: multiValueMin(data),\n      valueMax: multiValueMax(data),\n      valueExtent: multiValueExtent(data),\n      coordinatesMin: multiCoordinatesMin(data),\n      coordinatesMax: multiCoordinatesMax(data),\n      coordinatesExtent: multiCoordinatesExtent(data),\n      maxDecimalPlace: multiMaxDecimalPlace(data),\n      thresholds: multiThresholds(data),\n      rowValuesKeys: multiRowValueKeys(data)\n    };\n  };\n  /************* MAIN FUNCTIONS **********************/\n\n  /**\n   * Summary\n   *\n   * @returns {Object}\n   */\n\n\n  const summary = function () {\n    if (dataType(data) === SINGLE_SERIES) {\n      return singleSummary(data);\n    } else {\n      return multiSummary(data);\n    }\n  };\n  /**\n   * Rotate Data\n   *\n   * @returns {Array}\n   */\n\n\n  const rotate = function () {\n    const columnKeys = data.map(d => d.key);\n    const rowKeys = data[0].values.map(d => d.key);\n    const rotated = rowKeys.map((rowKey, rowIndex) => {\n      const values = columnKeys.map((columnKey, columnIndex) => {\n        // Copy the values from the original object\n        const values = Object.assign({}, data[columnIndex].values[rowIndex]); // Swap the key over\n\n        values.key = columnKey;\n        return values;\n      });\n      return {\n        key: rowKey,\n        values: values\n      };\n    });\n    return rotated;\n  };\n  /**\n   * Smooth Data\n   *\n   * Returns a copy of the input data series which is subsampled into a 100 samples,\n   * and has the smoothed values based on a provided d3.curve function.\n   *\n   * @param curveFunction\n   * @returns {{values: *, key: *}}\n   */\n\n\n  const smooth = function (curveFunction) {\n    const epsilon = 0.00001;\n    const samples = 100;\n    const values = data.values.map(d => d.value);\n    const sampler = d3.range(0, 1, 1 / samples);\n\n    const keyPolator = t => Number((t * samples).toFixed(0)) + 1;\n\n    const valuePolator = d3Interpolate.interpolateFromCurve(values, curveFunction, epsilon, samples);\n    const smoothed = {\n      key: data.key,\n      values: sampler.map(t => ({\n        key: keyPolator(t),\n        value: valuePolator(t)\n      }))\n    };\n    return smoothed;\n  };\n\n  return {\n    summary: summary,\n    rotate: rotate,\n    smooth: smooth\n  };\n}","map":{"version":3,"sources":["C:/Users/Michael Wilke/Desktop/Scout/frontend/node_modules/d3-x3d/src/dataTransform.js"],"names":["d3","d3Interpolate","dataTransform","data","SINGLE_SERIES","MULTI_SERIES","coordinates","dataType","key","undefined","union","array1","array2","ret","arr","length","concat","len","assoc","item","unshift","decimalPlaces","num","match","Math","max","singleRowKey","values","singleRowTotal","sum","d","value","singleRowValueKeys","Object","keys","singleColumnKeys","map","singleValueMin","min","singleValueMax","singleValueExtent","extent","singleCoordinatesMin","reduce","maximums","coord","singleCoordinatesMax","singleCoordinatesExtent","extents","singleThresholds","bands","distance","v","Number","toFixed","singleMaxDecimalPlace","places","singleSummary","rowKey","rowTotal","columnKeys","valueMin","valueMax","valueExtent","coordinatesMin","coordinatesMax","coordinatesExtent","maxDecimalPlace","thresholds","rowValuesKeys","multiRowKeys","multiRowTotals","totals","row","multiRowTotalsMax","multiRowValueKeys","multiColumnKeys","tmp","forEach","i","multiColumnTotals","columnName","multiColumnTotalsMax","multiValueMin","multiValueMax","multiValueExtent","multiCoordinatesMin","minimums","multiCoordinatesMax","multiCoordinatesExtent","multiThresholds","multiMaxDecimalPlace","multiSummary","rowKeys","rowTotals","rowTotalsMax","columnTotals","columnTotalsMax","summary","rotate","rotated","rowIndex","columnKey","columnIndex","assign","smooth","curveFunction","epsilon","samples","sampler","range","keyPolator","t","valuePolator","interpolateFromCurve","smoothed"],"mappings":"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","sourcesContent":["import * as d3 from \"d3\";\nimport * as d3Interpolate from \"d3-interpolate-curve\";\n\n/**\n * Data Transform\n *\n * @module\n * @returns {Object}\n */\nexport default function dataTransform(data) {\n\n\tconst SINGLE_SERIES = 1;\n\tconst MULTI_SERIES = 2;\n\tconst coordinates = [\"x\", \"y\", \"z\"];\n\n\t/**\n\t * Data Type (Single or Multi Series)\n\t *\n\t * @param data\n\t */\n\tconst dataType = function(data) {\n\t\treturn data.key !== undefined ? SINGLE_SERIES : MULTI_SERIES;\n\t};\n\n\t/************* HELPER FUNCTIONS *******************/\n\n\t/**\n\t * Union Two Arrays\n\t *\n\t * @private\n\t * @param {Array} array1 - First Array.\n\t * @param {Array} array2 - Second Array.\n\t * @returns {Array}\n\t */\n\tconst union = function(array1, array2) {\n\t\tconst ret = [];\n\t\tlet arr;\n\n\t\tif (array1.length > array2.length) {\n\t\t\tarr = array2.concat(array1);\n\t\t} else {\n\t\t\tarr = array1.concat(array2);\n\t\t}\n\n\t\tlet len = arr.length;\n\t\tconst assoc = {};\n\n\t\twhile (len--) {\n\t\t\tconst item = arr[len];\n\n\t\t\tif (!assoc[item]) {\n\t\t\t\tret.unshift(item);\n\t\t\t\tassoc[item] = true;\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t};\n\n\t/**\n\t * How Many Decimal Places?\n\t *\n\t * @private\n\t * @param {number} num - Float Number.\n\t * @returns {number}\n\t */\n\tconst decimalPlaces = function(num) {\n\t\tconst match = (\"\" + num).match(/(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/);\n\t\tif (!match) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn Math.max(\n\t\t\t0,\n\t\t\t// Number of digits right of decimal point.\n\t\t\t(match[1] ? match[1].length : 0)\n\t\t\t// Adjust for scientific notation.\n\t\t\t-\n\t\t\t(match[2] ? +match[2] : 0)\n\t\t);\n\t};\n\n\t/************* SINGLE SERIES FUNCTIONS ************/\n\n\t/**\n\t * Row Key (Single Series)\n\t *\n\t * @returns {Array}\n\t */\n\tconst singleRowKey = function(data) {\n\t\treturn d3.values(data)[0];\n\t};\n\n\t/**\n\t * Row Total (Single Series)\n\t *\n\t * @returns {number}\n\t */\n\tconst singleRowTotal = function(data) {\n\t\treturn d3.sum(data.values, (d) => d.value);\n\t};\n\n\t/**\n\t * Row Value Keys (Single Series)\n\t *\n\t * @returns {Array}\n\t */\n\tconst singleRowValueKeys = function(data) {\n\t\treturn data.values.length ? Object.keys(data.values[0]) : [];\n\t};\n\n\t/**\n\t * Column Keys (Single Series)\n\t *\n\t * @returns {Array}\n\t */\n\tconst singleColumnKeys = function(data) {\n\t\treturn d3.values(data.values).map((d) => d.key);\n\t};\n\n\t/**\n\t * Value Min (Single Series)\n\t *\n\t * @returns {number}\n\t */\n\tconst singleValueMin = function(data) {\n\t\treturn d3.min(data.values, (d) => +d.value);\n\t};\n\n\t/**\n\t * Value Max (Single Series)\n\t *\n\t * @returns {number}\n\t */\n\tconst singleValueMax = function(data) {\n\t\treturn d3.max(data.values, (d) => +d.value);\n\t};\n\n\t/**\n\t * Value Extent (Single Series)\n\t *\n\t * @returns {Array}\n\t */\n\tconst singleValueExtent = function(data) {\n\t\treturn d3.extent(data.values, (d) => +d.value);\n\t};\n\n\t/**\n\t * Coordinates Min (Single Series)\n\t *\n\t * @returns {Object}\n\t */\n\tconst singleCoordinatesMin = function(data) {\n\t\treturn coordinates.reduce((maximums, coord) => {\n\t\t\tmaximums[coord] = d3.min(data.values, (d) => +d[coord]);\n\t\t\treturn maximums;\n\t\t}, {});\n\t};\n\n\t/**\n\t * Coordinates Max (Single Series)\n\t *\n\t * @returns {Object}\n\t */\n\tconst singleCoordinatesMax = function(data) {\n\t\treturn coordinates.reduce((maximums, coord) => {\n\t\t\tmaximums[coord] = d3.max(data.values, (d) => +d[coord]);\n\t\t\treturn maximums;\n\t\t}, {});\n\t};\n\n\t/**\n\t * Coordinates Extent (Single Series)\n\t *\n\t * @returns {Object}\n\t */\n\tconst singleCoordinatesExtent = function(data) {\n\t\treturn coordinates.reduce((extents, coord) => {\n\t\t\textents[coord] = d3.extent(data.values, (d) => +d[coord]);\n\t\t\treturn extents;\n\t\t}, {});\n\t};\n\n\t/**\n\t * Thresholds (Single Series)\n\t *\n\t * @returns {Array}\n\t */\n\tconst singleThresholds = function(data) {\n\t\tconst bands = [0.15, 0.40, 0.55, 0.90];\n\t\tconst min = singleValueMin(data);\n\t\tconst max = singleValueMax(data);\n\t\tconst distance = max - min;\n\n\t\treturn bands.map((v) => Number((min + (v * distance)).toFixed(singleMaxDecimalPlace(data))));\n\t};\n\n\t/**\n\t * Max Decimal Place (Single Series)\n\t *\n\t * @returns {number}\n\t */\n\tconst singleMaxDecimalPlace = function(data) {\n\t\treturn data.values.reduce((places, d) => {\n\t\t\tplaces = d3.max([places, decimalPlaces(d.value)]);\n\n\t\t\t// toFixed must be between 0 and 20\n\t\t\treturn places > 20 ? 20 : places;\n\t\t}, 0);\n\t};\n\n\t/**\n\t * Single Series Summary\n\t *\n\t * @returns {Object}\n\t */\n\tconst singleSummary = function(data) {\n\t\treturn {\n\t\t\tdataType: dataType(data),\n\t\t\trowKey: singleRowKey(data),\n\t\t\trowTotal: singleRowTotal(data),\n\t\t\tcolumnKeys: singleColumnKeys(data),\n\t\t\tvalueMin: singleValueMin(data),\n\t\t\tvalueMax: singleValueMax(data),\n\t\t\tvalueExtent: singleValueExtent(data),\n\t\t\tcoordinatesMin: singleCoordinatesMin(data),\n\t\t\tcoordinatesMax: singleCoordinatesMax(data),\n\t\t\tcoordinatesExtent: singleCoordinatesExtent(data),\n\t\t\tmaxDecimalPlace: singleMaxDecimalPlace(data),\n\t\t\tthresholds: singleThresholds(data),\n\t\t\trowValuesKeys: singleRowValueKeys(data)\n\t\t}\n\t};\n\n\t/************* MULTI SERIES FUNCTIONS *************/\n\n\t/**\n\t * Row Keys (Multi Series)\n\t *\n\t * @returns {Array}\n\t */\n\tconst multiRowKeys = function(data) {\n\t\treturn data.map((d) => d.key);\n\t};\n\n\t/**\n\t * Row Totals (Multi Series)\n\t *\n\t * @returns {Object}\n\t */\n\tconst multiRowTotals = function(data) {\n\t\treturn data.reduce((totals, row) => {\n\t\t\ttotals[row.key] = singleRowTotal(row);\n\t\t\treturn totals;\n\t\t}, {});\n\t};\n\n\t/**\n\t * Row Totals Max (Multi Series)\n\t *\n\t * @returns {number}\n\t */\n\tconst multiRowTotalsMax = function(data) {\n\t\treturn d3.max(d3.values(multiRowTotals(data)));\n\t};\n\n\t/**\n\t * Row Value Keys (Multi Series)\n\t *\n\t * @returns {Array}\n\t */\n\tconst multiRowValueKeys = function(data) {\n\t\treturn data.length ? Object.keys(data[0].values[0]) : [];\n\t};\n\n\t/**\n\t * Column Keys (Multi Series)\n\t *\n\t * @returns {Array}\n\t */\n\tconst multiColumnKeys = function(data) {\n\t\treturn data.reduce((keys, row) => {\n\t\t\tconst tmp = [];\n\t\t\trow.values.forEach((d, i) => {\n\t\t\t\ttmp[i] = d.key;\n\t\t\t});\n\n\t\t\tkeys = union(keys, tmp);\n\n\t\t\treturn keys;\n\t\t}, []);\n\t};\n\n\t/**\n\t * Column Totals (Multi Series)\n\t *\n\t * @returns {Object}\n\t */\n\tconst multiColumnTotals = function(data) {\n\t\treturn data.reduce((totals, row) => {\n\t\t\trow.values.forEach((d) => {\n\t\t\t\tconst columnName = d.key;\n\t\t\t\ttotals[columnName] = (typeof totals[columnName] === \"undefined\" ? 0 : totals[columnName]);\n\t\t\t\ttotals[columnName] += d.value;\n\t\t\t});\n\n\t\t\treturn totals;\n\t\t}, {});\n\t};\n\n\t/**\n\t * Column Totals Max (Multi Series)\n\t *\n\t * @returns {number}\n\t */\n\tconst multiColumnTotalsMax = function(data) {\n\t\treturn d3.max(d3.values(multiColumnTotals(data)));\n\t};\n\n\t/**\n\t * Value Min (Multi Series)\n\t *\n\t * @returns {number}\n\t */\n\tconst multiValueMin = function(data) {\n\t\treturn d3.min(data.map((row) => singleValueMin(row)));\n\t};\n\n\t/**\n\t * Value Max (Multi Series)\n\t *\n\t * @returns {number}\n\t */\n\tconst multiValueMax = function(data) {\n\t\treturn d3.max(data.map((row) => singleValueMax(row)));\n\t};\n\n\t/**\n\t * Value Extent (Multi Series)\n\t *\n\t * @returns {Array}\n\t */\n\tconst multiValueExtent = function(data) {\n\t\treturn [multiValueMin(data), multiValueMax(data)];\n\t};\n\n\t/**\n\t * Coordinates Min (Multi Series)\n\t *\n\t * @returns {Object}\n\t */\n\tconst multiCoordinatesMin = function(data) {\n\t\treturn data.map((row) => singleCoordinatesMin(row)).reduce((minimums, row) => {\n\t\t\tcoordinates.forEach((coord) => {\n\t\t\t\tminimums[coord] = (coord in minimums ? d3.min([minimums[coord], +row[coord]]) : row[coord]);\n\t\t\t});\n\n\t\t\treturn minimums;\n\t\t}, {});\n\t};\n\n\t/**\n\t * Coordinates Max (Multi Series)\n\t *\n\t * @returns {Object}\n\t */\n\tconst multiCoordinatesMax = function(data) {\n\t\treturn data.map((row) => singleCoordinatesMax(row)).reduce((maximums, row) => {\n\t\t\tcoordinates.forEach((coord) => {\n\t\t\t\tmaximums[coord] = (coord in maximums ? d3.max([maximums[coord], +row[coord]]) : row[coord]);\n\t\t\t});\n\n\t\t\treturn maximums;\n\t\t}, {});\n\t};\n\n\t/**\n\t * Coordinates Extent (Multi Series)\n\t *\n\t * @returns {Object}\n\t */\n\tconst multiCoordinatesExtent = function(data) {\n\t\treturn coordinates.reduce((extents, coord) => {\n\t\t\textents[coord] = [multiCoordinatesMin(data)[coord], multiCoordinatesMax(data)[coord]];\n\n\t\t\treturn extents;\n\t\t}, {});\n\t};\n\n\t/**\n\t * Thresholds (Multi Series)\n\t *\n\t * @returns {Array}\n\t */\n\tconst multiThresholds = function(data) {\n\t\tconst bands = [0.15, 0.40, 0.55, 0.90];\n\t\tconst min = multiValueMin(data);\n\t\tconst max = multiValueMax(data);\n\t\tconst distance = max - min;\n\n\t\treturn bands.map((v) => Number((min + (v * distance)).toFixed(multiMaxDecimalPlace(data))));\n\t};\n\n\t/**\n\t * Max Decimal Place (Multi Series)\n\t *\n\t * @returns {number}\n\t */\n\tconst multiMaxDecimalPlace = function(data) {\n\t\treturn d3.max(d3.map(data).values().reduce((places, row, i) => {\n\t\t\tplaces[i] = singleMaxDecimalPlace(row);\n\n\t\t\treturn places;\n\t\t}, []));\n\t};\n\n\t/**\n\t * Multi Series Summary\n\t *\n\t * @returns {Object}\n\t */\n\tconst multiSummary = function(data) {\n\t\treturn {\n\t\t\tdataType: dataType(data),\n\t\t\trowKeys: multiRowKeys(data),\n\t\t\trowTotals: multiRowTotals(data),\n\t\t\trowTotalsMax: multiRowTotalsMax(data),\n\t\t\tcolumnKeys: multiColumnKeys(data),\n\t\t\tcolumnTotals: multiColumnTotals(data),\n\t\t\tcolumnTotalsMax: multiColumnTotalsMax(data),\n\t\t\tvalueMin: multiValueMin(data),\n\t\t\tvalueMax: multiValueMax(data),\n\t\t\tvalueExtent: multiValueExtent(data),\n\t\t\tcoordinatesMin: multiCoordinatesMin(data),\n\t\t\tcoordinatesMax: multiCoordinatesMax(data),\n\t\t\tcoordinatesExtent: multiCoordinatesExtent(data),\n\t\t\tmaxDecimalPlace: multiMaxDecimalPlace(data),\n\t\t\tthresholds: multiThresholds(data),\n\t\t\trowValuesKeys: multiRowValueKeys(data)\n\t\t}\n\t};\n\n\t/************* MAIN FUNCTIONS **********************/\n\n\t/**\n\t * Summary\n\t *\n\t * @returns {Object}\n\t */\n\tconst summary = function() {\n\t\tif (dataType(data) === SINGLE_SERIES) {\n\t\t\treturn singleSummary(data);\n\t\t} else {\n\t\t\treturn multiSummary(data);\n\t\t}\n\t};\n\n\t/**\n\t * Rotate Data\n\t *\n\t * @returns {Array}\n\t */\n\tconst rotate = function() {\n\t\tconst columnKeys = data.map((d) => d.key);\n\t\tconst rowKeys = data[0].values.map((d) => d.key);\n\n\t\tconst rotated = rowKeys.map((rowKey, rowIndex) => {\n\t\t\tconst values = columnKeys.map((columnKey, columnIndex) => {\n\t\t\t\t// Copy the values from the original object\n\t\t\t\tconst values = Object.assign({}, data[columnIndex].values[rowIndex]);\n\t\t\t\t// Swap the key over\n\t\t\t\tvalues.key = columnKey;\n\n\t\t\t\treturn values;\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tkey: rowKey,\n\t\t\t\tvalues: values\n\t\t\t};\n\t\t});\n\n\t\treturn rotated;\n\t};\n\n\t/**\n\t * Smooth Data\n\t *\n\t * Returns a copy of the input data series which is subsampled into a 100 samples,\n\t * and has the smoothed values based on a provided d3.curve function.\n\t *\n\t * @param curveFunction\n\t * @returns {{values: *, key: *}}\n\t */\n\tconst smooth = function(curveFunction) {\n\t\tconst epsilon = 0.00001;\n\t\tconst samples = 100;\n\n\t\tconst values = data.values.map((d) => d.value);\n\n\t\tconst sampler = d3.range(0, 1, 1 / samples);\n\t\tconst keyPolator = (t) => (Number((t * samples).toFixed(0)) + 1);\n\n\t\tconst valuePolator = d3Interpolate.interpolateFromCurve(values, curveFunction, epsilon, samples);\n\n\t\tconst smoothed = {\n\t\t\tkey: data.key,\n\t\t\tvalues: sampler.map((t) => ({\n\t\t\t\tkey: keyPolator(t),\n\t\t\t\tvalue: valuePolator(t)\n\t\t\t}))\n\t\t};\n\n\t\treturn smoothed;\n\t};\n\n\treturn {\n\t\tsummary: summary,\n\t\trotate: rotate,\n\t\tsmooth: smooth\n\t};\n}\n\n\n"]},"metadata":{},"sourceType":"module"}