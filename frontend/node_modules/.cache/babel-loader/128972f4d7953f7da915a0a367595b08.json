{"ast":null,"code":"import { line as shapeLine, curveBasis } from \"d3-shape\";\nimport { range as arrayRange } from \"d3-array\";\nimport { interpolateBasis } from \"d3-interpolate\";\n/**\n * Curve Polator\n *\n * @param points\n * @param curveFunction\n * @param epsilon\n * @param samples\n * @returns {Function}\n */\n\nfunction curvePolator(points, curveFunction, epsilon, samples) {\n  // eslint-disable-line max-params\n  const path = shapeLine().curve(curveFunction)(points);\n  return svgPathInterpolator(path, epsilon, samples);\n}\n/**\n * SVG Path Interpolator\n *\n * @param path\n * @param epsilon\n * @param samples\n * @returns {Function}\n */\n\n\nfunction svgPathInterpolator(path, epsilon, samples) {\n  // Create detached SVG path\n  path = path || \"M0,0L1,1\";\n  const area = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n  area.innerHTML = \"<path></path>\";\n  const svgpath = area.querySelector(\"path\");\n  svgpath.setAttribute(\"d\", path); // Calculate lengths and max points\n\n  const totalLength = svgpath.getTotalLength();\n  const minPoint = svgpath.getPointAtLength(0);\n  const maxPoint = svgpath.getPointAtLength(totalLength);\n  let reverse = maxPoint.x < minPoint.x;\n  const range = reverse ? [maxPoint, minPoint] : [minPoint, maxPoint];\n  reverse = reverse ? -1 : 1; // Return function\n\n  return function (x) {\n    // Check for 0 and null/undefined\n    const targetX = x === 0 ? 0 : x || minPoint.x; // Clamp\n\n    if (targetX < range[0].x) return range[0];\n    if (targetX > range[1].x) return range[1];\n\n    function estimateLength(l, mn, mx) {\n      let delta = svgpath.getPointAtLength(l).x - targetX;\n      let nextDelta = 0;\n      let iter = 0;\n\n      while (Math.abs(delta) > epsilon && iter < samples) {\n        if (iter > samples) return false;\n        iter++;\n\n        if (reverse * delta < 0) {\n          mn = l;\n          l = (l + mx) / 2;\n        } else {\n          mx = l;\n          l = (mn + l) / 2;\n        }\n\n        nextDelta = svgpath.getPointAtLength(l).x - targetX;\n        delta = nextDelta;\n      }\n\n      return l;\n    }\n\n    const estimatedLength = estimateLength(totalLength / 2, 0, totalLength);\n    return svgpath.getPointAtLength(estimatedLength).y;\n  };\n}\n/**\n * Interpolate From Curve\n *\n * @param values\n * @param curveFunction\n * @param epsilon\n * @param samples\n * @returns {Function}\n */\n\n\nexport default function (values, curveFunction) {\n  let epsilon = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.00001;\n  let samples = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 100;\n  // eslint-disable-line max-params\n  const length = values.length;\n  const xrange = arrayRange(length).map(function (d, i) {\n    return i * (1 / (length - 1));\n  });\n  const points = values.map((v, i) => [xrange[i], v]); // If curveFunction is curveBasis then reach straight for D3's native 'interpolateBasis' function (it's faster!)\n\n  if (curveFunction === curveBasis) {\n    return interpolateBasis(values);\n  } else {\n    return curvePolator(points, curveFunction, epsilon, samples);\n  }\n}","map":{"version":3,"sources":["C:/Users/Michael Wilke/Desktop/Scout/frontend/node_modules/d3-interpolate-curve/src/fromCurve.js"],"names":["line","shapeLine","curveBasis","range","arrayRange","interpolateBasis","curvePolator","points","curveFunction","epsilon","samples","path","curve","svgPathInterpolator","area","document","createElementNS","innerHTML","svgpath","querySelector","setAttribute","totalLength","getTotalLength","minPoint","getPointAtLength","maxPoint","reverse","x","targetX","estimateLength","l","mn","mx","delta","nextDelta","iter","Math","abs","estimatedLength","y","values","length","xrange","map","d","i","v"],"mappings":"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","sourcesContent":["import { line as shapeLine, curveBasis } from \"d3-shape\";\nimport { range as arrayRange } from \"d3-array\";\nimport { interpolateBasis } from \"d3-interpolate\";\n\n/**\n * Curve Polator\n *\n * @param points\n * @param curveFunction\n * @param epsilon\n * @param samples\n * @returns {Function}\n */\nfunction curvePolator(points, curveFunction, epsilon, samples) { // eslint-disable-line max-params\n  const path = shapeLine().curve(curveFunction)(points);\n\n  return svgPathInterpolator(path, epsilon, samples);\n}\n\n/**\n * SVG Path Interpolator\n *\n * @param path\n * @param epsilon\n * @param samples\n * @returns {Function}\n */\nfunction svgPathInterpolator(path, epsilon, samples) {\n  // Create detached SVG path\n  path = path || \"M0,0L1,1\";\n\n  const area = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n  area.innerHTML = \"<path></path>\";\n  const svgpath = area.querySelector(\"path\");\n  svgpath.setAttribute(\"d\", path);\n\n  // Calculate lengths and max points\n  const totalLength = svgpath.getTotalLength();\n  const minPoint = svgpath.getPointAtLength(0);\n  const maxPoint = svgpath.getPointAtLength(totalLength);\n  let reverse = maxPoint.x < minPoint.x;\n  const range = reverse ? [maxPoint, minPoint] : [minPoint, maxPoint];\n  reverse = reverse ? -1 : 1;\n\n  // Return function\n  return function(x) {\n    // Check for 0 and null/undefined\n    const targetX = x === 0 ? 0 : x || minPoint.x;\n    // Clamp\n    if (targetX < range[0].x) return range[0];\n    if (targetX > range[1].x) return range[1];\n\n    function estimateLength(l, mn, mx) {\n      let delta = svgpath.getPointAtLength(l).x - targetX;\n      let nextDelta = 0;\n      let iter = 0;\n\n      while (Math.abs(delta) > epsilon && iter < samples) {\n        if (iter > samples) return false;\n        iter++;\n\n        if (reverse * delta < 0) {\n          mn = l;\n          l = (l + mx) / 2;\n        } else {\n          mx = l;\n          l = (mn + l) / 2;\n        }\n        nextDelta = svgpath.getPointAtLength(l).x - targetX;\n\n        delta = nextDelta;\n      }\n\n      return l;\n    }\n\n    const estimatedLength = estimateLength(totalLength / 2, 0, totalLength);\n\n    return svgpath.getPointAtLength(estimatedLength).y;\n  }\n}\n\n/**\n * Interpolate From Curve\n *\n * @param values\n * @param curveFunction\n * @param epsilon\n * @param samples\n * @returns {Function}\n */\nexport default function(values, curveFunction, epsilon = 0.00001, samples = 100) { // eslint-disable-line max-params\n  const length = values.length;\n  const xrange = arrayRange(length).map(function(d, i) { return i * (1 / (length - 1)); });\n  const points = values.map((v, i) => [xrange[i], v]);\n\n  // If curveFunction is curveBasis then reach straight for D3's native 'interpolateBasis' function (it's faster!)\n  if (curveFunction === curveBasis) {\n    return interpolateBasis(values);\n  } else {\n    return curvePolator(points, curveFunction, epsilon, samples);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}