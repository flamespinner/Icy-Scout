{"ast":null,"code":"import * as d3 from \"d3\";\nimport dataTransform from \"../dataTransform\";\nimport { dispatch } from \"../events\";\nimport { colorParse } from \"../colorHelper\";\n/**\n * Reusable 3D Ribbon Chart Component\n *\n * @module\n */\n\nexport default function () {\n  /* Default Properties */\n  let dimensions = {\n    x: 40,\n    y: 40,\n    z: 5\n  };\n  let color = \"red\";\n  let transparency = 0.1;\n  let classed = \"d3X3dRibbon\";\n  let smoothed = d3.curveBasis;\n  /* Scales */\n\n  let xScale;\n  let yScale;\n  /**\n   * Array to String\n   *\n   * @private\n   * @param {array} arr\n   * @returns {string}\n   */\n\n  const array2dToString = function (arr) {\n    return arr.reduce((a, b) => a.concat(b), []).reduce((a, b) => a.concat(b), []).join(\" \");\n  };\n  /**\n   * Array to Coordinate Index\n   *\n   * @private\n   * @param {array} arr\n   * @returns {string}\n   */\n\n\n  const arrayToCoordIndex = function (arr) {\n    return arr.map((d, i) => i).join(\" \").concat(\" -1\");\n  };\n  /**\n   * Initialise Data and Scales\n   *\n   * @private\n   * @param {Array} data - Chart data.\n   */\n\n\n  const init = function (data) {\n    const {\n      columnKeys,\n      valueMax\n    } = dataTransform(data).summary();\n    const valueExtent = [0, valueMax];\n    const {\n      x: dimensionX,\n      y: dimensionY\n    } = dimensions;\n\n    if (typeof xScale === \"undefined\") {\n      xScale = d3.scalePoint().domain(columnKeys).range([0, dimensionX]);\n    }\n\n    if (typeof yScale === \"undefined\") {\n      yScale = d3.scaleLinear().domain(valueExtent).range([0, dimensionY]);\n    }\n  };\n  /**\n   * Constructor\n   *\n   * @constructor\n   * @alias ribbon\n   * @param {d3.selection} selection - The chart holder D3 selection.\n   */\n\n\n  const my = function (selection) {\n    selection.each(function (data) {\n      init(data);\n      const element = d3.select(this).classed(classed, true).attr(\"id\", d => d.key);\n\n      const ribbonData = function (data) {\n        const dimensionX = dimensions.x;\n\n        if (smoothed) {\n          data = dataTransform(data).smooth(smoothed);\n          const keys = d3.extent(data.values.map(d => d.key));\n          xScale = d3.scaleLinear().domain(keys).range([0, dimensionX]);\n        }\n\n        let values = data.values; // Convert values into IFS coordinates\n\n        let coords = values.map((pointThis, indexThis, array) => {\n          let indexNext = indexThis + 1;\n\n          if (indexNext >= array.length) {\n            return null;\n          }\n\n          let pointNext = array[indexNext];\n          let x1 = xScale(pointThis.key);\n          let x2 = xScale(pointNext.key);\n          let y1 = yScale(pointThis.value);\n          let y2 = yScale(pointNext.value);\n          let z1 = 1 - dimensions.z / 2;\n          let z2 = dimensions.z / 2;\n          return [x1, y1, z1, x1, y1, z2, x2, y2, z2, x2, y2, z1];\n        }).filter(d => d !== null);\n        data.point = coords.map(d => d.join(\" \")).join(\" \");\n        data.coordIndex = coords.map((d, i) => {\n          const offset = i * 4;\n          return [offset, offset + 1, offset + 2, offset + 3, -1].join(\" \");\n        }).join(\" \");\n        return [data];\n      };\n\n      const shape = el => {\n        const shape = el.append(\"Shape\");\n        /*\n        // FIXME: x3dom cannot have empty IFS nodes, we must to use .html() rather than .append() & .attr().\n        shape.append(\"IndexedFaceset\")\n        \t.attr(\"coordIndex\", (d) => d.coordIndex)\n        \t.append(\"Coordinate\")\n        \t.attr(\"point\", (d) => d.point);\n        \tshape.append(\"Appearance\")\n        \t.append(\"Material\")\n        \t.attr(\"diffuseColor\", colorParse(color))\n        \t.attr(\"transparency\", transparency);\n        */\n\n        shape.html(d => `\n\t\t\t\t\t<IndexedFaceset coordIndex=\"${d.coordIndex}\"  solid=\"false\">\n\t\t\t\t\t\t<Coordinate point=\"${d.point}\"></Coordinate>\n\t\t\t\t\t</IndexedFaceset>\n\t\t\t\t\t<Appearance>\n\t\t\t\t\t\t<Material diffuseColor=\"${colorParse(color)}\" transparency=\"${transparency}\"></Material>\n\t\t\t\t\t</Appearance>\n\t\t\t\t`);\n      };\n\n      const ribbon = element.selectAll(\".ribbon\").data(d => ribbonData(d), d => d.key);\n      ribbon.enter().append(\"Group\").classed(\"ribbon\", true).call(shape).merge(ribbon);\n      const ribbonTransition = ribbon.transition().select(\"Shape\");\n      ribbonTransition.select(\"IndexedFaceset\").attr(\"coordIndex\", d => d.coordIndex).select(\"Coordinate\").attr(\"point\", d => d.point);\n      ribbonTransition.select(\"Appearance\").select(\"Material\").attr(\"diffuseColor\", colorParse(color));\n      ribbon.exit().remove();\n    });\n  };\n  /**\n   * Dimensions Getter / Setter\n   *\n   * @param {{x: {number}, y: {number}, z: {number}}} _v - 3D Object dimensions.\n   * @returns {*}\n   */\n\n\n  my.dimensions = function (_v) {\n    if (!arguments.length) return dimensions;\n    dimensions = _v;\n    return this;\n  };\n  /**\n   * X Scale Getter / Setter\n   *\n   * @param {d3.scale} _v - D3 scale.\n   * @returns {*}\n   */\n\n\n  my.xScale = function (_v) {\n    if (!arguments.length) return xScale;\n    xScale = _v;\n    return my;\n  };\n  /**\n   * Y Scale Getter / Setter\n   *\n   * @param {d3.scale} _v - D3 scale.\n   * @returns {*}\n   */\n\n\n  my.yScale = function (_v) {\n    if (!arguments.length) return yScale;\n    yScale = _v;\n    return my;\n  };\n  /**\n   * Color Getter / Setter\n   *\n   * @param {string} _v - Color (e.g. \"red\" or \"#ff0000\").\n   * @returns {*}\n   */\n\n\n  my.color = function (_v) {\n    if (!arguments.length) return color;\n    color = _v;\n    return my;\n  };\n  /**\n   * Smooth Interpolation Getter / Setter\n   *\n   * Options:\n   *   d3.curveBasis\n   *   d3.curveLinear\n   *   d3.curveMonotoneX\n   *\n   * @param {d3.curve} _v.\n   * @returns {*}\n   */\n\n\n  my.smoothed = function (_v) {\n    if (!arguments.length) return smoothed;\n    smoothed = _v;\n    return my;\n  };\n  /**\n   * Dispatch On Getter\n   *\n   * @returns {*}\n   */\n\n\n  my.on = function () {\n    let value = dispatch.on.apply(dispatch, arguments);\n    return value === dispatch ? my : value;\n  };\n\n  return my;\n}","map":{"version":3,"sources":["C:/Users/Michael Wilke/Desktop/Scout/frontend/node_modules/d3-x3d/src/component/ribbon.js"],"names":["d3","dataTransform","dispatch","colorParse","dimensions","x","y","z","color","transparency","classed","smoothed","curveBasis","xScale","yScale","array2dToString","arr","reduce","a","b","concat","join","arrayToCoordIndex","map","d","i","init","data","columnKeys","valueMax","summary","valueExtent","dimensionX","dimensionY","scalePoint","domain","range","scaleLinear","my","selection","each","element","select","attr","key","ribbonData","smooth","keys","extent","values","coords","pointThis","indexThis","array","indexNext","length","pointNext","x1","x2","y1","value","y2","z1","z2","filter","point","coordIndex","offset","shape","el","append","html","ribbon","selectAll","enter","call","merge","ribbonTransition","transition","exit","remove","_v","arguments","on","apply"],"mappings":"AAAA,OAAO,KAAKA,EAAZ,MAAoB,IAApB;AACA,OAAOC,aAAP,MAA0B,kBAA1B;AACA,SAASC,QAAT,QAAyB,WAAzB;AACA,SAASC,UAAT,QAA2B,gBAA3B;AAEA;AACA;AACA;AACA;AACA;;AACA,eAAe,YAAW;AAEzB;AACA,MAAIC,UAAU,GAAG;AAAEC,IAAAA,CAAC,EAAE,EAAL;AAASC,IAAAA,CAAC,EAAE,EAAZ;AAAgBC,IAAAA,CAAC,EAAE;AAAnB,GAAjB;AACA,MAAIC,KAAK,GAAG,KAAZ;AACA,MAAIC,YAAY,GAAG,GAAnB;AACA,MAAIC,OAAO,GAAG,aAAd;AACA,MAAIC,QAAQ,GAAGX,EAAE,CAACY,UAAlB;AAEA;;AACA,MAAIC,MAAJ;AACA,MAAIC,MAAJ;AAEA;AACD;AACA;AACA;AACA;AACA;AACA;;AACC,QAAMC,eAAe,GAAG,UAASC,GAAT,EAAc;AACrC,WAAOA,GAAG,CAACC,MAAJ,CAAW,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAACE,MAAF,CAASD,CAAT,CAArB,EAAkC,EAAlC,EACLF,MADK,CACE,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAACE,MAAF,CAASD,CAAT,CADZ,EACyB,EADzB,EAELE,IAFK,CAEA,GAFA,CAAP;AAGA,GAJD;AAMA;AACD;AACA;AACA;AACA;AACA;AACA;;;AACC,QAAMC,iBAAiB,GAAG,UAASN,GAAT,EAAc;AACvC,WAAOA,GAAG,CAACO,GAAJ,CAAQ,CAACC,CAAD,EAAIC,CAAJ,KAAUA,CAAlB,EACLJ,IADK,CACA,GADA,EAELD,MAFK,CAEE,KAFF,CAAP;AAGA,GAJD;AAMA;AACD;AACA;AACA;AACA;AACA;;;AACC,QAAMM,IAAI,GAAG,UAASC,IAAT,EAAe;AAC3B,UAAM;AAAEC,MAAAA,UAAF;AAAcC,MAAAA;AAAd,QAA2B5B,aAAa,CAAC0B,IAAD,CAAb,CAAoBG,OAApB,EAAjC;AACA,UAAMC,WAAW,GAAG,CAAC,CAAD,EAAIF,QAAJ,CAApB;AACA,UAAM;AAAExB,MAAAA,CAAC,EAAE2B,UAAL;AAAiB1B,MAAAA,CAAC,EAAE2B;AAApB,QAAmC7B,UAAzC;;AAEA,QAAI,OAAOS,MAAP,KAAkB,WAAtB,EAAmC;AAClCA,MAAAA,MAAM,GAAGb,EAAE,CAACkC,UAAH,GACPC,MADO,CACAP,UADA,EAEPQ,KAFO,CAED,CAAC,CAAD,EAAIJ,UAAJ,CAFC,CAAT;AAGA;;AAED,QAAI,OAAOlB,MAAP,KAAkB,WAAtB,EAAmC;AAClCA,MAAAA,MAAM,GAAGd,EAAE,CAACqC,WAAH,GACPF,MADO,CACAJ,WADA,EAEPK,KAFO,CAED,CAAC,CAAD,EAAIH,UAAJ,CAFC,CAAT;AAGA;AACD,GAhBD;AAkBA;AACD;AACA;AACA;AACA;AACA;AACA;;;AACC,QAAMK,EAAE,GAAG,UAASC,SAAT,EAAoB;AAC9BA,IAAAA,SAAS,CAACC,IAAV,CAAe,UAASb,IAAT,EAAe;AAC7BD,MAAAA,IAAI,CAACC,IAAD,CAAJ;AAEA,YAAMc,OAAO,GAAGzC,EAAE,CAAC0C,MAAH,CAAU,IAAV,EACdhC,OADc,CACNA,OADM,EACG,IADH,EAEdiC,IAFc,CAET,IAFS,EAEFnB,CAAD,IAAOA,CAAC,CAACoB,GAFN,CAAhB;;AAIA,YAAMC,UAAU,GAAG,UAASlB,IAAT,EAAe;AACjC,cAAMK,UAAU,GAAG5B,UAAU,CAACC,CAA9B;;AAEA,YAAIM,QAAJ,EAAc;AACbgB,UAAAA,IAAI,GAAG1B,aAAa,CAAC0B,IAAD,CAAb,CAAoBmB,MAApB,CAA2BnC,QAA3B,CAAP;AAEA,gBAAMoC,IAAI,GAAG/C,EAAE,CAACgD,MAAH,CAAUrB,IAAI,CAACsB,MAAL,CAAY1B,GAAZ,CAAiBC,CAAD,IAAOA,CAAC,CAACoB,GAAzB,CAAV,CAAb;AACA/B,UAAAA,MAAM,GAAGb,EAAE,CAACqC,WAAH,GACPF,MADO,CACAY,IADA,EAEPX,KAFO,CAED,CAAC,CAAD,EAAIJ,UAAJ,CAFC,CAAT;AAGA;;AAED,YAAIiB,MAAM,GAAGtB,IAAI,CAACsB,MAAlB,CAZiC,CAcjC;;AACA,YAAIC,MAAM,GAAGD,MAAM,CAAC1B,GAAP,CAAW,CAAC4B,SAAD,EAAYC,SAAZ,EAAuBC,KAAvB,KAAiC;AACxD,cAAIC,SAAS,GAAGF,SAAS,GAAG,CAA5B;;AACA,cAAIE,SAAS,IAAID,KAAK,CAACE,MAAvB,EAA+B;AAC9B,mBAAO,IAAP;AACA;;AACD,cAAIC,SAAS,GAAGH,KAAK,CAACC,SAAD,CAArB;AAEA,cAAIG,EAAE,GAAG5C,MAAM,CAACsC,SAAS,CAACP,GAAX,CAAf;AACA,cAAIc,EAAE,GAAG7C,MAAM,CAAC2C,SAAS,CAACZ,GAAX,CAAf;AACA,cAAIe,EAAE,GAAG7C,MAAM,CAACqC,SAAS,CAACS,KAAX,CAAf;AACA,cAAIC,EAAE,GAAG/C,MAAM,CAAC0C,SAAS,CAACI,KAAX,CAAf;AACA,cAAIE,EAAE,GAAG,IAAK1D,UAAU,CAACG,CAAZ,GAAiB,CAA9B;AACA,cAAIwD,EAAE,GAAI3D,UAAU,CAACG,CAAZ,GAAiB,CAA1B;AAEA,iBAAO,CAACkD,EAAD,EAAKE,EAAL,EAASG,EAAT,EAAaL,EAAb,EAAiBE,EAAjB,EAAqBI,EAArB,EAAyBL,EAAzB,EAA6BG,EAA7B,EAAiCE,EAAjC,EAAqCL,EAArC,EAAyCG,EAAzC,EAA6CC,EAA7C,CAAP;AACA,SAfY,EAeVE,MAfU,CAeFxC,CAAD,IAAOA,CAAC,KAAK,IAfV,CAAb;AAiBAG,QAAAA,IAAI,CAACsC,KAAL,GAAaf,MAAM,CAAC3B,GAAP,CAAYC,CAAD,IAAOA,CAAC,CAACH,IAAF,CAAO,GAAP,CAAlB,EAA+BA,IAA/B,CAAoC,GAApC,CAAb;AACAM,QAAAA,IAAI,CAACuC,UAAL,GAAkBhB,MAAM,CAAC3B,GAAP,CAAW,CAACC,CAAD,EAAIC,CAAJ,KAAU;AACtC,gBAAM0C,MAAM,GAAG1C,CAAC,GAAG,CAAnB;AACA,iBAAO,CAAC0C,MAAD,EAASA,MAAM,GAAG,CAAlB,EAAqBA,MAAM,GAAG,CAA9B,EAAiCA,MAAM,GAAG,CAA1C,EAA6C,CAAC,CAA9C,EAAiD9C,IAAjD,CAAsD,GAAtD,CAAP;AACA,SAHiB,EAGfA,IAHe,CAGV,GAHU,CAAlB;AAKA,eAAO,CAACM,IAAD,CAAP;AACA,OAvCD;;AAyCA,YAAMyC,KAAK,GAAIC,EAAD,IAAQ;AACrB,cAAMD,KAAK,GAAGC,EAAE,CAACC,MAAH,CAAU,OAAV,CAAd;AAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGIF,QAAAA,KAAK,CAACG,IAAN,CAAY/C,CAAD,IAAQ;AACvB,mCAAmCA,CAAC,CAAC0C,UAAW;AAChD,2BAA2B1C,CAAC,CAACyC,KAAM;AACnC;AACA;AACA,gCAAgC9D,UAAU,CAACK,KAAD,CAAQ,mBAAkBC,YAAa;AACjF;AACA,KAPI;AAQA,OAxBD;;AA0BA,YAAM+D,MAAM,GAAG/B,OAAO,CAACgC,SAAR,CAAkB,SAAlB,EACb9C,IADa,CACPH,CAAD,IAAOqB,UAAU,CAACrB,CAAD,CADT,EACeA,CAAD,IAAOA,CAAC,CAACoB,GADvB,CAAf;AAGA4B,MAAAA,MAAM,CAACE,KAAP,GACEJ,MADF,CACS,OADT,EAEE5D,OAFF,CAEU,QAFV,EAEoB,IAFpB,EAGEiE,IAHF,CAGOP,KAHP,EAIEQ,KAJF,CAIQJ,MAJR;AAMA,YAAMK,gBAAgB,GAAGL,MAAM,CAACM,UAAP,GAAoBpC,MAApB,CAA2B,OAA3B,CAAzB;AAEAmC,MAAAA,gBAAgB,CAACnC,MAAjB,CAAwB,gBAAxB,EACEC,IADF,CACO,YADP,EACsBnB,CAAD,IAAOA,CAAC,CAAC0C,UAD9B,EAEExB,MAFF,CAES,YAFT,EAGEC,IAHF,CAGO,OAHP,EAGiBnB,CAAD,IAAOA,CAAC,CAACyC,KAHzB;AAKAY,MAAAA,gBAAgB,CAACnC,MAAjB,CAAwB,YAAxB,EACEA,MADF,CACS,UADT,EAEEC,IAFF,CAEO,cAFP,EAEuBxC,UAAU,CAACK,KAAD,CAFjC;AAIAgE,MAAAA,MAAM,CAACO,IAAP,GACEC,MADF;AAGA,KAjGD;AAkGA,GAnGD;AAqGA;AACD;AACA;AACA;AACA;AACA;;;AACC1C,EAAAA,EAAE,CAAClC,UAAH,GAAgB,UAAS6E,EAAT,EAAa;AAC5B,QAAI,CAACC,SAAS,CAAC3B,MAAf,EAAuB,OAAOnD,UAAP;AACvBA,IAAAA,UAAU,GAAG6E,EAAb;AACA,WAAO,IAAP;AACA,GAJD;AAMA;AACD;AACA;AACA;AACA;AACA;;;AACC3C,EAAAA,EAAE,CAACzB,MAAH,GAAY,UAASoE,EAAT,EAAa;AACxB,QAAI,CAACC,SAAS,CAAC3B,MAAf,EAAuB,OAAO1C,MAAP;AACvBA,IAAAA,MAAM,GAAGoE,EAAT;AACA,WAAO3C,EAAP;AACA,GAJD;AAMA;AACD;AACA;AACA;AACA;AACA;;;AACCA,EAAAA,EAAE,CAACxB,MAAH,GAAY,UAASmE,EAAT,EAAa;AACxB,QAAI,CAACC,SAAS,CAAC3B,MAAf,EAAuB,OAAOzC,MAAP;AACvBA,IAAAA,MAAM,GAAGmE,EAAT;AACA,WAAO3C,EAAP;AACA,GAJD;AAMA;AACD;AACA;AACA;AACA;AACA;;;AACCA,EAAAA,EAAE,CAAC9B,KAAH,GAAW,UAASyE,EAAT,EAAa;AACvB,QAAI,CAACC,SAAS,CAAC3B,MAAf,EAAuB,OAAO/C,KAAP;AACvBA,IAAAA,KAAK,GAAGyE,EAAR;AACA,WAAO3C,EAAP;AACA,GAJD;AAMA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCA,EAAAA,EAAE,CAAC3B,QAAH,GAAc,UAASsE,EAAT,EAAa;AAC1B,QAAI,CAACC,SAAS,CAAC3B,MAAf,EAAuB,OAAO5C,QAAP;AACvBA,IAAAA,QAAQ,GAAGsE,EAAX;AACA,WAAO3C,EAAP;AACA,GAJD;AAMA;AACD;AACA;AACA;AACA;;;AACCA,EAAAA,EAAE,CAAC6C,EAAH,GAAQ,YAAW;AAClB,QAAIvB,KAAK,GAAG1D,QAAQ,CAACiF,EAAT,CAAYC,KAAZ,CAAkBlF,QAAlB,EAA4BgF,SAA5B,CAAZ;AACA,WAAOtB,KAAK,KAAK1D,QAAV,GAAqBoC,EAArB,GAA0BsB,KAAjC;AACA,GAHD;;AAKA,SAAOtB,EAAP;AACA","sourcesContent":["import * as d3 from \"d3\";\nimport dataTransform from \"../dataTransform\";\nimport { dispatch } from \"../events\";\nimport { colorParse } from \"../colorHelper\";\n\n/**\n * Reusable 3D Ribbon Chart Component\n *\n * @module\n */\nexport default function() {\n\n\t/* Default Properties */\n\tlet dimensions = { x: 40, y: 40, z: 5 };\n\tlet color = \"red\";\n\tlet transparency = 0.1;\n\tlet classed = \"d3X3dRibbon\";\n\tlet smoothed = d3.curveBasis;\n\n\t/* Scales */\n\tlet xScale;\n\tlet yScale;\n\n\t/**\n\t * Array to String\n\t *\n\t * @private\n\t * @param {array} arr\n\t * @returns {string}\n\t */\n\tconst array2dToString = function(arr) {\n\t\treturn arr.reduce((a, b) => a.concat(b), [])\n\t\t\t.reduce((a, b) => a.concat(b), [])\n\t\t\t.join(\" \");\n\t};\n\n\t/**\n\t * Array to Coordinate Index\n\t *\n\t * @private\n\t * @param {array} arr\n\t * @returns {string}\n\t */\n\tconst arrayToCoordIndex = function(arr) {\n\t\treturn arr.map((d, i) => i)\n\t\t\t.join(\" \")\n\t\t\t.concat(\" -1\");\n\t};\n\n\t/**\n\t * Initialise Data and Scales\n\t *\n\t * @private\n\t * @param {Array} data - Chart data.\n\t */\n\tconst init = function(data) {\n\t\tconst { columnKeys, valueMax } = dataTransform(data).summary();\n\t\tconst valueExtent = [0, valueMax];\n\t\tconst { x: dimensionX, y: dimensionY } = dimensions;\n\n\t\tif (typeof xScale === \"undefined\") {\n\t\t\txScale = d3.scalePoint()\n\t\t\t\t.domain(columnKeys)\n\t\t\t\t.range([0, dimensionX]);\n\t\t}\n\n\t\tif (typeof yScale === \"undefined\") {\n\t\t\tyScale = d3.scaleLinear()\n\t\t\t\t.domain(valueExtent)\n\t\t\t\t.range([0, dimensionY]);\n\t\t}\n\t};\n\n\t/**\n\t * Constructor\n\t *\n\t * @constructor\n\t * @alias ribbon\n\t * @param {d3.selection} selection - The chart holder D3 selection.\n\t */\n\tconst my = function(selection) {\n\t\tselection.each(function(data) {\n\t\t\tinit(data);\n\n\t\t\tconst element = d3.select(this)\n\t\t\t\t.classed(classed, true)\n\t\t\t\t.attr(\"id\", (d) => d.key);\n\n\t\t\tconst ribbonData = function(data) {\n\t\t\t\tconst dimensionX = dimensions.x;\n\n\t\t\t\tif (smoothed) {\n\t\t\t\t\tdata = dataTransform(data).smooth(smoothed);\n\n\t\t\t\t\tconst keys = d3.extent(data.values.map((d) => d.key));\n\t\t\t\t\txScale = d3.scaleLinear()\n\t\t\t\t\t\t.domain(keys)\n\t\t\t\t\t\t.range([0, dimensionX]);\n\t\t\t\t}\n\n\t\t\t\tlet values = data.values;\n\n\t\t\t\t// Convert values into IFS coordinates\n\t\t\t\tlet coords = values.map((pointThis, indexThis, array) => {\n\t\t\t\t\tlet indexNext = indexThis + 1;\n\t\t\t\t\tif (indexNext >= array.length) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tlet pointNext = array[indexNext];\n\n\t\t\t\t\tlet x1 = xScale(pointThis.key);\n\t\t\t\t\tlet x2 = xScale(pointNext.key);\n\t\t\t\t\tlet y1 = yScale(pointThis.value);\n\t\t\t\t\tlet y2 = yScale(pointNext.value);\n\t\t\t\t\tlet z1 = 1 - (dimensions.z) / 2;\n\t\t\t\t\tlet z2 = (dimensions.z) / 2;\n\n\t\t\t\t\treturn [x1, y1, z1, x1, y1, z2, x2, y2, z2, x2, y2, z1];\n\t\t\t\t}).filter((d) => d !== null);\n\n\t\t\t\tdata.point = coords.map((d) => d.join(\" \")).join(\" \");\n\t\t\t\tdata.coordIndex = coords.map((d, i) => {\n\t\t\t\t\tconst offset = i * 4;\n\t\t\t\t\treturn [offset, offset + 1, offset + 2, offset + 3, -1].join(\" \");\n\t\t\t\t}).join(\" \");\n\n\t\t\t\treturn [data];\n\t\t\t};\n\n\t\t\tconst shape = (el) => {\n\t\t\t\tconst shape = el.append(\"Shape\");\n\n\t\t\t\t/*\n\t\t\t\t// FIXME: x3dom cannot have empty IFS nodes, we must to use .html() rather than .append() & .attr().\n\t\t\t\tshape.append(\"IndexedFaceset\")\n\t\t\t\t\t.attr(\"coordIndex\", (d) => d.coordIndex)\n\t\t\t\t\t.append(\"Coordinate\")\n\t\t\t\t\t.attr(\"point\", (d) => d.point);\n\n\t\t\t\tshape.append(\"Appearance\")\n\t\t\t\t\t.append(\"Material\")\n\t\t\t\t\t.attr(\"diffuseColor\", colorParse(color))\n\t\t\t\t\t.attr(\"transparency\", transparency);\n\t\t\t\t*/\n\n\t\t\t\tshape.html((d) => `\n\t\t\t\t\t<IndexedFaceset coordIndex=\"${d.coordIndex}\"  solid=\"false\">\n\t\t\t\t\t\t<Coordinate point=\"${d.point}\"></Coordinate>\n\t\t\t\t\t</IndexedFaceset>\n\t\t\t\t\t<Appearance>\n\t\t\t\t\t\t<Material diffuseColor=\"${colorParse(color)}\" transparency=\"${transparency}\"></Material>\n\t\t\t\t\t</Appearance>\n\t\t\t\t`);\n\t\t\t};\n\n\t\t\tconst ribbon = element.selectAll(\".ribbon\")\n\t\t\t\t.data((d) => ribbonData(d), (d) => d.key);\n\n\t\t\tribbon.enter()\n\t\t\t\t.append(\"Group\")\n\t\t\t\t.classed(\"ribbon\", true)\n\t\t\t\t.call(shape)\n\t\t\t\t.merge(ribbon);\n\n\t\t\tconst ribbonTransition = ribbon.transition().select(\"Shape\");\n\n\t\t\tribbonTransition.select(\"IndexedFaceset\")\n\t\t\t\t.attr(\"coordIndex\", (d) => d.coordIndex)\n\t\t\t\t.select(\"Coordinate\")\n\t\t\t\t.attr(\"point\", (d) => d.point);\n\n\t\t\tribbonTransition.select(\"Appearance\")\n\t\t\t\t.select(\"Material\")\n\t\t\t\t.attr(\"diffuseColor\", colorParse(color));\n\n\t\t\tribbon.exit()\n\t\t\t\t.remove();\n\n\t\t});\n\t};\n\n\t/**\n\t * Dimensions Getter / Setter\n\t *\n\t * @param {{x: {number}, y: {number}, z: {number}}} _v - 3D Object dimensions.\n\t * @returns {*}\n\t */\n\tmy.dimensions = function(_v) {\n\t\tif (!arguments.length) return dimensions;\n\t\tdimensions = _v;\n\t\treturn this;\n\t};\n\n\t/**\n\t * X Scale Getter / Setter\n\t *\n\t * @param {d3.scale} _v - D3 scale.\n\t * @returns {*}\n\t */\n\tmy.xScale = function(_v) {\n\t\tif (!arguments.length) return xScale;\n\t\txScale = _v;\n\t\treturn my;\n\t};\n\n\t/**\n\t * Y Scale Getter / Setter\n\t *\n\t * @param {d3.scale} _v - D3 scale.\n\t * @returns {*}\n\t */\n\tmy.yScale = function(_v) {\n\t\tif (!arguments.length) return yScale;\n\t\tyScale = _v;\n\t\treturn my;\n\t};\n\n\t/**\n\t * Color Getter / Setter\n\t *\n\t * @param {string} _v - Color (e.g. \"red\" or \"#ff0000\").\n\t * @returns {*}\n\t */\n\tmy.color = function(_v) {\n\t\tif (!arguments.length) return color;\n\t\tcolor = _v;\n\t\treturn my;\n\t};\n\n\t/**\n\t * Smooth Interpolation Getter / Setter\n\t *\n\t * Options:\n\t *   d3.curveBasis\n\t *   d3.curveLinear\n\t *   d3.curveMonotoneX\n\t *\n\t * @param {d3.curve} _v.\n\t * @returns {*}\n\t */\n\tmy.smoothed = function(_v) {\n\t\tif (!arguments.length) return smoothed;\n\t\tsmoothed = _v;\n\t\treturn my;\n\t};\n\n\t/**\n\t * Dispatch On Getter\n\t *\n\t * @returns {*}\n\t */\n\tmy.on = function() {\n\t\tlet value = dispatch.on.apply(dispatch, arguments);\n\t\treturn value === dispatch ? my : value;\n\t};\n\n\treturn my;\n}\n"]},"metadata":{},"sourceType":"module"}