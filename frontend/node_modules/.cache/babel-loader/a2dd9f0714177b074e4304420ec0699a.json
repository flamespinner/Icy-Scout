{"ast":null,"code":"import * as d3 from \"d3\";\nimport dataTransform from \"../dataTransform\";\nimport { dispatch } from \"../events\";\nimport { colorParse } from \"../colorHelper\";\n/**\n * Reusable 3D Surface Area Component\n *\n * @module\n */\n\nexport default function () {\n  /* Default Properties */\n  let dimensions = {\n    x: 40,\n    y: 40,\n    z: 40\n  };\n  let colors = [\"blue\", \"red\"];\n  let classed = \"d3X3dSurface\";\n  /* Scales */\n\n  let xScale;\n  let yScale;\n  let zScale;\n  let colorScale;\n  /**\n   * Array to String\n   *\n   * @private\n   * @param {array} arr\n   * @returns {string}\n   */\n\n  const array2dToString = function (arr) {\n    return arr.reduce((a, b) => a.concat(b), []).reduce((a, b) => a.concat(b), []).join(\" \");\n  };\n  /**\n   * Initialise Data and Scales\n   *\n   * @private\n   * @param {Array} data - Chart data.\n   */\n\n\n  const init = function (data) {\n    const {\n      rowKeys,\n      columnKeys,\n      valueMax\n    } = dataTransform(data).summary();\n    const valueExtent = [0, valueMax];\n    const {\n      x: dimensionX,\n      y: dimensionY,\n      z: dimensionZ\n    } = dimensions;\n\n    if (typeof xScale === \"undefined\") {\n      xScale = d3.scalePoint().domain(rowKeys).range([0, dimensionX]);\n    }\n\n    if (typeof yScale === \"undefined\") {\n      yScale = d3.scaleLinear().domain(valueExtent).range([0, dimensionY]);\n    }\n\n    if (typeof zScale === \"undefined\") {\n      zScale = d3.scalePoint().domain(columnKeys).range([0, dimensionZ]);\n    }\n\n    if (typeof colorScale === \"undefined\") {\n      colorScale = d3.scaleLinear().domain(valueExtent).range(colors).interpolate(d3.interpolateLab);\n    }\n  };\n  /**\n   * Constructor\n   *\n   * @constructor\n   * @alias surface\n   * @param {d3.selection} selection - The chart holder D3 selection.\n   */\n\n\n  const my = function (selection) {\n    selection.each(function (data) {\n      init(data);\n      const element = d3.select(this).classed(classed, true);\n\n      const surfaceData = function (data) {\n        const coordPoints = function (Y) {\n          return Y.map(function (X) {\n            return X.values.map(function (d) {\n              return [xScale(X.key), yScale(d.value), zScale(d.key)];\n            });\n          });\n        };\n\n        const coordIndex = function (Y) {\n          let ny = Y.length;\n          let nx = Y[0].values.length;\n          return Array.apply(0, Array(ny - 1)).map(function (_, j) {\n            return Array.apply(0, Array(nx - 1)).map(function (_, i) {\n              const start = i + j * nx;\n              return [start, start + 1, start + nx + 1, start + nx, start, -1];\n            });\n          });\n        };\n\n        const colorFaceSet = function (Y) {\n          return Y.map(function (X) {\n            return X.values.map(function (d) {\n              const color = d3.color(colorScale(d.value));\n              return colorParse(color);\n            });\n          });\n        };\n\n        data.coordIndex = array2dToString(coordIndex(data));\n        data.point = array2dToString(coordPoints(data));\n        data.color = array2dToString(colorFaceSet(data));\n        return [data];\n      };\n\n      const shape = el => {\n        const shape = el.append(\"Shape\").classed(\"surface\", true);\n        const ifs = shape.append(\"IndexedFaceset\").attr(\"coordIndex\", d => d.coordIndex).attr(\"solid\", false);\n        ifs.append(\"Coordinate\").attr(\"point\", d => d.point);\n        ifs.append(\"Color\").attr(\"color\", d => d.color);\n        return shape;\n      };\n\n      const surface = element.selectAll(\".surface\").data(d => surfaceData(d), d => d.key);\n      surface.enter().call(shape).merge(surface);\n      const surfaceTransition = surface.transition().select(\"IndexedFaceset\").attr(\"coordIndex\", d => d.coordIndex);\n      surfaceTransition.select(\"coordinate\").attr(\"point\", d => d.point);\n      surfaceTransition.select(\"color\").attr(\"color\", d => d.color);\n      surface.exit().remove();\n    });\n  };\n  /**\n   * Dimensions Getter / Setter\n   *\n   * @param {{x: number, y: number, z: number}} _v - 3D object dimensions.\n   * @returns {*}\n   */\n\n\n  my.dimensions = function (_v) {\n    if (!arguments.length) return dimensions;\n    dimensions = _v;\n    return this;\n  };\n  /**\n   * X Scale Getter / Setter\n   *\n   * @param {d3.scale} _v - D3 scale.\n   * @returns {*}\n   */\n\n\n  my.xScale = function (_v) {\n    if (!arguments.length) return xScale;\n    xScale = _v;\n    return my;\n  };\n  /**\n   * Y Scale Getter / Setter\n   *\n   * @param {d3.scale} _v - D3 scale.\n   * @returns {*}\n   */\n\n\n  my.yScale = function (_v) {\n    if (!arguments.length) return yScale;\n    yScale = _v;\n    return my;\n  };\n  /**\n   * Z Scale Getter / Setter\n   *\n   * @param {d3.scale} _v - D3 scale.\n   * @returns {*}\n   */\n\n\n  my.zScale = function (_v) {\n    if (!arguments.length) return zScale;\n    zScale = _v;\n    return my;\n  };\n  /**\n   * Color Scale Getter / Setter\n   *\n   * @param {d3.scale} _v - D3 color scale.\n   * @returns {*}\n   */\n\n\n  my.colorScale = function (_v) {\n    if (!arguments.length) return colorScale;\n    colorScale = _v;\n    return my;\n  };\n  /**\n   * Colors Getter / Setter\n   *\n   * @param {Array} _v - Array of colours used by color scale.\n   * @returns {*}\n   */\n\n\n  my.colors = function (_v) {\n    if (!arguments.length) return colors;\n    colors = _v;\n    return my;\n  };\n  /**\n   * Dispatch On Getter\n   *\n   * @returns {*}\n   */\n\n\n  my.on = function () {\n    let value = dispatch.on.apply(dispatch, arguments);\n    return value === dispatch ? my : value;\n  };\n\n  return my;\n}","map":{"version":3,"sources":["C:/Users/Michael Wilke/Desktop/Scout/frontend/node_modules/d3-x3d/src/component/surface.js"],"names":["d3","dataTransform","dispatch","colorParse","dimensions","x","y","z","colors","classed","xScale","yScale","zScale","colorScale","array2dToString","arr","reduce","a","b","concat","join","init","data","rowKeys","columnKeys","valueMax","summary","valueExtent","dimensionX","dimensionY","dimensionZ","scalePoint","domain","range","scaleLinear","interpolate","interpolateLab","my","selection","each","element","select","surfaceData","coordPoints","Y","map","X","values","d","key","value","coordIndex","ny","length","nx","Array","apply","_","j","i","start","colorFaceSet","color","point","shape","el","append","ifs","attr","surface","selectAll","enter","call","merge","surfaceTransition","transition","exit","remove","_v","arguments","on"],"mappings":"AAAA,OAAO,KAAKA,EAAZ,MAAoB,IAApB;AACA,OAAOC,aAAP,MAA0B,kBAA1B;AACA,SAASC,QAAT,QAAyB,WAAzB;AACA,SAASC,UAAT,QAA2B,gBAA3B;AAEA;AACA;AACA;AACA;AACA;;AACA,eAAe,YAAW;AAEzB;AACA,MAAIC,UAAU,GAAG;AAAEC,IAAAA,CAAC,EAAE,EAAL;AAASC,IAAAA,CAAC,EAAE,EAAZ;AAAgBC,IAAAA,CAAC,EAAE;AAAnB,GAAjB;AACA,MAAIC,MAAM,GAAG,CAAC,MAAD,EAAS,KAAT,CAAb;AACA,MAAIC,OAAO,GAAG,cAAd;AAEA;;AACA,MAAIC,MAAJ;AACA,MAAIC,MAAJ;AACA,MAAIC,MAAJ;AACA,MAAIC,UAAJ;AAEA;AACD;AACA;AACA;AACA;AACA;AACA;;AACC,QAAMC,eAAe,GAAG,UAASC,GAAT,EAAc;AACrC,WAAOA,GAAG,CAACC,MAAJ,CAAW,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAACE,MAAF,CAASD,CAAT,CAArB,EAAkC,EAAlC,EACLF,MADK,CACE,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAACE,MAAF,CAASD,CAAT,CADZ,EACyB,EADzB,EAELE,IAFK,CAEA,GAFA,CAAP;AAGA,GAJD;AAMA;AACD;AACA;AACA;AACA;AACA;;;AACC,QAAMC,IAAI,GAAG,UAASC,IAAT,EAAe;AAC3B,UAAM;AAAEC,MAAAA,OAAF;AAAWC,MAAAA,UAAX;AAAuBC,MAAAA;AAAvB,QAAoCxB,aAAa,CAACqB,IAAD,CAAb,CAAoBI,OAApB,EAA1C;AACA,UAAMC,WAAW,GAAG,CAAC,CAAD,EAAIF,QAAJ,CAApB;AACA,UAAM;AAAEpB,MAAAA,CAAC,EAAEuB,UAAL;AAAiBtB,MAAAA,CAAC,EAAEuB,UAApB;AAAgCtB,MAAAA,CAAC,EAAEuB;AAAnC,QAAkD1B,UAAxD;;AAEA,QAAI,OAAOM,MAAP,KAAkB,WAAtB,EAAmC;AAClCA,MAAAA,MAAM,GAAGV,EAAE,CAAC+B,UAAH,GACPC,MADO,CACAT,OADA,EAEPU,KAFO,CAED,CAAC,CAAD,EAAIL,UAAJ,CAFC,CAAT;AAGA;;AAED,QAAI,OAAOjB,MAAP,KAAkB,WAAtB,EAAmC;AAClCA,MAAAA,MAAM,GAAGX,EAAE,CAACkC,WAAH,GACPF,MADO,CACAL,WADA,EAEPM,KAFO,CAED,CAAC,CAAD,EAAIJ,UAAJ,CAFC,CAAT;AAGA;;AAED,QAAI,OAAOjB,MAAP,KAAkB,WAAtB,EAAmC;AAClCA,MAAAA,MAAM,GAAGZ,EAAE,CAAC+B,UAAH,GACPC,MADO,CACAR,UADA,EAEPS,KAFO,CAED,CAAC,CAAD,EAAIH,UAAJ,CAFC,CAAT;AAGA;;AAED,QAAI,OAAOjB,UAAP,KAAsB,WAA1B,EAAuC;AACtCA,MAAAA,UAAU,GAAGb,EAAE,CAACkC,WAAH,GACXF,MADW,CACJL,WADI,EAEXM,KAFW,CAELzB,MAFK,EAGX2B,WAHW,CAGCnC,EAAE,CAACoC,cAHJ,CAAb;AAIA;AACD,GA7BD;AA+BA;AACD;AACA;AACA;AACA;AACA;AACA;;;AACC,QAAMC,EAAE,GAAG,UAASC,SAAT,EAAoB;AAC9BA,IAAAA,SAAS,CAACC,IAAV,CAAe,UAASjB,IAAT,EAAe;AAC7BD,MAAAA,IAAI,CAACC,IAAD,CAAJ;AAEA,YAAMkB,OAAO,GAAGxC,EAAE,CAACyC,MAAH,CAAU,IAAV,EACdhC,OADc,CACNA,OADM,EACG,IADH,CAAhB;;AAGA,YAAMiC,WAAW,GAAG,UAASpB,IAAT,EAAe;AAElC,cAAMqB,WAAW,GAAG,UAASC,CAAT,EAAY;AAC/B,iBAAOA,CAAC,CAACC,GAAF,CAAM,UAASC,CAAT,EAAY;AACxB,mBAAOA,CAAC,CAACC,MAAF,CAASF,GAAT,CAAa,UAASG,CAAT,EAAY;AAC/B,qBAAO,CAACtC,MAAM,CAACoC,CAAC,CAACG,GAAH,CAAP,EAAgBtC,MAAM,CAACqC,CAAC,CAACE,KAAH,CAAtB,EAAiCtC,MAAM,CAACoC,CAAC,CAACC,GAAH,CAAvC,CAAP;AACA,aAFM,CAAP;AAGA,WAJM,CAAP;AAKA,SAND;;AAQA,cAAME,UAAU,GAAG,UAASP,CAAT,EAAY;AAC9B,cAAIQ,EAAE,GAAGR,CAAC,CAACS,MAAX;AACA,cAAIC,EAAE,GAAGV,CAAC,CAAC,CAAD,CAAD,CAAKG,MAAL,CAAYM,MAArB;AAEA,iBAAOE,KAAK,CAACC,KAAN,CAAY,CAAZ,EAAeD,KAAK,CAACH,EAAE,GAAG,CAAN,CAApB,EAA8BP,GAA9B,CAAkC,UAASY,CAAT,EAAYC,CAAZ,EAAe;AACvD,mBAAOH,KAAK,CAACC,KAAN,CAAY,CAAZ,EAAeD,KAAK,CAACD,EAAE,GAAG,CAAN,CAApB,EAA8BT,GAA9B,CAAkC,UAASY,CAAT,EAAYE,CAAZ,EAAe;AACvD,oBAAMC,KAAK,GAAGD,CAAC,GAAGD,CAAC,GAAGJ,EAAtB;AACA,qBAAO,CAACM,KAAD,EAAQA,KAAK,GAAG,CAAhB,EAAmBA,KAAK,GAAGN,EAAR,GAAa,CAAhC,EAAmCM,KAAK,GAAGN,EAA3C,EAA+CM,KAA/C,EAAsD,CAAC,CAAvD,CAAP;AACA,aAHM,CAAP;AAIA,WALM,CAAP;AAMA,SAVD;;AAYA,cAAMC,YAAY,GAAG,UAASjB,CAAT,EAAY;AAChC,iBAAOA,CAAC,CAACC,GAAF,CAAM,UAASC,CAAT,EAAY;AACxB,mBAAOA,CAAC,CAACC,MAAF,CAASF,GAAT,CAAa,UAASG,CAAT,EAAY;AAC/B,oBAAMc,KAAK,GAAG9D,EAAE,CAAC8D,KAAH,CAASjD,UAAU,CAACmC,CAAC,CAACE,KAAH,CAAnB,CAAd;AACA,qBAAO/C,UAAU,CAAC2D,KAAD,CAAjB;AACA,aAHM,CAAP;AAIA,WALM,CAAP;AAMA,SAPD;;AASAxC,QAAAA,IAAI,CAAC6B,UAAL,GAAkBrC,eAAe,CAACqC,UAAU,CAAC7B,IAAD,CAAX,CAAjC;AACAA,QAAAA,IAAI,CAACyC,KAAL,GAAajD,eAAe,CAAC6B,WAAW,CAACrB,IAAD,CAAZ,CAA5B;AACAA,QAAAA,IAAI,CAACwC,KAAL,GAAahD,eAAe,CAAC+C,YAAY,CAACvC,IAAD,CAAb,CAA5B;AAEA,eAAO,CAACA,IAAD,CAAP;AACA,OApCD;;AAsCA,YAAM0C,KAAK,GAAIC,EAAD,IAAQ;AACrB,cAAMD,KAAK,GAAGC,EAAE,CAACC,MAAH,CAAU,OAAV,EACZzD,OADY,CACJ,SADI,EACO,IADP,CAAd;AAGA,cAAM0D,GAAG,GAAGH,KAAK,CAACE,MAAN,CAAa,gBAAb,EACVE,IADU,CACL,YADK,EACUpB,CAAD,IAAOA,CAAC,CAACG,UADlB,EAEViB,IAFU,CAEL,OAFK,EAEI,KAFJ,CAAZ;AAIAD,QAAAA,GAAG,CAACD,MAAJ,CAAW,YAAX,EACEE,IADF,CACO,OADP,EACiBpB,CAAD,IAAOA,CAAC,CAACe,KADzB;AAGAI,QAAAA,GAAG,CAACD,MAAJ,CAAW,OAAX,EACEE,IADF,CACO,OADP,EACiBpB,CAAD,IAAOA,CAAC,CAACc,KADzB;AAGA,eAAOE,KAAP;AACA,OAfD;;AAiBA,YAAMK,OAAO,GAAG7B,OAAO,CAAC8B,SAAR,CAAkB,UAAlB,EACdhD,IADc,CACR0B,CAAD,IAAON,WAAW,CAACM,CAAD,CADT,EACeA,CAAD,IAAOA,CAAC,CAACC,GADvB,CAAhB;AAGAoB,MAAAA,OAAO,CAACE,KAAR,GACEC,IADF,CACOR,KADP,EAEES,KAFF,CAEQJ,OAFR;AAIA,YAAMK,iBAAiB,GAAGL,OAAO,CAACM,UAAR,GACxBlC,MADwB,CACjB,gBADiB,EAExB2B,IAFwB,CAEnB,YAFmB,EAEJpB,CAAD,IAAOA,CAAC,CAACG,UAFJ,CAA1B;AAIAuB,MAAAA,iBAAiB,CAACjC,MAAlB,CAAyB,YAAzB,EACE2B,IADF,CACO,OADP,EACiBpB,CAAD,IAAOA,CAAC,CAACe,KADzB;AAGAW,MAAAA,iBAAiB,CAACjC,MAAlB,CAAyB,OAAzB,EACE2B,IADF,CACO,OADP,EACiBpB,CAAD,IAAOA,CAAC,CAACc,KADzB;AAGAO,MAAAA,OAAO,CAACO,IAAR,GACEC,MADF;AAEA,KAhFD;AAiFA,GAlFD;AAoFA;AACD;AACA;AACA;AACA;AACA;;;AACCxC,EAAAA,EAAE,CAACjC,UAAH,GAAgB,UAAS0E,EAAT,EAAa;AAC5B,QAAI,CAACC,SAAS,CAAC1B,MAAf,EAAuB,OAAOjD,UAAP;AACvBA,IAAAA,UAAU,GAAG0E,EAAb;AACA,WAAO,IAAP;AACA,GAJD;AAMA;AACD;AACA;AACA;AACA;AACA;;;AACCzC,EAAAA,EAAE,CAAC3B,MAAH,GAAY,UAASoE,EAAT,EAAa;AACxB,QAAI,CAACC,SAAS,CAAC1B,MAAf,EAAuB,OAAO3C,MAAP;AACvBA,IAAAA,MAAM,GAAGoE,EAAT;AACA,WAAOzC,EAAP;AACA,GAJD;AAMA;AACD;AACA;AACA;AACA;AACA;;;AACCA,EAAAA,EAAE,CAAC1B,MAAH,GAAY,UAASmE,EAAT,EAAa;AACxB,QAAI,CAACC,SAAS,CAAC1B,MAAf,EAAuB,OAAO1C,MAAP;AACvBA,IAAAA,MAAM,GAAGmE,EAAT;AACA,WAAOzC,EAAP;AACA,GAJD;AAMA;AACD;AACA;AACA;AACA;AACA;;;AACCA,EAAAA,EAAE,CAACzB,MAAH,GAAY,UAASkE,EAAT,EAAa;AACxB,QAAI,CAACC,SAAS,CAAC1B,MAAf,EAAuB,OAAOzC,MAAP;AACvBA,IAAAA,MAAM,GAAGkE,EAAT;AACA,WAAOzC,EAAP;AACA,GAJD;AAMA;AACD;AACA;AACA;AACA;AACA;;;AACCA,EAAAA,EAAE,CAACxB,UAAH,GAAgB,UAASiE,EAAT,EAAa;AAC5B,QAAI,CAACC,SAAS,CAAC1B,MAAf,EAAuB,OAAOxC,UAAP;AACvBA,IAAAA,UAAU,GAAGiE,EAAb;AACA,WAAOzC,EAAP;AACA,GAJD;AAMA;AACD;AACA;AACA;AACA;AACA;;;AACCA,EAAAA,EAAE,CAAC7B,MAAH,GAAY,UAASsE,EAAT,EAAa;AACxB,QAAI,CAACC,SAAS,CAAC1B,MAAf,EAAuB,OAAO7C,MAAP;AACvBA,IAAAA,MAAM,GAAGsE,EAAT;AACA,WAAOzC,EAAP;AACA,GAJD;AAMA;AACD;AACA;AACA;AACA;;;AACCA,EAAAA,EAAE,CAAC2C,EAAH,GAAQ,YAAW;AAClB,QAAI9B,KAAK,GAAGhD,QAAQ,CAAC8E,EAAT,CAAYxB,KAAZ,CAAkBtD,QAAlB,EAA4B6E,SAA5B,CAAZ;AACA,WAAO7B,KAAK,KAAKhD,QAAV,GAAqBmC,EAArB,GAA0Ba,KAAjC;AACA,GAHD;;AAKA,SAAOb,EAAP;AACA","sourcesContent":["import * as d3 from \"d3\";\nimport dataTransform from \"../dataTransform\";\nimport { dispatch } from \"../events\";\nimport { colorParse } from \"../colorHelper\";\n\n/**\n * Reusable 3D Surface Area Component\n *\n * @module\n */\nexport default function() {\n\n\t/* Default Properties */\n\tlet dimensions = { x: 40, y: 40, z: 40 };\n\tlet colors = [\"blue\", \"red\"];\n\tlet classed = \"d3X3dSurface\";\n\n\t/* Scales */\n\tlet xScale;\n\tlet yScale;\n\tlet zScale;\n\tlet colorScale;\n\n\t/**\n\t * Array to String\n\t *\n\t * @private\n\t * @param {array} arr\n\t * @returns {string}\n\t */\n\tconst array2dToString = function(arr) {\n\t\treturn arr.reduce((a, b) => a.concat(b), [])\n\t\t\t.reduce((a, b) => a.concat(b), [])\n\t\t\t.join(\" \");\n\t};\n\n\t/**\n\t * Initialise Data and Scales\n\t *\n\t * @private\n\t * @param {Array} data - Chart data.\n\t */\n\tconst init = function(data) {\n\t\tconst { rowKeys, columnKeys, valueMax } = dataTransform(data).summary();\n\t\tconst valueExtent = [0, valueMax];\n\t\tconst { x: dimensionX, y: dimensionY, z: dimensionZ } = dimensions;\n\n\t\tif (typeof xScale === \"undefined\") {\n\t\t\txScale = d3.scalePoint()\n\t\t\t\t.domain(rowKeys)\n\t\t\t\t.range([0, dimensionX]);\n\t\t}\n\n\t\tif (typeof yScale === \"undefined\") {\n\t\t\tyScale = d3.scaleLinear()\n\t\t\t\t.domain(valueExtent)\n\t\t\t\t.range([0, dimensionY]);\n\t\t}\n\n\t\tif (typeof zScale === \"undefined\") {\n\t\t\tzScale = d3.scalePoint()\n\t\t\t\t.domain(columnKeys)\n\t\t\t\t.range([0, dimensionZ]);\n\t\t}\n\n\t\tif (typeof colorScale === \"undefined\") {\n\t\t\tcolorScale = d3.scaleLinear()\n\t\t\t\t.domain(valueExtent)\n\t\t\t\t.range(colors)\n\t\t\t\t.interpolate(d3.interpolateLab);\n\t\t}\n\t};\n\n\t/**\n\t * Constructor\n\t *\n\t * @constructor\n\t * @alias surface\n\t * @param {d3.selection} selection - The chart holder D3 selection.\n\t */\n\tconst my = function(selection) {\n\t\tselection.each(function(data) {\n\t\t\tinit(data);\n\n\t\t\tconst element = d3.select(this)\n\t\t\t\t.classed(classed, true);\n\n\t\t\tconst surfaceData = function(data) {\n\n\t\t\t\tconst coordPoints = function(Y) {\n\t\t\t\t\treturn Y.map(function(X) {\n\t\t\t\t\t\treturn X.values.map(function(d) {\n\t\t\t\t\t\t\treturn [xScale(X.key), yScale(d.value), zScale(d.key)];\n\t\t\t\t\t\t})\n\t\t\t\t\t});\n\t\t\t\t};\n\n\t\t\t\tconst coordIndex = function(Y) {\n\t\t\t\t\tlet ny = Y.length;\n\t\t\t\t\tlet nx = Y[0].values.length;\n\n\t\t\t\t\treturn Array.apply(0, Array(ny - 1)).map(function(_, j) {\n\t\t\t\t\t\treturn Array.apply(0, Array(nx - 1)).map(function(_, i) {\n\t\t\t\t\t\t\tconst start = i + j * nx;\n\t\t\t\t\t\t\treturn [start, start + 1, start + nx + 1, start + nx, start, -1];\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t};\n\n\t\t\t\tconst colorFaceSet = function(Y) {\n\t\t\t\t\treturn Y.map(function(X) {\n\t\t\t\t\t\treturn X.values.map(function(d) {\n\t\t\t\t\t\t\tconst color = d3.color(colorScale(d.value));\n\t\t\t\t\t\t\treturn colorParse(color);\n\t\t\t\t\t\t})\n\t\t\t\t\t});\n\t\t\t\t};\n\n\t\t\t\tdata.coordIndex = array2dToString(coordIndex(data));\n\t\t\t\tdata.point = array2dToString(coordPoints(data));\n\t\t\t\tdata.color = array2dToString(colorFaceSet(data));\n\n\t\t\t\treturn [data];\n\t\t\t};\n\n\t\t\tconst shape = (el) => {\n\t\t\t\tconst shape = el.append(\"Shape\")\n\t\t\t\t\t.classed(\"surface\", true);\n\n\t\t\t\tconst ifs = shape.append(\"IndexedFaceset\")\n\t\t\t\t\t.attr(\"coordIndex\", (d) => d.coordIndex)\n\t\t\t\t\t.attr(\"solid\", false);\n\n\t\t\t\tifs.append(\"Coordinate\")\n\t\t\t\t\t.attr(\"point\", (d) => d.point);\n\n\t\t\t\tifs.append(\"Color\")\n\t\t\t\t\t.attr(\"color\", (d) => d.color);\n\n\t\t\t\treturn shape;\n\t\t\t};\n\n\t\t\tconst surface = element.selectAll(\".surface\")\n\t\t\t\t.data((d) => surfaceData(d), (d) => d.key);\n\n\t\t\tsurface.enter()\n\t\t\t\t.call(shape)\n\t\t\t\t.merge(surface);\n\n\t\t\tconst surfaceTransition = surface.transition()\n\t\t\t\t.select(\"IndexedFaceset\")\n\t\t\t\t.attr(\"coordIndex\", (d) => d.coordIndex);\n\n\t\t\tsurfaceTransition.select(\"coordinate\")\n\t\t\t\t.attr(\"point\", (d) => d.point);\n\n\t\t\tsurfaceTransition.select(\"color\")\n\t\t\t\t.attr(\"color\", (d) => d.color);\n\n\t\t\tsurface.exit()\n\t\t\t\t.remove();\n\t\t});\n\t};\n\n\t/**\n\t * Dimensions Getter / Setter\n\t *\n\t * @param {{x: number, y: number, z: number}} _v - 3D object dimensions.\n\t * @returns {*}\n\t */\n\tmy.dimensions = function(_v) {\n\t\tif (!arguments.length) return dimensions;\n\t\tdimensions = _v;\n\t\treturn this;\n\t};\n\n\t/**\n\t * X Scale Getter / Setter\n\t *\n\t * @param {d3.scale} _v - D3 scale.\n\t * @returns {*}\n\t */\n\tmy.xScale = function(_v) {\n\t\tif (!arguments.length) return xScale;\n\t\txScale = _v;\n\t\treturn my;\n\t};\n\n\t/**\n\t * Y Scale Getter / Setter\n\t *\n\t * @param {d3.scale} _v - D3 scale.\n\t * @returns {*}\n\t */\n\tmy.yScale = function(_v) {\n\t\tif (!arguments.length) return yScale;\n\t\tyScale = _v;\n\t\treturn my;\n\t};\n\n\t/**\n\t * Z Scale Getter / Setter\n\t *\n\t * @param {d3.scale} _v - D3 scale.\n\t * @returns {*}\n\t */\n\tmy.zScale = function(_v) {\n\t\tif (!arguments.length) return zScale;\n\t\tzScale = _v;\n\t\treturn my;\n\t};\n\n\t/**\n\t * Color Scale Getter / Setter\n\t *\n\t * @param {d3.scale} _v - D3 color scale.\n\t * @returns {*}\n\t */\n\tmy.colorScale = function(_v) {\n\t\tif (!arguments.length) return colorScale;\n\t\tcolorScale = _v;\n\t\treturn my;\n\t};\n\n\t/**\n\t * Colors Getter / Setter\n\t *\n\t * @param {Array} _v - Array of colours used by color scale.\n\t * @returns {*}\n\t */\n\tmy.colors = function(_v) {\n\t\tif (!arguments.length) return colors;\n\t\tcolors = _v;\n\t\treturn my;\n\t};\n\n\t/**\n\t * Dispatch On Getter\n\t *\n\t * @returns {*}\n\t */\n\tmy.on = function() {\n\t\tlet value = dispatch.on.apply(dispatch, arguments);\n\t\treturn value === dispatch ? my : value;\n\t};\n\n\treturn my;\n}\n"]},"metadata":{},"sourceType":"module"}